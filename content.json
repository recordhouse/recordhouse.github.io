{"pages":[{"title":"About","text":"기록 전용 블로그","link":"/about/index.html"}],"posts":[{"title":"[Algorithm] 인덱스 증가 감소","text":"슬라이드에서 이전 슬라이드, 다음 슬라이드 인덱스 값이 필요할 경우 쓰이는 방법이다. 슬라이드 갯수와 다음, 이전 인덱스 값을 초기 설정해준다. 123var slideLength = 4, next = 0, prev = 0; 알고리즘이 들어갈 함수와 이벤트를 실행시킬 이벤트 리스너가 필요할 것이다. slide 함수를 선언하고 setInterval 함수에다가 이벤트 리스너를 등록하자 1234function slide() { console.log(0);}setInterval(slide, 1000); 1초마다 콘솔창에 0이 출력된다. 이제 1초마다 다음 인덱스에 1을 더하며 그 값을 이전 인덱스에 주자 123456function slide() { next++; console.log(next, prev); prev = next;}setInterval(slide, 1000); 콘솔창이 들어가있는 곳이 추후에 인덱스 다음과 이전 인덱스 값을 받아 처리하는 기능이 들어간다. 콘솔창을 보면 아래와 같이 다음과 이전이 1씩 밀리면서 출력된다. 123456781 0 2 1 3 2 4 3 5 4 6 5 7 6 ... 하지만 슬라이드 갯수는 4개다. 다음 인덱스가 4이상이 되면 0으로 초기화되도록 조건문을 입력하면 된다. 123456789function slide() { next++; if (next &gt;= slideLength) { next = 0; }; console.log(next, prev); prev = next;}setInterval(slide, 1000); 아래와 같이 순차적으로 1씩 밀려서 출력되며, 4이상이 되면 0으로 초기화가 된다. 123456781 0 2 1 3 2 0 3 1 0 2 1 3 2 ... 이제 인덱스가 순차적으로 감소되는 코드를 작성해 보자 123456789function slide() { next--; if (next &lt; 0) { next = slideLength - 1; } console.log(next, prev); prev = next;}setInterval(slide, 1000); 다음 인덱스를 1식 빼고, 다음 인덱스가 0보다 작이질 시 슬라이드 갯수의 1을 뺀 값을 대입하면 된다. 1을 빼는 이유는 프래그래밍에서 수의 시작은 0부터 시작하기 때문이다. 네번째 슬라이드의 인덱스는 3이 될 것이다.","link":"/2017/12/15/algorithm-increase-decrease/"},{"title":"[Algorithm] 배수 구하기","text":"0부터 100까지 특정 배수를 구하는법이다. 반복문과 조건문, 나머지 연산자가 사용된다. 123for (var i = 0; i &lt;= 100; i++) { console.log(i);} i가 증감되면서 콘솔창에 1부터 100까지 차례로 출력될 것이다. 그렇다면 아래의 코드는 어떻게 출력될까? 123for (var i = 0; i &lt;= 100; i++) { console.log(i % 3);} 12345670 1 2 0 1 2 ... 0부터 2는 3으로 나눠지지 않기때문에 첫번째 피연산자가 출력되고 3은 나눠지기 때문에 0이 출력된다. 그 이후로는 3으로 나눈 뒤 나머지가 출력되기 때문에 위처럼 0, 1, 2, 0, 1, 2 .. 로 출력된다. i값이 3으로 나머지 없이 나눠지면 0이 출력되는걸 확인할 수 있다. 이걸 통해 조건문으로 3의 배수를 구할 수 있는 것이다. 12345for (var i = 0; i &lt;= 100; i++) { if (i % 3 === 0) { console.log(i); }} 나머지 없이 3으로 나눠 질때만 i값이 출력된다. 하지만 i값이 0일 때도 같이 출력된다. 다중 조건문을 추가해 주자 12345for (var i = 0; i &lt;= 100; i++) { if (i % 3 == 0 &amp;&amp; i !== 0) { console.log(i); }} 3의 배수가 출력되는걸 확인할 수 있다.","link":"/2017/12/14/algorithm-multiple/"},{"title":"[Algorithm] 구구단 출력하기","text":"자바스크립트로 중첩 반복문을 활용한 구구단 출력하기 예제이다. 예전에 면접볼 때 코딩 테스트에서 해당 문제가 나와 적어본다. 우선 반복문으로 2단의 값을 출력해 보자 123for (var i = 1; i &lt;= 9; i++) { console.log(2 * i);} 123452 4 6 8 ... 정상적으로 출력된다. 이제 이 값을 하나의 변수에 넣어 보자 12345var result = '';for (var i = 1; i &lt;= 9; i++) { result += 2 * i + '\\n';}console.log(result); result에 2단의 값을 차례대로 대입하였더니 정상적으로 출력된다. 이제 답 말고 구구단식도 같이 넣어 보자 12345var result = '';for (var i = 1; i &lt;= 9; i++) { result += '2' + 'x' + i + '=' + 2 * i + '\\n';}console.log(result); 1234567892 x 1 = 2 2 x 2 = 4 2 x 3 = 6 2 x 4 = 8 2 x 5 = 10 2 x 6 = 12 2 x 7 = 14 2 x 8 = 16 2 x 9 = 18 제대로 출력된다. 이제 중첩 반복문을 활용하여 1단부터 9단까지의 모든 구구단을 출력해 보자 1234567var result = '';for (var i = 1; i &lt;= 9; i++) { for (var j = 1; j &lt;= 9; j++) { result += i + 'x' + j + '=' + i * j + '\\n'; }}console.log(result); 로직을 살펴보면, result가 선언되고 외부 반복문이 시작된다. i가 1인 상태에서 내부 반복문으로 들어간다. result에 대입되는 값을 해석해 보면 i에 문자열 x을 더하고 j값을 더한뒤 문자열 = 을 더하고 값을 더한뒤 줄바꿈 처리를 했다. 내부 반복문이 다시 실행된다. i값이 1상태에서 j는 2에서 반복문이 실행된다. i는 몇단인지 구분되는 값이 된다. 이런식으로 중첩되어 값을 계산하고 마지막엔 콘솔창에 값을 출력하게 된다.","link":"/2018/02/20/algorithm-multiplication/"},{"title":"[Algorithm] 랜덤 배열(Shuffle)","text":"아래는 배열을 무작위로 섞는 알고리즘이며, arr배열을 선언한 뒤 각 요소를 랜덤으로 추출하여 newArr라는 새로운 배열에 할당하도록 작성되었다. 123456789101112131415161718192021let arr = [1, 2, 3, 4, 5], newArr = [], len = arr.length, ranIdx = 0, ran = 0, target = 0;console.log(arr);// [ 1, 2, 3, 4, 5 ]for (let i = 0; i &lt; len; i++) { ranIdx = Math.floor(Math.random() * arr.length); ran = arr[ranIdx]; if (arr.indexOf(ran) !== -1) { target = arr.indexOf(ran); arr.splice(target, 1); newArr.push(ran); }}console.log(newArr);// 무작위로 배열 출력 구글링을 하다 더욱 간결한 코드를 발견하였다. 코드는 아래와 같다. 123456789101112function shuffle(a) { let j, x, i; for (let i = a.length; i; i -= 1) { j = Math.floor(Math.random() * i); x = a[i - 1]; a[i - 1] = a[j]; a[j] = x; } console.log(a); // 무작위로 배열 출력}shuffle([1, 2, 3, 4, 5]); shuffle()에 배열을 인자로 넘겨 호출한다. 함수안 반복문의 인덱스 값은 내림차순으로 할당된다. Math.random()로 배열 요소의 난수를 구한 뒤 x에 배열의 마지막 요소를 할당하고, 마지막 요소 자리에 난수를 인덱스로 가지는 요소를 대입한다. 난수를 인덱스 값으로 가지는 요소 자리에는 아까 할당해둔 x값을 대입한다. 이 로직을 반복하여 랜덤 배열을 얻게 된다.","link":"/2020/06/04/algorithm-shuffle-array/"},{"title":"[Algorithm] 중첩 반복문(별찍기)","text":"중첩 반복문의 별찍기 예제이다. 알고리즘 기초 문제로 자주 등장하는 예제중 하나이다. 우선 하단의 별모양으로 찍어보자 12345678910******************************************************* 나는 프로그래밍을 처음 배울때 아래처럼 코드를 작성했었다. 12345var star = '';for (var i = 0; i &lt; 10; i++) { star += '*'; console.log(star);} *이 저장될 star를 선언한뒤 하나씩 *을 한번씩 추가한뒤 반복문이 끝나지 않고 바로 콘솔창으로 출력이 된다. 콘솔창에 10번 출력되면 되는줄 알고 반복문을 왜 중첩으로 사용해야 되지? 라는 짧은 생각을 했었던 적이 있었다. 화면에 출력하는 것도 함수를 호출하는 것이기 때문에 10번 출력한다는 것은 그만큼 비효율적이다. 반복문이 돌아갈때마다 출력하는 것이 아닌, 구해진 값을 담아 한번에 출력해야 좀 더 효율적인 방법이라 할 수 있다. 이렇게 하기 위해선 반복문이 중첩으로 사용되어야 한다. 기본 별찍기12345678var star = '';for (var i = 0; i &lt; 10; i++) { for (var j = 0; j &lt;= i; j++) { star += '*'; } star += '\\n';}console.log(star); 코드를 살펴 보자 외부 반복문에서 i값이 0인 상태로 내부 반복문으로 들어 간다. j가 0으로 선언되고 j와 i를 비교한다. j와 i값은 0과 0으로 같기 때문에 star에 *이 한번 대입되고 내부 반복문을 빠져 나온뒤 줄바꿈문자인 \\n을 star에 대입시킨다. 외부 반복문이 다시 실행된다. i값이 +1 되어 1인 상태에서 다시 내부함수로 들어간다. 내부반복문의 조건은 j값이 i보다 같거나 클 때 실행이 된다. j값은 0으로 초기화되었기 때문에 i값이 1이므로 star에 *을 두번 대입하고 내부반복문을 빠져나오게 되고 다시 \\n을 대입하여 줄바꿈이 이루어진다. 이 과정을 반복하여 열번째 *을 대입하고 마지막으로 결과 값을 콘솔창에 뿌리게 된다. 콘솔창을 보면 제대로 출력된 결과물을 볼 수 있다. 두개씩 별찍기여기서 응용을 하여 아래 모양으로 출력해 보자 12345************************* 별이 2개씩 추가되었다. 외부반복문의 i값이 0일때 별을 한번 찍고, 이후에는 j값이 2의 배수 일때만 내부 반복문을 실행하는 조건을 달아주면 된다. 12345678var star = '';for (var i = 0; i &lt; 10; i++) { for (var j = 0; j &lt;= (i * 2); j++) { star += '*'; } star += '\\n';}console.log(star); 정상적으로 출력되는걸 확인할 수 있다. 역삼각형 별찍기아래처럼 역삼각형으로 나타낼려면 어떻게 되는지 알아보자 1234567891011****************************************************************** 12345678var star = '';for (var i = 10; i &gt;= 0; i--) { for (var j = 0; j &lt;= i; j++) { star += '*'; } star += '\\n';}console.log(star); i값을 10으로 설정한 뒤 i값이 0과 같아질때까지 i값을 빼주면 된다. 정상적으로 코드가 출력되는걸 확인할 수 있다. 가운데 정렬 삼각형 별찍기가운데 정렬 삼각형을 만들어 보자 12345 * *** ***** **************** 5줄로 만들어진 삼각형 이다. 차근차근 살펴 보자, 왼쪽부터 공백이 들어가고 별은 처음 한번 찍힌 뒤 2개씩 늘어나면서 찍힌다. 이제 코드를 확인해 보자 1234567891011var star = '';for (var i = 0; i &lt; 5; i++) { for (var j = 4; j &gt; i; j--) { star += ' '; } for (var k = 0; k &lt;= (i * 2); k++) { star += '*'; } star += '\\n';}console.log(star); 별과 공백이 대입될 star를 선언한 뒤 외부 반복문이 실행 된다. 5줄인 삼각형을 만들계획이니 외부 반복문은 5번만 실행해야 된다. i값이 5보다 작을 때 까지만 조건을 달아주고 내부 반복문으로 들어가고, 공백이 들어갈 반복문이 첫번째로 나온다. 5줄인 삼각형이니 공백은 4칸 대입 다음에 별이 한개 대입되고, 다음에는 공백 3칸에 별 세개, 이런식으로 반복되서 마지막 5줄째에는 공백이 없고 별만 9개가 대입되도록 짜면 될 것이다. 첫번째 내부 반복문에서 공백을 star에 4번 대입하고 빠져 나온다. 두번째 내부 반복문에서는 처음 별 한개를 대입한 뒤 이후에는 2의 배수만큼 별을 대입한다. 두번째 내부 반복문을 빠져나오면 줄바꿈이 대입되고, 외부 반복문이 다섯번 반복되면 이제 콘솔창에 결과값을 출력하게 된다. 다이아몬드 별찍기이제 위에 예제를 응용하여 다이아몬드 형태를 만들어 보도록 하자, 복잡한 예제인 만큼 차근 차근 해석해 보겠다. 123456789 * *** ***** **************** ******* ***** *** * 몇줄인지 보면 아홉줄이다. 9번 실행되는 반복문을 먼저 선언해 주자 1234var star = '';for (var i = 0; i &lt; 9; i++) {} 다이아몬드 형태는 별이 다섯번째 줄까지 증가하다가 그 다음부터는 감소한다. i값이 4가 될 때까지만 별을 증가시켜 주는 조건문을 달고 내부 반복문을 선언해 주자 12345678910111213var star = '';for (var i = 0; i &lt; 9; i++) { if (i &lt; 5) { for (var j = 4; j &gt; i; j--) { star += ' '; } for (var k = 0; k &lt;= i * 2; k++) { star += '*'; } star += '\\n'; }}console.log(star); 12345 * *** ***** **************** 위처럼 제대로 출력된다. 이전 예제에서 해봤기 때문에 어렵지 않게 작성할 수 있다. 이제 i값이 5가되면 별이 감소하는 반복문을 추가한다. 공백을 먼저 넣을 것이다. 눈으로 확인하기 쉽게 우선 공백을 - 로 표기하겠다. 123456789101112131415161718var star = '';for (var i = 0; i &lt; 9; i++) { if (i &lt; 5) { for (var j = 4; j &gt; i; j--) { star += ' '; } for (var k = 0; k &lt;= i * 2; k++) { star += '*'; } star += '\\n'; } else { for (var j = 4; j &lt; i; j++) { star += '-'; } star += '\\n'; }}console.log(star); i값이 4까지만 첫번째 조건문이 실행되고 i값이 5부터는 아래 조건문이 실행된다. 2번째 조건문 반복문을 만나서 j와 i값을 비교한다. j는 4로 선언되고 i는 5 이다. j는 i보다 작다. 참이다. 공백이 한번 찍히고 다시 돌면서 비교를 한다. j는 i와 같은 값인 5가 된다. 거짓이다. 반복문을 빠져나오고 줄바꿈을 한뒤 다시 외부 반복문이 i값을 증감 한다. 이 과정을 반복하면서 아래 모양처럼 출력된다. 123456789 * *** ***** ****************---------- 이제 - 을 공백처리 한 후 별을 찍는 반복문을 추가 해 보자 123456789101112131415161718192021var star = '';for (var i = 0; i &lt; 9; i++) { if (i &lt; 5) { for (var j = 4; j &gt; i; j--) { star += ' '; } for (var k = 0; k &lt;= i * 2; k++) { star += '*'; } star += '\\n'; } else { for (var j = 4; j &lt; i; j++) { star += ' '; } for (var k = 9; k &gt; i; k--) { star += '*'; } star += '\\n'; }}console.log(star); 여기서 좀 복잡해진다. 우선 별 반쪽만 찍어보도록 해보자 123456789 * *** ***** **************** **** *** ** * 아래 조건의 반복문은 i가 5부터 8까지만 4번 실행된다. i값이 5일때 k값과 비교를 한다. k는 9이므로 참이다. 별을 한번 찍고 k값은 차례로 내려간다. k값이 9, 8, 7, 6이 될때까지 별을 네번 찍고 반복문을 빠져 나온다. 이 과정을 거쳐 위 모양처럼 별이 출력된다. 하지만 별은 2개씩 찍혀야 된다. 조건문에 2를 곱해보자 123456789101112131415161718192021var star = '';for (var i = 0; i &lt; 9; i++) { if (i &lt; 5) { for (var j = 4; j &gt; i; j--) { star += ' '; } for (var k = 0; k &lt;= i * 2; k++) { star += '*'; } star += '\\n'; } else { for (var j = 4; j &lt; i; j++) { star += ' '; } for (var k = 9; k &gt; i * 2; k--) { star += '*'; } star += '\\n'; }}console.log(star); 123456789 * *** ***** **************** 출력되지 않는다. 이유는 i값이 배가 되어 k값보다 훨 씬 커지기 때문이다. 처음 비교할때 k값은 9인데 i값은 10이기 때문이다. i값의 최대치는 8인데 배가 되니 16보다 큰 수가 k값으로 대입되어야 한다. 17을 대입해 주자 123456789101112131415161718192021var star = '';for (var i = 0; i &lt; 9; i++) { if (i &lt; 5) { for (var j = 4; j &gt; i; j--) { star += ' '; } for (var k = 0; k &lt;= i * 2; k++) { star += '*'; } star += '\\n'; } else { for (var j = 4; j &lt; i; j++) { star += ' '; } for (var k = 17; k &gt; i * 2; k--) { star += '*'; } star += '\\n'; }}console.log(star); k값은 17, i는 5 * 2 = 10 이다. 참이다. 별을 한번 찍고, 다시 비교, 16 &gt; 10 이다. 이과정을 네번 반복하고 계속 찍어 내려간다. 마지막 i값이 8일때 k는 17 i는 8*2 = 16 참이다. 다시 돌아서 k–은 16 이다. 16 &lt; 16 거짓이다. 반복문을 빠져 나온다. 제대로 출력되는 것을 확인할 수 있다.","link":"/2018/02/21/algorithm-star/"},{"title":"[CSS] 수정, 배포 CSS파일 캐시 방지","text":"웹사이트를 운영중 이미지 및 css 또는 js를 수정해도 반영이 안되어있을 때가 있다. 브라우저 내에 저장되어 있는 캐시 때문인데, 이를 해결하려면 사용자가 직접 캐시를 지우거나 강력 새로고침을 해야하는 번거로운 상황이 있다. 이를 방지하려면 작업자가 수정된 파일의 url 뒤에 ?ver=1라고 쿼리스트링을 붙여주면버전 정보를 적어주면 브라우저가 새로운 파일로 인식하고 파일들을 다시 다운로드 한다. html 1&lt;link type=&quot;text/css&quot; href=&quot;./common.css?ver=1&quot; /&gt; 위 방법은 수정될 때 마다 쿼리스트링을 변경해줘야되는데, 이것도 번거롭다면 자바스크립트를 이용하여 동적으로 랜덤한 쿼리스트링을 생성하여 붙여주는 방법이 있다. javascript 12var bust = Math.floor((Math.random() * 1000));document.write('&lt;link type=&quot;text/css&quot; href=&quot;./common.css?bust=' + bust + '&quot; /&gt;'); 이 방법은 브라우저가 로딩될 때 마다 쿼리스트링 값이 다르기 때문에 항상 파일을 새로 불러오게 된다. References 수정배포된 CSS/JS 파일 캐시 방지","link":"/2020/03/01/cache-css/"},{"title":"[CentOS] CentOS7 PHP 설치","text":"설치환경 CentOS 7.2 Extra Packages for Enterprise Linux (EPEL) repository CentOS CentOS는 리눅스(Linux) 계열의 배포판 버전, 리눅스 계열중에서도 레드햇(RedHat)계열이다. 국내에서 웹 서버로 많이 사용하는 배포판이 센토스(Centos)와 우분투(Ubuntu)이다. Extra Packages for Enterprise Linux (EPEL) repository EPEL (Extra Packages for Enterprise Linux) 은 Fedora Project 에서 제공되는 저장소로 각종 패키지의 최신 버전을 제공하는 community 기반의 저장소이다. wget 설치인터넷에 있는 PHP압축파일을 설치하기 위해선 wget을 설치해야 한다. wget은 인터넷 파일을 다운받는 명령어로서 리눅스 최소 설치 시에는 wget을 따로 설치해야 한다. 아래 Yum 명령어를 이용하여 설치해 준다. Yum Yellow dog Updater, Modified의 약자로 RPM 기반의 시스템을 위한 자동 업데이터 겸 패키지 설치/제거 도구이다. 이전에는 rpm으로 설치하였지만 Yum은 의존성을 고려하여 의존성 패키지까지 자동으로 설치된다. 1# yum install wget wget를 입력하였을 때 아래처럼 출력된다면 제대로 설치가 된 것이다. 1234wget: missing URLUsage: wget [OPTION]... [URL]...Try `wget --help' for more options. remi repository를 yum 에 추가 한다. 123456# wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh epel-release-latest-7.noarch.rpm# wget http://rpms.remirepo.net/enterprise/remi-release-7.rpm# rpm -Uvh remi-release-7.rpm# yum install -y yum-utils# yum-config-manager --enable remi-php72 기존의 설치된 PHP 패키지를 확인하여 잘못된 패키지가 삭제되지 않도록 한다. 1# yum list installed | cut -d &quot; &quot; -f 1 | grep php 기존 설치된 PHP를 제거한다. 1# yum remove -y `yum list installed | cut -d &quot; &quot; -f 1 | grep php` php 패키지 설치한다. php-common 외의 패키지는 자신의 상황에 맞게 조정해서 설치한다. 12345678# yum install -y php-common php-fpm php-cli \\ php-process \\ php-opcache php-pecl-apcu \\ php-mysqlnd php-pdo \\ php-gd \\ php-mbstring php-xml \\ php-pecl-zip \\ php-bcmath “php-common” 대신 “php72w-common”과 같이 PHP 버전을 지정한 패키지를 사용해도 된다. 항상 최신 버전을 사용할 것이 아니라 특정 버전대를 사용해야 한다면 이 방법을 사용하자. 향후 PHP가 버전업되면 운영중인 프로그램과의 호환에 문제가 발생할 수 있으므로 이 방법이 더 안전하다. 단, 메이저 버전업시 기존 패키지를 지우고 설치하는 방법을 사용해야 하므로 불편하다. 기존에 yum으로 설치된 PHP가 존재하고 해당 패키지의 이름이 “php-“로 시작한다면 기존 패키지를 지우고 재설치하는 것보다 아래처럼 그냥 update 받는 방법도 있다. 1# yum update php-* 설치된 php 버전을 확인해 본다. 123456# php -vPHP 7.2.24 (cli) (built: Oct 22 2019 11:15:01) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.24, Copyright (c) 1999-2018, by Zend Technologies References PHP 7.2 설치(업그레이드) [CentOS 7 / remi RPM repository]RHEL/CentOS 5,6,7 에 EPEL 과 Remi/WebTatic Repository 설치하기YUM 명령어와 epel 저장소 추가하는 방법","link":"/2019/10/24/centos-php-install/"},{"title":"[CentOS] CentOS7 Apache 설치","text":"yum을 이용하여 apache를 설치한다. 1# yum -y install httpd apache 버전을 확인하여 설치가 제대로 되었는지 확인해 본다. 1234# httpd -vServer version: Apache/2.4.6 (CentOS)Server built: Aug 8 2019 11:41:18 apache 실행CentOS7부터 기존에 사용하단 service 명령이 실행되지 않을 수 있다. systemctl 명령어를 사용해준다. 1# systemctl start httpd 부팅될 때 마다 apache를 실행 1# chkconfig httpd on 자신의 공인아이피로 들어가보면 apache 서버가 실행되어 있는 확인해 볼 수있다. 자신의 공인아이피를 확인하고 싶다면 curl를 확인해 볼 수 있다. # curl bot.whatismyipaddress.com# curl http://ipecho.net/plain# curl icanhazip.com# curl ipv4.icanhazip.com# curl ipv4.ipogre.com 이제 구동된 서버에 간단한 html 문서를 띄워보자. 아래 경로로 들어간다.(설치된 Apache 버전마다 경로가 다를 수 있다.) /var/www/html/ 해당 디렉토리로 가서 index.html 파일을 만들어준다. 1# touch index.html vi 편집기를 실행하여 “hello world!”를 입력하고 ESC를 누른뒤 아래 명령어를 입력하여 저장하고 나온다. 1# wq 공인아이피로 들어가 보면 “hello world!”가 제대로 출력되는 것을 확인할 수 있다. apache를 재시작할일이 드물기 때문에 종종 명령어를 잃어버린다. 아래 명령어를 참고하도록 한다. Apache 버전 확인 1# httpd -v Apache 상태 확인 12# systemctl status httpd# service httpd status Apache 시작 123# systemctl start httpd# service httpd start# apachectl start Apache 중지 123# systemctl stop httpd# service httpd stop# apachectl stop Apache 재시작 123# systemctl restart httpd# service httpd restart# apachectl restart References CentOS 아파치 설치CentOS에서 apache 설치CentOS 아파치 상태/재시작/시작/중지 명령어리눅스 공인 IP 확인","link":"/2019/10/25/centos-apache-install/"},{"title":"[CentOS] CentOS7 깃 설치 및 로컬 세팅","text":"초기 설치 환경서버 Centos7 Nginx MySQL5.7 PHP7.1 로컬 Homestead Git 설치원격 저장소 만들고 ssh 접속하여 root권한으로 변경 1# su root yum을 이용해서 git 설치 1# yum install git-core yum을 이용해서 git 설치 1# yum install git-core 설치된 영카트 디렉토리로 이동 1# cd /data/web_htdocs/ 깃 초기화 1# git init 파일 상태를 확인해 깃이 잘 설치되어 있는지 확인 1# git status 전역 사용자 등록(원격 저장소에 있는 아이디와 메일이 일치하도록 설정) 12# git config --global user.name &quot;사용자 이름&quot;# git config --global user.email &quot;사용자 메일&quot; 원격 저장소 url을 복사하여 git에 연동 1# git remote add origin `원격 저장소 url` 로컬 소스트리 클론원격 저장소 url 복사 1# git remote add origin `원격 저장소 url` 설치할 디렉토리 경로 맞춘 뒤 클론 1# git remote add origin `원격 저장소 url` 로컬 세팅Homestead.ymal 파일 열고 site 부분에 12map: 로컬 도메인 주소to: vagrant 경로 추가 123$ vagrant reload --provision$ sudo service nginx restart// (nginx 백업 필수 설정 다시 해줄것!) host 파일에 로컬주소 추가(관리자권한으로 실행)C:\\windows\\system32\\drivers\\etc 실서버 디비 백업1$ mysqldump -p db명 &gt; 저장할 파일이름.sql 해당 파일 찾아서 local DB인 Homestead에 넣어주기symlink(): Protocol error 에러 뜰경우 Git Bash 를 관리자 권한으로 실행 후 1$ php artisan storage:link 또는 관리자 권한으로 실행 후 1$ vagrant up 한 다음 새로고침 해볼것 배포 해보기로컬에서 소스 수정 후 commit, push 하고 쉘 접속하여 수정 부분 받기 12$ cd /data/web_htdocs/$ git pull error cannot open .git/fetch_head permission denied 에러 날경우 .git 파일의 권한이 root 여서 오류남, 일반 계정으로 변경 해야함, 루트 계정으로 접속 12345$ su rootPassword: 패스워드 입력chown -R webapp:webapp /data/web_htdocs/.gitls -al 해당 파일 변경해준 권한인지 확인exit 다시 git pull, 그래도 안된다면 1$ git pull origin master 또는 12$ git branch --set-upstream-to=origin/master master$ git pull","link":"/2019/12/11/centos-youngcart-git/"},{"title":"[CentOS] CentOS7 영카트 설치 및 초기 세팅","text":"초기 설치 환경 CentOS 7 사용자 설정로그인 12login as: rootpassword: 최초 세팅된 PW 입력 새 PW 입력 1# passwd webapp 계정 생성 및 새 PW 입력 12# useradd '새 계정 ID'# passwd '새 계정 ID' ssh root 접속 제한 위해 sshd_config 실행 12# vi /etc/ssh/sshd_config# PermitRootLogin yes 에서 no 로 변경 후 저장 ssh 재시작 1# systemctl restart sshd root ssh 접속 되는지 확인 후 webapp으로 접속 후 root로 변경 1# su root Nginx 설치패키기 업그레이드 12# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm Nginx 설치 1# yum install nginx.x86_64 Nginx 활성화 12# systemctl start nginx# systemctl enable nginx 본인 ip주소로 들어가 CentOS 화면이 출력되면 성공 MySQL 설치wget 설치 1# yum install wget MySQL 다운로드 1# wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm MySQL 5.7 설치 1# sudo rpm -ivh mysql57-community-release-el7-11.noarch.rpm MySQL 5.7 서버 설치 1# sudo yum install mysql-server MySQL 5.7 데몬 시작 1# sudo systemctl start mysqld 비밀번호 설정MySQL 접속 1# mysql -u root -p 패스워드 변경**(중요! MySQL 5.7 이후부터 대문자, 숫자, 특수문자 포함된 12자리 이상의 패스워드만 통과한다.)** 123# UPDATE mysql.user SET authentication_string = PASSWORD('패스워드 입력') WHERE User = 'root' AND Host = 'localhost';# FLUSH PRIVILEGES;# exit 만약 로그인이 제대로 되지 않는 경우 1234567# systemctl stop mysqld# systemctl set-environment MYSQLD_OPTS=&quot;--skip-grant-tables&quot;# systemctl start mysqld# mysql -u root // root 계정 비번 없이 접속 가능# UPDATE mysql.user SET authentication_string = PASSWORD('여기에 새로운 비밀번호 입력') WHERE User = 'root' AND Host = 'localhost';# FLUSH PRIVILEGES;# exit 아래와 같은 오류가 뜰 경우You must reset your password using ALTER USER statement before executing this statement. ALTER USER 문을 사용하여 비밀번호 재설정 1# ALTER USER 'root'@'localhost' IDENTIFIED BY '여기에 새로운 비밀번호 입력'; 비밀번호 validation이 까다로우니, 이것을 없애기 위한 설정 12# mysql -u root -p# uninstall plugin validate_password; 데이터베이스 생성1# create database DB 이름; 데이터베이스 확인 1# show databases; 사용자 추가 &amp; 권한 부여(root 로 mysql 접속 후 작업)localhost 로만 접근 가능한 계정 생성(외부에서 워크벤치 등으로 접근 안됨) 1# create user '새로 만들 사용자 ID'@'localhost' identified by '새로운 사용자의 비밀번호'; 외부에서 워크벤치 등으로 접근 가능한 계정 생성 1# create user '새로 만들 사용자 ID'@'%' identified by '새로운 사용자의 비밀번호'; 해당 계정에 해당 데이터베이스의 모든 권한 부여 1# grant all privileges on 'DB 이름'.* to '사용자 ID'@'%'; 해당 계정에 데이터베이스의 모든 권한 부여 1# grant all privileges on *.* to '사용자 ID'@'%'; 해당 계정에 데이터베이스의 모든 권한 부여하고 비번 변경 1# grant all privileges on *.* to '사용자 ID'@'%' identified by '새로운 비밀번호'; 적용후에는 아래 명령어를 꼭 실행 해줘야 한다. 1# FLUSH PRIVILEGES; 외부 접속 설정 (firewall)123# yum install firewalld# systemctl start firewalld# systemctl enable firewalld 서비스 재구동시에는 # firewall-cmd --reload 명령 사용public은 zone 이름이며, 클라우드 시스템처럼 zone 형태로 방화벽 포트들을 관리할수 있음 1# firewall-cmd --permanent --zone=public --add-port=3306/tcp 포트를 범위로 지정하기 1# firewall-cmd --permanent --zone=public --add-port=5000-5100/tcp 포트 삭제 1# firewall-cmd --permanent --zone=public --remove-port=3306/tcp 모든 접속을 허용하고 싶을때(방화벽을 내리지 않고, zone을 trusted로 변경) 1# firewall-cmd --set-default-zone=trusted PHP 설치12345678910111213# yum install yum-plugin-replace# yum install mod_php71w php71w-common# yum install php71w-gd# yum install php71w-fpm# yum install php71w-opcache# yum install php71w-cli# yum install php71w-mysqlnd# yum install php71w-xml# yum install php71w-mbstring# sed -i 's/;date.timezone =/date.timezone = Asia\\/Seoul/g' /etc/php.ini# yum install -y make automake gcc gcc-c++ kernel-devel openssl-devel php php-devel php-pear bzip2-devel libvpx-devel yum-utils bison re2c libmcrypt-devel libpqxx-devel libxslt-devel pcre-devel libcurl-devel libgsasl-devel openldap-devel libmemcached-devel libjpeg-devel libpng-devel readline-devel PHP 활성화 12# systemctl start php-fpm# systemctl enable php-fpm vi /etc/php-fpm.d/www.conf로 들어가서 group = apache를 group = webapp으로 변경, user = apache도 user = webapp 로 변경 필수하드웨어 사양에 따라 pm 관련 세팅 환경 설정nginx conf 파일 세팅 1# vi /etc/nginx/conf.d/www.domain.co.kr.conf 아래와 동일하게 수정한 뒤 server_name 을 본인 IP에 맞게 입력 하고 저장 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051server { listen 80; server_name 00.000.000.000; access_log /var/log/nginx/$host.access.log main; error_log /var/log/nginx/$host.error.log; root /data/web_htdocs; index index.php; client_max_body_size 200M; sendfile on; # Deny dotfiles (**/.*) location ~ /\\. { deny all; } # Deny .php (**/*.php) location ~ \\.php$ { rewrite ^.* /index.php; }location / { index index.php index.html index.htm; try_files $uri $uri/ /index.php?$query_string; error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root /data/web_htdocs; } location ~ \\.php$ { root /data/web_htdocs; try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_buffer_size 128k; fastcgi_buffers 256 16k; fastcgi_busy_buffers_size 256k; fastcgi_temp_file_write_size 256k; include fastcgi_params; } location ~ /\\.ht { deny all; } }} 디렉토리 세팅 및 권한 설정을 위해 data 및 web_htdocs 폴더를 만들어 준다. 12# mkdir /data# mkdir /data/web_htdocs data폴더의 파일 권한과 소유권을 변경해준다. 12# chmod -R 777 /data# chown -R webapp:webapp /data FTP로 youngcart5.tar.gz를 /data/web_htdocs에 업로드 후 압축을 푼다. 123# cd /data/web_htdocs# tar xvfz youngcart5.tar.gz# systemctl restart nginx 본인 아이피주소로 들어가 사용자 정보를 입력하면 자동으로 설치가 완료된다. References MySQL 5.7 세팅 (CentOS7)","link":"/2019/12/10/centos-youngcart-init/"},{"title":"[Debug] 크롬으로 디버깅하기","text":"크롬 개발자 도구의 Sources패널로 디버깅을 할 수 있다. 예제12345678910111213function hello() { return 'hello';}function world() { return 'world';}function greetinf() { var h = hello(); var w = world(); document.getElementById('msg').setAttribute('value', h + w);} 12&lt;input type=&quot;text&quot; id=&quot;msg&quot; /&gt;&lt;button type=&quot;button&quot; onclick=&quot;greetinf()&quot;&gt;click&lt;/button&gt; 버튼을 클릭하면 greetinf함수가 실행되며, h, w변수에 차례대로 값이 할당된 후 인풋 태그에 결과 값(helloworld)이 출력되는 구문이다. 결과 function hello() { return 'hello'; } function world() { return 'world'; } function greetinf() { var h = hello(); var w = world(); document.getElementById('msg').setAttribute('value', h + w); } click 디버깅크롬 개발자 도구의 소스탭을 들어가면 아래 처럼 확인할 수 있다. 개발자 도구는 특정 라인이 아닌 글로벌한 이벤트에 대해 중단점을 만들 수 있다. 좌측 하단의 Event Listener Breakpoints탭으로 들어가 Mouse &gt; click를 체크해준다. 화면으로 넘어가 버튼을 클릭하면 이벤트가 실행되면서 이벤트가 실행된 코드를 소스탭에서 확인할 수 있다. 1. Breakpoints중단점을 이용하면 실행이 중지된 시점에 변수가 어떤 값을 담고 있는지 알 수 있다. 또한 실행이 중지된 시점을 기준으로 명령어를 실행할 수도 있다. 2. Pretty Print압축 파일(min)을 보기 좋게 정렬하여 볼 수 있다. 3. Resume Script Execution(단축키: F8)스크립트 실행을 다시 시작한다. 추가 중단점이 없는 경우, 실행이 쭉 이어지고 디버거는 동작하지 않는다. 4. Step (단축키 F9)다음 명령어를 실행한다. Step버튼을 계속 누르면 스크립트 전체를 문 단위로 하나하나 실행할 수 있다. 5. Step over next function call(단축키 F10)다음 명령어를 실행하되, 함수 안으로 들어가진 않는다. Step과 유사하지만, 다음 문이 함수 호출일 때 Step과는 다르게 동작한다.(alert 같은 내장함수에는 해당하지 않고, 직접 작성한 함수일 때만 동작이 다르다.) Step은 함수 내부로 들어가 함수 본문 첫 번째 줄에서 실행을 멈춘다. 반면 Step over next function call은 보이지 않는 곳에서 중첩 함수를 실행하긴 하지만 함수 내로 진입하지 않는다. 함수 호출 시 내부에서 어떤 일이 일어나는지 궁금하지 않을 때 유용하다. 실행은 함수 실행이 끝난 후에 즉시 멈춘다. 6. Step into next function call(단축키 F11)Step과 유사한데, 비동기 함수 호출에서 Step과는 다르게 동작한다. Step은 setTimeout(함수 호출 스케줄링에 쓰이는 내장 메서드)같은 비동기 동작은 무시한다. 반면 Step into next function call는 비동기 동작을 담당하는 코드로 진입하고, 필요하다면 비동기 동작이 완료될 때까지 대기한다. 7. Step out of current function(단축키 shift + F11)현재 실행 중인 함수의 실행을 계속 이어가다가 함수 본문 마지막 줄에서 실행을 멈춘다. 실수로 Step을 눌러 내부 동작을 알고 싶지 않은 중첩 함수로 진입했거나 가능한 한 빨리 함수 실행을 끝내고 싶은 경우 유용하다. 8. Deactivate breakpoints모든 중단점을 일시적으로 활성화/비활성화한다.(실행에는 영향이 없음) 9. Pause on excepoints활성화되어 있고, 개발자 도구가 열려있는 상태에서 스크립트 실행 중에 에러가 발생하면 실행이 자동으로 멈춘다. 실행이 중단되었기 때문에 변수 등을 조사해 어디서 에러가 발생했는지 찾을 수 있게 된다. 개발하다가 에러와 함께 스크립트가 죽었다면 디버거를 열고 이 옵션을 활성화한 후, 페이지를 새로고침하면 에러가 발생한 곳과 에러 발생 시점의 컨텍스트를 확인할 수 있다. 10. Scope현재 정의된 모든 변수를 출력한다. Local은 함수의 지역변수를 보여준다. 지역 변수 정보는 소스 코드 영역에서도 확인(강조 표시)할 수 있다. Global은 함수 바깥에 정의된 전역 변수를 보여준다. Local 하위 항목으로 this에 대한 정보도 출력된다. 11. Watch표현식을 평가하고 결과를 보여준다. Add watch expression 버튼을 클릭해 원하는 표현식을 입력한 후 Enter를 누르면 중단 시점의 값을 보여준다. 입력한 표현식은 실행 과정 중에 계속해서 재평가된다. Call Stack코드를 해당 중단점으로 안내한 실행 경로를 역순으로 표시한다. References Chrome으로 디버깅하기Chrome DevTools에서 자바스크립트 디버깅 시작하기크롬 개발자 도구를 이용한 자바스크립트 디버깅생활코딩 - Sources","link":"/2020/01/29/chrome-debug-sources/"},{"title":"[Algorithm] 코딩테스트 풀이 - 해시","text":"코딩테스트 플랫폼인 프로그래머스에서 해시 문제 및 풀이를 포스팅해보았다. 언어는 자바스크립트를 기준으로 작성하였다. 해시해시란 데이터를 다루는 기술중 하나로서 해시함수를 이용하여 임의의 길이를 갖는 데이터를 고정된 길이의 데이터로 매핑하는 것을 말한다. 완주하지 못한 선수문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한 사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” 입출력 예 설명예제 #1“leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2“vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3“mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 풀이코드12345678910111213141516171819202122const participant = [&quot;mislav&quot;, &quot;stanko&quot;, &quot;mislav&quot;, &quot;ana&quot;];const completion = [&quot;stanko&quot;, &quot;ana&quot;, &quot;mislav&quot;];function solution(participant, completion) { let answer = &quot;&quot;; // 각 배열을 이름순으로 정렬 participant.sort(); completion.sort(); // 루프를 돌며 이름이 일치하지 않을 경우 결과를 담고 리턴 for (let i = 0; i &lt; participant.length; i++) { if (participant[i] !== completion[i]) { answer = participant[i]; break; } } return answer;}console.log(solution(participant, completion)); 설명반복문을 돌며 이름을 비교할 것이며 그 전에 동명이인이 있을 수 있기 때문에, 각 배열에 sort 함수를 사용하여 이름순으로 정렬한다. 반복문이 돌면서 이름을 매칭해보고 이름이 다를경우 해당 참여자를 응답값에 담고, 완주하지 못한 선수는 단 한명이기 때문에 값을 리턴하고 로직을 빠져나온다. 위장문제 설명스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한 사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_‘ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]] 5 [[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]] 3 입출력 예 설명예제 #1headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. 예제 #2face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. crow_mask blue_sunglasses smoky_makeup 풀이코드12345678910111213141516171819202122232425262728293031const clothes = [ [&quot;yellowhat&quot;, &quot;headgear&quot;], [&quot;bluesunglasses&quot;, &quot;eyewear&quot;], [&quot;green_turban&quot;, &quot;headgear&quot;],];function solution(clothes) { let answer = 1; // 리턴값, 마지막에 곱셉을 하기 때문에 0으로 하면 안됨 let obj = {}; // 의상 종류마다 갯수를 담을 객체 for (let i = 0; i &lt; clothes.length; i++) { // 중복되는 키값이 존재한다면 1 더함 if (obj[clothes[i][1]] &gt;= 1) { obj[clothes[i][1]] += 1; // 처음 등장하는 의상이면 1로 초기화 } else { obj[clothes[i][1]] = 1; } } // 경우의 수 곱셈, (2 + 1) X (1 + 1) for (let key in obj) { answer *= obj[key] + 1; } // 아무것도 입지 않는 경우는 빼줌 return answer - 1;}console.log(solution(clothes)); 설명리턴값은 다른 옷의 조합수로서 이럴땐 경우의 수 공식을 사용하면 된다. 예제 #1로 예를 들면 모자의 경우의수는 2개며 안경의 경우의수는 1개다. headgear: yellowhat, green_turban eyewear: bluesunglasses 경우의 수 공식에 따라, 2 X 1 = 2가 되야하지만, 모자나 안경을 안쓰는 경우도 있으니 각 경우의 수에 1씩 더해주서 (2 + 1) X (1 + 1) = 6이 된다. 여기서 아무것도 입지 않는 경우는 빼야 되므로 최종 경우의 수에 1을 빼준다. 최종적으로 (2 + 1) X (1 + 1) - 1 = 5 수식이 된다. 이 방법으로 코드를 위처럼 작성하면 된다.","link":"/2021/07/13/coding-test-hash/"},{"title":"[Economy] 보험 상품 개발 프로세스 및 보험 용어","text":"보험 개요보험은 질병, 재해, 사망 등 각종 사고와 같은 위험에 대비한 보장을 받기 위하여 가입하는 금융상품이다. 보험상품은 보험사가 만든다고 무조건 출시하는 것이 아니고, 보험개발원의 검증과 금융감독원의 승인이 필수적이다. 보험개발원은 보험요율의 산출과 검증, 보험상품의 개발 등을 하는 곳이다. 보험 개발시장조사, 상품 안 제안고객의 니즈, 시장성 수익성을 고려한 상품 안 제안 상품 안 확정 및 개발에 대한 승인상품개발 위원회를 통해 상품 안 논의, 확정 및 개발 착수에 대한 승인 진행 상품 개발위험을 개발, 외부 기관 검증자료 준비 상품 승인보험개발원 검증 및 금융감독원 승인, 선임계리사 검증 상품 출시 준비상품판매에 필요한 시스템 준비, 판매자 교육 진행 상품공시 판매 모니터링홈페이지 공시 (상품요약서, 약관, 사업 방법서 별지), 완전 판매 관리 보험 판매보험 상품에 대한 금융감독원의 승인이 이루어지면, 대면 및 비대면 방식으로 상품 판매가 시행된다. 대면: 창구에서 판매 비대면: 홈페이지, 모바일, 텔레마케팅으로 판매 텔레마케팅 채널은 전화를 이용하여 판매하는 경우로써 크게 두가지가 있다. 인바운드(Inbound): 보험사 콜센터로 걸려온 고객의 전화를 받아 홍보하는 것 아웃바운드(Outbound): 보험사 콜센터 직원이 고객에게 전화를 걸어 홍보하는 것 각 채널을 통해 보험 상품을 고객에게 판매하였다면, 보험 상품에 대한 계약을 하게 되는데 이를 청약이라고 한다. 청약이 이루어지기 전에 보험사 내부에서는 언더라이팅(Underwriting) 과정을 거치게 되는데, 이는 언더라이터(보험 계약의 인수 여부를 확인하는 사람)들이 고객이 작성한 청약서의 고지내용이나 건강진단 결과 등을 토대로, 최종 심사 과정을 진행하는 것이다. 언더라이팅 과정이 통과되고, 초회 보험료(제 1회 보험료)를 납입하면 이 때부터 효력이 발생하게 되며, 이후 입금하는 보험료를 계속 보험료라고 한다. 이후 계약자는 개인정보 변경, 조건 변경 등 다양한 이유로 계약 조건을 변경할 것이고, 중도해지 등을 하지 않으면 아래 경우로 보험금을 지급받을 수 있다. 만기 &gt; 지금 사고(클레임) &gt; 심사 &gt; 계산 &gt; 지급 보험 종류인(人)보험과 물(物)보험 인보험: 사람에 관하여 발생하는 사고에 대한 보험 물보험: 물건 기타의 재산에 관하여 발생하는 사고에 대한 보험 생명보험, 손해보험, 제3보험 생명보험: 생명/신체에 대한 보장 손해보험: 재산에 대한 보장 제3보험: 생명보험이나 손해보험 중 어느 한 보험으로 분류하기 어려운 보험 보장성보험, 저축성보험 보장성보험: 사망 · 상해 · 입원 · 생존 등과 같은 사람의 생명이나, 재산 피해와 관련하여 보험사고가 발생했을 때 피보험자에게 약속된 급부금을 제공하는 보험 저축성보험: 목돈마련이나 노후생활자금을 대비해주는 보험상품으로 납입한 보험료보다 만기시 지급되는 급부금이 더 많은 보험 추후 추가 예정 보험 용어보험보험같은 종류의 사고를 당할 위험성이 있는 많은 사람이 미리 금전을 각출하여 공통준비재산을 형성하고, 사고를 당한 사람이 이것으로부터 재산적 급여를 받는 경제제도. 보험료보험계약의 당사자 한쪽인 보험계약자가 보험계약에 의거하여 보험자에게 지급하는 요금. 보험금보험사고(생명보험인 경우) 또는 소정의 손해(손해보험인 경우)가 발생한 때에 보험자가 계약자에게 지급하는 금전. 보험자흔히 보험사를 말하며, 보험자는 수익자에게 보험금을 지급할 의무가 있다. 계약자말그대로 보험을 가입한 사람을 말하며, 보험료를 납부할 의무가 있다. 피보험자보험을 통해 보호받을 보험 대상자를 말하고, 생명보험에서는 피보험자, 손해보험에서는 담보물, 목적물 이라고 한다. 피보험자는 여러명 일 수 있다. 부부보험, 가족보험처럼 피보험자를 여러 명 지정할 수 있다. 주피보험자보험의 주대상(1명) 종피보험자함께 가입한 대상(여러명) 수익자피보험자에게 보험 사고가 발생 시 보험금을 받을 수 있는 사람을 말하며, 계약자가 따로 지정하지 않으면 법정 상속인이 수익자가 된다. 계피 동일계약자와 피보험자가 같은 경우 계피 상이계약자와 피보험자가 다를 경우 시기보험 시작일 종기보험 종료일 만기정해진 보험기간이 다 경과하여 끝나는 것 갱신보험 기간이 종료되어 다시 기간을 연장하는 것 보험 개발원보험요율의 산출과 검증, 보험상품의 개발 등을 하는 기관으로써 개인의 보험 가입 정보 등 보험료 계산을 위한 정보를 가지고 있다. 담보, 보장보험이 보장해 주는 것 특약특별보험약관의 줄임말이며, 주 계약의 보장 내용 보완을 위해 주 계약에 부가해서 판매하는 것, 필요하거나 부족한 보장을 자유롭게 선택택하여 가입 가능 플랜미리 짜여진 담보 조합(예: 기본플랜, 표준플랜, 고급플랜) 고지사항보험 계약 전에 고객에게 알려야할 중요한 사항 질병고지본인의 질병에 대해 알릴 사항 청약보험 계약자가 보험 상품에 대한 가입을 위해 의사 표시를 하는 것 References 헷갈리는 보험 용어 알아두기 1편보험[insurance,保險]보험상품상품개발 프로세스","link":"/2020/05/06/economy-insurance-terms/"},{"title":"[Express] Express + React 연동 및 Heroku에 배포하기","text":"헤로쿠(Heroku)란?헤로쿠(Heroku)는 서버 호스팅을 지원하는 클라우드 플랫폼이며, 무료로 서비스를 이용할 수 있는 장점이 있다. 단 무료 버전의 경우 최대 5개의 어플리케이션만 올릴 수 있으며, 30분동안 요청이 없는 경우 사이트는 잠이 든다. 잠이 든 상태에서 다시 요청이 들어오면 깨어나지만, 10초 ~ 30초 가량의 시간이 걸린다는 단점이 있다. 간단한 토이 프로젝트나 포트폴리오 용도로 적합하며, 파일 업로드는 Git을 이용하여 업로드할 수 있다. 이번 포스팅에서는 하나의 디렉토리에 클라이언트와 백앤드로 구성된 프로젝트를 세팅하여 헤로쿠에 배포하는 것까지 진행해 볼 것이다. 클라이언트는 리액트(React)로 구성하고 서버는 익스프레스(Express)로 구성한다. 보통 CRA(Create-React-App)로 리액트 프로젝트를 생성하면 자동으로 서버가 생성되기 때문에 로컬에서 바로 확인이 가능하다. 하지만 익스프레스로 구축한 서버에 리액트를 연동할 경우 두개의 서버(리액트 + 익스프레스)가 존재해 버린다. 로컬에서 작업할 때는 두개의 서버를 돌려 작업할것이며, 실제로 헤로쿠에 배포할 때는 익스프레스 서버에 리액트 빌드 파일을 배포하여 사용할 것이다. 리액트를 빌드하면 build/ 디렉토리에는 웹팩과 바벨 등을 통해 빌드된 번들 등이 담기지만 CRA에서 제공하는 서버는 포함되지 않는다. 디렉토리 구조프로젝트 기본 구조는 아래와 같다. 123456789101112131415161718my-app/├── clinet // 클라이언트(리액트) 영역│ ├── build // 배포 전용 파일│ ├── node_modules│ ├── public // 정적 파일 리소스│ ├── src // 개발 전용 소스│ ├── .gitignore│ ├── package-lock.json│ ├── package.json│ ├── README.md│ └── tsconfig.json│├── node_modules├── .gitignore├── index.js // 백앤드(익스프레스) 영역├── package-lock.json├── package.json└── README.md 프로젝트 초기화 및 익스프레스 설치프로젝트 초기화프로젝트 디렉토리 생성 및 npm 초기화한다. 123$ mkdir my-app$ cd my-app $ npm init -y 익스프레스와 필요 모듈 설치익스프레스 서버 생성 및 필요 모듈 추가한다. 1$ npm install express nodemon concurrently express: 데이터와 통신할 서버로 사용할 것이다.nodemon: node.js를 이용하는 파일들은 수정을 해도 반영이 바로 안되고 서버를 재시작해줘야 반영이 되기 때문에 번거롭다. 노드몬은 코드가 수정될 경우 자동으로 서버를 재시작 해주기 때문에 편리하게 사용할 수 있다.concurrently: 리액트와 익스프레스를 동시 실행해주는 역할을 한다. index.js파일을 생성하여 아래 내용 입력한다. 12345678910111213141516// express 모듈 불러오기const express = require('express');// express 객체 생성const app = express();// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 미들웨어 함수를 특정 경로에 등록app.use('/api/data', function(req, res) { res.json({ greeting: 'Hello World' });});console.log(`server running at http ${port}`); 노드몬으로 서버 구동해보자. 1$ nodemon server http://localhost:5000/api/data경로에 들어가 보면 {&quot;greeting&quot;:&quot;Hello World&quot;}를 확인해 볼 수 있다. 헤로쿠 실행 스크립트 추가헤로쿠 앱을 시작하려면 아래 명령어가 필요하다. package.json파일의 script에 하단 명령어를 추가해 준다. 123&quot;scripts&quot;: { &quot;start&quot;: &quot;node index.js&quot;} 헤로쿠에 배포해보기계정 생성 및 CLI 설치헤로쿠 홈페이지로 들어가 회원가입을 하고 이곳에서 헤로쿠 CLI를 설치한다. 설치가 완료되면 버전을 확인하여 헤로쿠 CLI가 제대로 설치되어 있는지 확인한다. 1$ heroku -v Git 초기화헤로쿠는 Git을 이용하여 업로드한다. 깃을 초기화 하고, 업로드 할 때 node_modules파일들을 무시하도록 .gitignore 파일을 추가한다. 다음에 첫번째 커밋을 해주자. 123$ echo node_modules &gt; .gitignore$ git add .$ git commit -m 'init commit' 헤로쿠 프로젝트 생성아래 명령어를 사용하여 내가 만든 계정에 로그인을 해주자. 명령어 입력 후 아무키나 입력하면 새 브라우저 창이 열리며 내 헤로쿠 계정에 로그인할 수 있다. 1$ heroku login 만약 새 브라우저 창에서 IP address mismatch라는 오류가 뜰 경우 아래 명령어를 이용하여 터미널에서 직접 로그인해준다. 1$ heroku login -i 아래 명령어를 사용하여 내 헤로쿠 계정에 프로젝트를 생성한다. 프로젝트 이름은 url로 사용되기 때문에 다른 헤로쿠 사용자와 중복되면 안되며, heroku create 명령어만 사용할 경우 임의의 이름으로 설정된다. 이후 로컬과 헤로쿠 저장소가 제대로 연결이 되었는지 확인해 본다. 12$ heroku create 프로젝트이름$ git remote -v 헤로쿠에 배포해보자. 1$ git push heroku master 시간이 약간 소요되며 https://프로젝트이름.herokuapp.com/api/data으로 들어가면 {&quot;greeting&quot;:&quot;Hello World&quot;}를 확인해 볼 수 있다. 리액트 설치익스프레스를 설치하였으니 이제 클라이언트 영역인 리액트를 생성하겠다. 이 포스팅에서는 TypeScript를 사용하겠다. client이란 폴더명으로 CRA를 실행한다. 1$ npx create-react-app client --template typescript 조금 기다리면 리액트 앱이 생성될 것이다. /client/src/ 경로의 App.tsx파일을 아래처럼 수정해준다. 12345678910111213141516171819import React from 'react';function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; { fetch('http://localhost:5000/api/data') .then((res) =&gt; { return res.json(); }) .then((data) =&gt; { console.log(data); }); }}&gt;get data&lt;/button&gt; &lt;/div&gt; );}export default App; 버튼을 누르면 fetch 함수를 이용하여 http://localhost:5000/api/data에서 데이터를 가져오겠다는 코드다. 수정하고 client디렉토리로 가서 리액트를 실행한다. 1$ npm start 그럼 브라우저가 열리면서 http://localhost:3000페이지가 나타난다. get data버튼을 누르면 브라우저의 콘솔창에 http://localhost:5000/api/data에서 가져온 JSON 데이터를 출력해야 되는데 아래와 같은 오류가 난다. 1Access to fetch at 'http://localhost:5000/api/data' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled. CORS(Cross-Origin Resource Sharing) 오류로써, 클라이언트와 서버의 포트가 다른 상태에서 클라이언트 측에서 서버 측으로 무언가를 요청했을 때 브라우저가 보안상의 이유로 요청을 차단하는 문제다. 여기서 설정한 리액트(http://localhost:3000)와 익스프레스(http://localhost:5000)는 각 다른 포트를 사용하고 있다. 이럴 경우 프록시 설정을 해줘야 한다. 프록시(Proxy) 설정프록시란 사전적으로 대리, 대리인이라는 의미를 가지고 있으며, 프로토콜에 대한 대리 응답이라는 개념으로 보면 된다. 유저가 요청을 하는 경우 IP 주소가 전달되는데, 이를 프록시 서버가 임의로 IP 주소를 변경할 수 있다. 즉, 유저의 실제 IP를 알 수 없도록 하는 것이 프록시 서버의 역할이다. http-proxy-middleware 모듈을 설치하여 프록시를 설정할 수 있다. client 디렉토리에서 아래 명령어로 설치해 준다. 1$ npm install http-proxy-middleware 다음에 /client/src/ 디렉토리로 가서 setupProxy.js 파일을 생성하고 아래 코드를 입력해준다. 12345678910const { createProxyMiddleware } = require(&quot;http-proxy-middleware&quot;);module.exports = function (app) { app.use( createProxyMiddleware(&quot;/api/data&quot;, { target: &quot;http://localhost:5000&quot;, changeOrigin: true, }) );}; http-proxy-middleware모듈은 앱이 실행될 때 src 디렉토리에서 setupProxy.js파일을 찾은 뒤 이 파일의 설정을 참고하여 프록시를 설정해 준다. /api/data라는 경로로 요청이 들어올 경우 localhost:5000서버를 이용하도록 설정했다. 다시 App.tsx파일을 아래처럼 수정해준다. 12345678910111213141516171819import React from 'react';function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; { fetch('/api/data') .then((res) =&gt; { return res.json(); }) .then((data) =&gt; { console.log(data); }); }}&gt;get data&lt;/button&gt; &lt;/div&gt; );}export default App; 리액트를 재시작 하여 get data버튼을 클릭하면 콘솔창에 {&quot;greeting&quot;:&quot;Hello World&quot;} 데이터가 정상적으로 출력되는 것을 확인할 수 있다. 서버 동시 시작익스프레스와 리액트, 프록시 설정까지 마쳤다. 이제 이 두개의 서버를 동시에 시작해야하는데, 처음에 설치했던 concurrently모듈을 이용하면 된다. 루트 디렉토리의 package.json파일의 script에 아래 부분을 추가한다. 12345&quot;scripts&quot;: { &quot;dev&quot;: &quot;concurrently \\&quot;npm run dev:server\\&quot; \\&quot;npm run dev:client\\&quot;&quot;, &quot;dev:server&quot;: &quot;npm start&quot;, &quot;dev:client&quot;: &quot;cd client &amp;&amp; npm start&quot;} 기존의 실행되있던 서버를 모두 종료 후 아래 명령어를 실행해보면 두개의 서버가 동시에 실행된다. 1$ npm run dev 빌드 빛 배포하기client 디렉토리로 가서 빌드를 해보자 1$ npm run build 빌드가 완료되면 build 디렉토리가 생성되며 안에는 배포용 파일들이 들어있다. 이 정적 파일들이 헤로쿠에서 클라이언트 영역으로 사용되며, 서버는 익스프레스만 구동된다. 따라서 정적 파일에 접근할 수 있도록 Route 설정이 필요하다. index.js 파일을 아래 코드처럼 수정한다. 123456789101112131415161718192021222324252627// express 모듈 불러오기const express = require('express');// express 객체 생성const app = express();// path 모듈 불러오기const path = require('path');// 미들웨어 함수를 특정 경로에 등록app.use('/api/data', function(req, res) { res.json({ greeting: 'Hello World' });});// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 리액트 정적 파일 제공app.use(express.static(path.join(__dirname, 'client/build')));// 라우트 설정app.get('*', (req, res) =&gt; { res.sendFile(path.join(__dirname+'/client/build/index.html'));});console.log(`server running at http ${port}`); 코드를 수정했으면 다시 루트 디렉토리의 package.json파일의 script에 아래 부분을 추가한다. 123&quot;scripts&quot;: { &quot;heroku-postbuild&quot;: &quot;cd client &amp;&amp; npm install &amp;&amp; npm run build&quot;} 이제 헤로쿠에 푸쉬해주자. 123$ git add .$ git commit -m 'build'$ git push heroku master 배포가 완료되고 해당 주소로 들어가 배포가 잘 되었는지 확인해 본다. References Deploy React and Express to Heroku) 배포Express 서버와 React: Proxy 활용과 빌드 및 헤로쿠(Heroku) 배포[React.js] 프록시(Proxy) 설정을 통해 CORS 이슈를 해결해보자!","link":"/2020/11/05/express-react-heroku-init/"},{"title":"[ETC] ESLint, Prettier 적용하기","text":"자바스크립트 개발을 하다 보면 문법 오류나 코드 정리로 인해 시간을 많이 소비한다. ESLint와 Prettier는 이러한 상황을 해결해 주는 도구들이며, VSCode, WebStorm, Atom 등 여러 에디터와 연동해 사용이 가능하다. 이번 포스팅에서는 두가지 도구를 간단히 살펴보고 리액트 프로젝트에 적용하는 방법을 알아보겠다. 에디터는 VSCode를 기준으로 하겠다. ESLintESLint는 ES + Lint의 합성어로 ES는 EcmaScript를 의미하고 Lint는 보푸라기라는 뜻인데, 프로그래밍에서는 에러가 있는 코드에 표시를 달아 놓는 것을 의미한다. 즉 ESLint는 JavaScript의 스타일 가이드를 따르지 않거나 문제가 있는 안티 패턴들을 찾아주고 일관된 코드 스타일로 작성하도록 도와준다. 코딩 컨벤션 및 안티 패턴을 자동 검출 하므로 옮바른 코딩 습관을 위해 필히 사용할 것을 권장한다. ESLint는 스타일 가이드를 편리하게 적용하기 위해 사용되기도 하는데, 많은 개발자가 사용중인 Airbnb Style Guide, Google Style Guide가 대표적인 예이다. ESLint가 어떻게 오류를 잡아주는지 예제를 통해 간단히 알아보자. 123$ mkdir test$ cd test$ touch test.js 프로젝트를 생성할 디렉토리로 이동하여 test 폴더를 만들고 test.js 파일을 생성하였다. 1let foo = text;; 문자열에 따옴표도 없고, 세미콜론도 두개고, 변수에 값이 할당되어도 사용이 안되는 엉망인 코드를 작성하였다. 그냥 js 파일은 문법적 오류를 따로 잡아주지 않을 것이다. ESLint 설치npm 프로젝트를 하나 생성하고 ESLint를 설치하도록 하겠다. 12$ npm init -y$ npm i -D eslint 축약법 간단 설명 npm init -y 명령어에 -y는 --yes의 축약법으로 npm 프로젝트를 초기 세팅할 때 아무 질문 없이 기본값으로 프로젝트가 세팅된다. 비슷한 명령어로 --force(-f)가 있다. npm i -D eslint 명령어의 -D는 --save-dev의 축약법이며, 비슷한 옵션으로 --save가 있다. 차이는 아래를 참고한다. --save-dev는 설치한 패키지 정보를 ./package.json 파일의 devDependencies 항목에 저장하며, npm install을 할 때 해당 패키지가 같이 설치된다. 설치할 때 --production 옵션을 붙이면 해당 패키지를 제외하고 npm이 설치된다. --save는 설치한 패키지 정보가 ./package.json의 dependencies에 추가되며, npm install을 할 때 해당 패키지는 항상 설치가 된다. 아무 옵션을 넣지 않으면 순수하게 ./node_modules에 패키지만 설치한다. 설치가 끝나면 ESLint 실행 파일이 ./node_modules 디렉토리 안에 생성될 것이다. ESLint 설정 파일을 생성하기 위해 아래 명령어를 실행한다. 1$ node_modules/.bin/eslint --init 실행하면 몇가지 질문들이 나온다. 본인의 프로젝트 상황에 맞게 답변을 하면 된다. 123456789101112? How would you like to use ESLint? ❯ To check syntax and find problems? What type of modules does your project use? ❯ None of these? Which framework does your project use? ❯ None of these? Does your project use TypeScript? ❯ No? Where does your code run? ❯ browser? What format do you want your config file to be in? ❯ JavaScript 답변을 전부 마치면 루트 경로에 .eslintrc.js 파일이 생성되며, 여기에서 ESLint를 설정할 수 있다. 12345678910111213module.exports = { &quot;env&quot;: { &quot;browser&quot;: true, &quot;es2020&quot;: true }, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 11, &quot;sourceType&quot;: &quot;module&quot; }, &quot;rules&quot;: { }}; 환경(env): 프로젝트의 사용 환경을 설정한다. 확장(extends): 다른 ESLint 설정을 확장해서 사용할때 설정한다. 위 파일에서는 ESLint가 추천하는 규칙을 적용하라는 설정이며, 실제 프로젝트에서는 위에서 언급한 airbnb나 prettier 등을 확장해서 사용한다. 파서 옵션(parserOptions): ESLint 사용을 위해 지원하려는 Javascript 언어 옵션을 설정할 수 있다. 규칙(rules): 프로젝트에서 자체적으로 덮어쓰고 싶은 규칙을 정의할 때 사용한다. 설정 규칙 및 리스트는 상당히 방대하며, ESLint 공식 레퍼런스에서 참고 가능하다. ESLint 검사이제 위에서 엉망으로 작성한 test.js 파일을 아래 명령어를 사용하여 검사해 보자. 1$ node_modules/.bin/eslint test.js 터미널에서 오류를 세가지를 아래처럼 알려준다. 1234567C:\\code\\test\\test.js 1:5 error 'foo' is assigned a value but never used no-unused-vars 1:11 error 'text' is not defined no-undef 1:16 error Unnecessary semicolon no-extra-semi✖ 3 problems (3 errors, 0 warnings) 1 error and 0 warnings potentially fixable with the `--fix` option. foo에 값이 할당되었지만 사용되지 않음 text가 정의되지 않았음 불필요한 세미콜론이 있음 위에서 3번째 항목에는 오른쪽에 no-extra-semi라고 나와있다. 이는 ESLint가 의도된 것이 아닌 실수라고 판단한 것이며, 자동으로 코드를 수정할 수 있다. 검사 명령어에 --fix를 붙이면 no-extra-semi항목을 자동으로 고쳐준다. 1$ node_modules/.bin/eslint test.js --fix 명령어를 실행하면 세미콜론이 두개에서 한개로 바뀐것을 확인할 수 있다. 실제 프로젝트에서는 검사할 파일이 많은데 위와 같이 일일히 터미널에서 ESLint를 실행하는것은 비효율적이다. 그래서 일반적으로 ESLint를 사용할때는 package.json 파일에 따로 설정해준다. 전체 파일을 상대로 ESLint를 실행되도록 설정해 보자. 123&quot;scripts&quot;: { &quot;lint&quot;: &quot;eslint .&quot;}, 이제 터미널에 아래 명령어를 실행하면 전체 파일을 상대로 ESLint가 실행될 것이다. 1$ npm run lint PrettierPrettier는 기존의 코드에 적용되어있던 스타일들을 전부 무시하고, 정해진 규칙에 따라 자동으로 코드 스타일을 정리해 주는 코드 포멧터이다. 코드 포멧터(Code Formatter)란 개발자가 작성한 코드를 정해진 코딩 스타일을 따르도록 변환해주는 도구를 말한다. ESLint와 다른점이라면 ESLint는 문법 에러를 잡아내고, 특정 문법 요소를 쓰도록 만드는 등 코드 퀄리티와 관련된 것을 고치기 위해 사용되지만 Prettier는 코드 한 줄의 최대 길이나, 탭의 길이는 몇으로 할 것인지, 따옴표는 홀따옴표(‘)나 쌍따옴표(“)중 무엇을 사용 할 것인지 등등 코드 퀄리티보단 코딩 스타일을 일괄적으로 통일하는 도구에 가깝다. 다시 테스트를 위해 test.js에 엉망인 코드를 작성하였다. 1234567let func=function ( ) { let foo ='text'return foo} Prettier 설치Prettier을 아래 명령어로 설치해 준다. 1$ npm i prettier -D -E 위 명령어중 -E는 --save-exac의 축약법이다. 위 ESLint 모듈을 설치할때와 다르게 Prettier에서는 이 옵션을 붙이는 것을 권장하는데, 버전이 달라지면서 생길 스타일 변화를 막기 위해서라고 한다. Prettier 실행1$ npx prettier test.js 위 명령어를 사용하면 엉망인 코드가 아래처럼 올바른 코드로 포멧팅되어 터미널창에 출력이 된다. 1234let func = function () { let foo = &quot;text&quot;; return foo;}; 코드 자체를 수정하고 싶다면 명령어에 --write 옵션을 추가하면 된다. 1$ npx prettier --write test.js 에디터에 아래처럼 코드가 수정된다. 1234let func = function () { let foo = &quot;text&quot;; return foo;}; 이제 리액트 프로젝트에 ESLint와 Prettier를 적용하는 방법을 알아보겠다. 리액트에 ESLint와 Prettier 적용하기이 포스팅에서는 CRA(Create React App)을 이용하여 생성한 리액트 프로젝트를 기준으로 한다. 아래 명령어를 사용하여 리액트 프로젝트를 생성한다. 리액트 프로젝트 생성자바스크립트 사용 경우 1$ create-react-app 프로젝트이름 --use-npm 타입스크립트 사용 경우 1$ create-react-app 프로젝트이름 --use-npm --template typescript CRA로 생성된 프로젝트는 안에 ESLint가 따로 탑재되어 있기 때문에 위처럼 따로 설치할 필요가 없다. 만약 CRA로 생성한 프로젝트에 수동으로 ESLint를 설치한다면, 프로젝트는 실행이 안되고, 터미널에 아래 경고가 출력될 것이다. 12345678910111213141516171819There might be a problem with the project dependency tree.It is likely not a bug in Create React App, but something you need to fix locally.The react-scripts package provided by Create React App requires a dependency: &quot;eslint&quot;: &quot;^6.6.0&quot;Don't try to install it manually: your package manager does it automatically.However, a different version of eslint was detected higher up in the tree: /Users/kongseongjoo/Documents/app/node_modules/eslint (version: 7.5.0) Manually installing incompatible versions is known to cause hard-to-debug issues.If you would prefer to ignore this check, add SKIP_PREFLIGHT_CHECK=true to an .env file in your project.That will permanently disable this message but you might encounter other issues.... 이는 기본 탑재되는 node_module과 수동설치한 node_module의 버전 호환성 문제이며 터미널 경고 아래에 해결 방법이 나온다. CRA로 생성된 프로젝트는 ESLint를 따로 설치를 하지 않도록 한다. Prettier 설치1$ npm i prettier -D -E 필요한 추가 모듈Prettier와 ESLint를 같이 사용하려면 아래 모듈을 추가로 설치해야 한다. eslint-config-prettierESLint의 formatting 관련 설정 중 Prettier와 충돌하는 부분을 비활성화 한다. eslint-plugin-prettierPrettier를 ESLint 플러그인으로 추가한다. 즉, Prettier에서 인식하는 코드상의 포맷 오류를 ESLint 오류로 출력해준다. 아래 명령어를 입력하여 위에서 언급한 모듈을 설치한다. 1$ npm i eslint-plugin-prettier eslint-config-prettier -D 그리고 프로젝트의 루트 경로에 .eslintrc.json파일을 만들고 아래 내용을 추가한다. 1234567{ &quot;plugins&quot;: [&quot;prettier&quot;], &quot;extends&quot;: [&quot;eslint:recommended&quot;, &quot;plugin:prettier/recommended&quot;], &quot;rules&quot;: { &quot;prettier/prettier&quot;: &quot;error&quot; }} ESLint, Prettier 익스텐션 설치Node 모듈을 설치했으니, 이제 VSCode와 같이 사용할 때 필요한 익스텐션을 설치하고 설정을 바꿔주자. VSCode의 Extensions: Marketplace로 들어가서 ESLint와 Prettier를 검색하여 설치한다. VSCode 설정VSCode에서 파일을 저장할 때마다 자동으로 코드가 수정되도록 설정해보자. VSCode 설정(윈도우, 리눅스에서는 Ctrl + , 맥에서는 Cmd + ,)으로 들어간다. 설정으로 들어가면 Search settings 입력창 아래에 User와 Workspace 항목이 있다. User는 VSCode 자체 설정으로 모든 프로젝트에 적용이 되고, Workspace는 현재 프로젝트에서만 설정이 적용되며, .vscode/settings.json에 설정 항목이 저장된다. ESLint와 Prettier의 경우 프로젝트별로 설정이 다른경우가 많이 때문에 작업공간마다 설정파일을 따로 관리하는 것을 선호한다. 설정은 json파일에 직접 입력이 가능하며, 우측 상단에 종이 모양의 Open Setting(JSON)아이콘을 클릭하면 settings.json파일이 열린다. 아래처럼 설정한다. 123456789101112{ // Set the default &quot;editor.formatOnSave&quot;: false, // Enable per-language &quot;[javascript]&quot;: { &quot;editor.formatOnSave&quot;: true }, &quot;editor.codeActionsOnSave&quot;: { // For ESLint &quot;source.fixAll.eslint&quot;: true }} ESLint 설정ESLint 규칙은 상당히 방대하며, 모든것을 다 바꾸기 어렵기 때문에 여러가지 규칙을 정해준 모음이 있는데 위에서 언급한 Airbnb Style Guide나 Google Style Guide가 있다. 여기선 Airbnb를 적용해 보겠다. Airbnb Style Guide 적용아래 명령어를 사용하여 Airbnb를 설치해준다. 1$ npm i -D eslint-config-airbnb eslint-config-airbnb 말고도 eslint-config-airbnb-base가 있는데, 차이는 base에는 리액트 관련 규칙이 들어있지 않다는 점이다. 그리고 .eslintrc.json파일의 &quot;extends&quot;속성에 &quot;airbnb&quot;를 추가 해준다. 1234567{ &quot;plugins&quot;: [&quot;prettier&quot;], &quot;extends&quot;: [&quot;eslint:recommended&quot;, &quot;plugin:prettier/recommended&quot;, &quot;airbnb&quot;], &quot;rules&quot;: { &quot;prettier/prettier&quot;: &quot;error&quot; }} App.js파일을 열어보면 빨간줄이 엄청 그어져 있을 것이다. Airbnb의 규칙이 상당히 까다롭기 때문이다. 꼭 Airbnb 규칙을 따를 필요는 없다. ESLint 문서에서 본인 스타일에 맞는 스타일을 찾거나 수정하여 사용하면 된다. Prettier 설정ESLint 설정 파일과 마찬가지로 루트 경로에 .prettierrc.json을 만들어 준다. Prettier의 옵션 문서에서 필요한 옵션을 골라 설정해 주면 된다. 아래는 간단한 예시이다. 123456{ &quot;trailingComma&quot;: &quot;es5&quot;, &quot;tabWidth&quot;: 2, &quot;semi&quot;: true, &quot;singleQuote&quot;: true} References [자바스크립트] ESLint로 소스 코드의 문제 찾기[자바스크립트] Prettier로 코딩 스타일 통일하기VS Code에서 ESlint와 Prettier 함께 사용하기ESLint 설정 살펴보기27. 리액트 개발 할 때 사용하면 편리한 도구들 - Prettier, ESLint, SnippetESLint 조금 더 잘 활용하기Airbnb JavaScript Style Guide프론트엔드 개발환경의 이해: 린트ESLint(TSLint)와 Prettier 함께 사용하기리액트 프로젝트에 ESLint 와 Prettier 끼얹기ESLint","link":"/2020/07/06/eslint-prettier/"},{"title":"[Git] 깃 커밋 메시지 컨벤션(Git Commit Message Convention)","text":"커밋 메시지는 타입, 제목, 본문(선택), 꼬리말(선택) 세 부분으로 작성한다. [타입(Type)] 제목(Title) 본문(Body) 꼬리말(Footer) 제목 커밋 메세지 제목의 맨 앞에 타입(Type)을 붙여준다. 각 타입의 종류는 아래와 같다. 기능(feat): 새로운 기능을 추가 버그(fix): 버그 수정 리팩토링(refactor): 코드 리팩토링 형식(style): 코드 형식, 정렬, 주석 등의 변경(동작에 영향을 주는 코드 변경 없음) 테스트(test): 테스트 추가, 테스트 리팩토링(제품 코드 수정 없음, 테스트 코드에 관련된 모든 변경에 해당) 문서(docs): 문서 수정(제품 코드 수정 없음) 기타(chore): 빌드 업무 수정, 패키지 매니저 설정 등 위에 해당되지 않는 모든 변경(제품 코드 수정 없음) 총 글자 수는 50자 이내며 마지막에 마침표(.)를 붙이지 않는다. 커밋 유형들이 복합적인 경우 최대한 분리하여 커밋한다. 본문 본문은 한 줄당 72자 이하로 작성한다. 깃은 자동 줄바꿈을 지원하지 않으므로, 직접 줄바꿈을 해야 한다. 내용은 어떻게 변경하였는지 보다 무엇을, 왜 변경하였는지 설명한다. 꼬리말 바닥 글은 선택 사항이며 이슈 트래커 ID를 참조하는데 사용된다. References Git 사용 규칙 - Git commit 메시지Udacity Git Commit Message Style Guide깃허브(GitHub)로 취업하기How to Write a Git Commit Message좋은 git 커밋 메시지를 작성하기 위한 7가지 약속","link":"/2019/11/01/git-commit-message-convention/"},{"title":"[Git] 깃 명령어","text":"자주 쓴 명령어 위주로 작성, 추후 계속 추가 예정 초기화깃 초기화 : 기존 디렉토리를 git 저장소로 만든다. 1$ git init 깃 상태 확인 : 현재 작업중인 브랜치와 파일 상태를 알려준다. 1$ git status 설정전역 사용자 이름 생성 1$ git config --global user.name &quot;your name&quot; 전역 사용자 이메일 생성 1$ git config --global user.email &quot;your_email@youremail.com&quot; 저장소별 사용자 이름 생성 1$ git config user.name &quot;your name&quot; 저장소별 사용자 이메일 생성 1$ git config user.email &quot;your_email@youremail.com&quot; 사용자 설정이 되어 있지 않으면 깃허브의 저장소에 커밋 이력 및 작성자의 아이콘도 ? 로 표시된다. 웬만하면 사용자 설정을 해주도록 하자 저장소 복제하기 1$ git clone &quot;url&quot; 저장소 추가하기 1$ git remote add origin &quot;url&quot; 로컬저장소가 바라보고 있는 저장소의 정보 확인 1$ git remote -v 전역 설정 정보 조회 1$ git config --global --list 저장소 정보 조회 1$ git config --list 파일 추가 및 업로드스테이지에 수정된 파일 업로드 1$ git add 'file name' 스테이지에 수정된 모든 파일 업로드 1$ git add . 커밋하기 1$ git commit -m 'message' 원격 저장소에 업로드 1$ git push origin master 원격 저장소에서 다운로드 1$ git pull origin master 되돌리기스테이지에 올라간 파일 전부 내리기 1$ git reset 이력모든 이력 보기 1$ git log 이력 나가기 1$ q 이력과 변경사항을 함께 보기 1$ git log -p 브랜치지역 브랜치 목록 보기 1$ git branch 원격 저장소 브랜치 목록 보기 1$ git branch -r 지역 브랜치 및 원격 저장소 모든 브랜치 목록 보기 1$ git branch -a 브랜치 생성하기 1$ git branch &quot;branch name&quot; 해당 브랜치로 체크아웃 하기 1$ git checkout &quot;branch name&quot; 브랜치를 생성하고 생성된 체크아웃 하기 1$ git checkout -b &quot;branch name&quot; 해당 브랜치 삭제하기 1$ git branch -d &quot;branch name&quot; 해당 브랜치 강제 삭제하기 1$ git branch -D &quot;branch name&quot;","link":"/2019/10/01/git-command/"},{"title":"[Github] 깃허브 호스팅 페이지에서 404 오류 나올 경우","text":"깃허브 호스팅 페이지가 404에러가 뜰 경우 아래 명령어를 실행하자, 설명은 아래 레퍼런스 참조 12$ git commit --allow-empty -m 'Trigger rebuild'$ git push origin References How to fix HTTP 404 on Github Pages?","link":"/2020/03/03/github-page-404-error/"},{"title":"[HEXO] 헥소를 이용한 깃허브 블로그 만들기","text":"헥소(HEXO)란?정적 웹 사이트(DB 통신 등을 해서 서버에서 HTML 페이지를 실시간으로 만들던 동적 사이트 방식이 아닌, 완성된 HTML 파일을 바로 전달) 생성기이며, 대표적으로 지킬(Jekyll)과 헥소(Hexo)가 있다. 지킬은 Ruby기반이며, 헥소는 Node.js기반의 도구이다. 나는 기존에 지킬 블로그를 이용하다가 최근에 헥소 블로그로 이전하였다. 이유는 지킬 블로그의 경우 포스팅을 작성한 후 깃허브 페이지에 배포하여 반영되기까지 매번 커밋 및 푸쉬를 해줘야 하는 번거로움과 푸쉬 후 약 1분정도의 시간이 지나야 반영이 되는 딜레이가 불편하였다. 헥소같은 경우 빠른 빌드 및 반영(명령어 단 한줄로 실시간 배포 가능) 및 로컬에서 바로 수정사항을 확인할 수 있다는 점(물론 지킬도 루비 기반의 플러그인을 따로 설치하면 로컬에서 바로 확인이 가능함), Node.js 기반의 도구인 점과 마지막으로 icarus테마가 가장 마음에 들어서(사실 이 부분이 제일 큼)이다. 헥소 블로그의 경우, 일반적으로 깃허브 저장소가 2개 사용되는데, 하나는 소스가 빌드 및 배포되어 실질적으로 보여지는 저장소(예: …github.io), 두번째는 실제 소스가 들어있는 저장소(블로그 설정 파일 및 테마 파일)가 있다. 설치 환경 node.js git 헥소(HEXO) 설치초기 세팅npm을 이용하여 헥소를 전역으로 설치 1$ npm install hexo-cli -g 원하는 디렉토리로 이동하여 헥소 블로그 초기 설치(이 포스팅에선 hexo라는 이름으로 초기 설치) 후 해당 디렉토리로 이동하여 노드 모듈 설치 123$ hexo init hexo$ cd hexo$ npm install 설치 후 터미널에서 hexo server명령어를 실행해 준다. 로컬 서버가 구동되면 http://localhost:4000주소로 들어가 보자, 아래 화면이 나온다면 헥소가 정상적으로 설치된 것이다. icarus 테마 적용이제 icarus 테마를 적용할 것이다. 우선 icarus 저장소로 가서 테마를 다운 받은 뒤 압축을 풀어준다. 압축을 풀어주면 hexo-theme-icarus-master폴더가 있는데, icarus라고 이름을 변경한 뒤 hexo폴더의 themes폴더 안에 넣어준다. 기존의 landscape(기본 테마)는 삭제해 준다. 이제 설정 파일에서 테마를 icarus로 사용한다고 정해줘야 한다. hexo폴더 루트 경로에 _config.yml파일이 있다. 이 파일이 헥소 기본 설정파일이며, 여기서 전반적인 사이트 설정을 할 수 있다. theme 항목을 icarus로 수정해 준다. 1theme: icarus 수정한 뒤 아래 명령어로 로컬서버를 다시 실행해 본다. 1$ hexo server 서버가 정상적으로 실행이 안되고 아래 처럼 에러가 날 것이다. 1234567ERROR Package bulma-stylus is not installed.ERROR Package hexo-component-inferno is not installed.ERROR Package hexo-renderer-inferno is not installed.ERROR Package inferno is not installed.ERROR Package inferno-create-element is not installed.ERROR Please install the missing dependencies your Hexo site root directory:ERROR npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.2.4 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 icarus테마는 위 패키지 설치가 필요해 보인다. 필요 패키지를 다시 설치한다. 1$ npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.2.4 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 설치한 후 다시 서버를 실행하면 성공적으로 icarus테마 사이트가 만들어 진다. about 페이지 생성살펴보니 about 페이지가 존재하지 않는다. 아래 명령어를 실행하여 페이지를 만들어 준다. 1$ hexo new page about 명령어를 실행하면 /sources/about/ 경로에 index.md파일이 생성된다. 이 파일에 원하는 내용을 작성하면 된다. 블로그 작성 하기헥소 블로그는 터미널에서 아래 명령어를 실행하여 마크다운 파일을 생성할 수 있다. 1hexo new post 포스트명 정해진 규칙은 아니지만 나는 범주-내용형식으로 포스트명을 지었다.(예: 자바스크립트의 클로저 포스팅일 경우 javascript-closure 라고 명명) /sources/_posts/ 경로에 마크다운 파일이 새로 생성되며 이곳에 포스팅을 작성하면 된다. 마크다운 문법은 MarkDown 사용법 총정리에 설명이 잘 되어있다. 깃허브 페이지에 배포하기이제 깃허브 페이지에 배포를 해보자 깃허브 저장소(배포 페이지) 생성우선 헥소 블로그는 2개의 저장소를 사용하는데, 한개는 배포 페이지(보여지는 블로그 페이지)로 사용되며 한개는 실제 소스가 들어가는 저장소다. 우선 배포 페이지 저장소를 만들어 준다. 저장소 이름은 사용자계정.github.io로 만들어 준다. 깃허브 페이지가 정상적으로 호스팅 되는것을 확인하기 위해 Initialize this repository with a README는 체크해 준다. 저장소가 생성 되면 README.md도 같이 생성이 된다. 이제 settings페이지로 가서 GitHub Pages항목에서 Source 옵션을 master branch로 선택해 준다. Your site is published at https://사용자계정.github.io/라는 문구가 뜨며, 이제 https://사용자계정.github.io주소로 들어가면 페이자가 정상으로 출력되는 것을 확인할 수 있다. 깃허브 저장소 주소 설정배포하기전 헥소 설정 파일에서 배포할 저장소를 입력해줘야 한다. hexo폴더 루트 경로에 _config.yml파일에 가면 아래 항목이 있다. 12deploy: type: '' 위 항목을 아래처럼 설정해 준다. 1234deploy: type: git repo: 저장소 주소(예: https://github.com/사용자계정/사용자계정.github.io.git) branch: master 배포 플러그인 설치깃허브 페이지에 배포하기 위해선 hexo-deployer-git플러그인을 설치해줘야 한다. 아래 명령어를 사용하여 설치해 준다. 1npm install --save hexo-deployer-git 정적 리소스 생성하기아래 명령어를 실행하면 public폴더가 생성되면서 정적 리소스가 생성된다. 이 파일들이 실제로 깃허브 페이지에 배포될 파일들이다. 1$ hexo generate 배포하기아래 명령어를 사용하면 생성한 정적 리소스를 배포하게 된다. 사용자계정.github.io주소로 들어가면 정상적으로 배포된 것을 확인할 수 있다. 1$ hexo deploy 정적 리소스를 삭제하는 명령어는 아래 명령어를 사용하면 된다. 간혹 정상적으로 배포가 되었음에도 불구하고 페이지가 업데이트 되지 않는 현상이 있는 경우 사용하면 된다. 1$ hexo clean 정적 리소스 및 배포를 동시에 하고싶다면 아래 명령어를 사용하면 된다. 1$ hexo deploy --generate 깃허브 저장소에 소스 저장하기위의 배포 과정은 보여지는 페이지를 저장한 것이고, 이제 실제 소스를 깃허브 저장소에 저장할 것이다. 새로운 저장소를 만들어 준다. 나는 hexo라고 저장소를 생성하였다. 다시 hexo폴더로 가서 아래 명령어를 입력해 깃을 설치하고, 소스가 들어갈 저장소를 선택한 뒤 푸쉬해준다. 12345$ git init$ git remote add origin 저장소 주소$ git add .$ git commit -m '커밋 메세지'$ git push origin master 간혹 깃의 히스토리가 충돌되어 푸쉬가 안되는 경우가 있는데 이런 상황에는 아래 명령어를 사용하여 해결해 준다. 1$ git pull origin 브랜치명 --allow-unrelated-histories References Github Page와 Hexo를 통해 30분만에 기술 블로그 만들기Github 블로그 만들기 with Hexo - 초기설정Jekyll을 이용한 무료 블로그 만들기","link":"/2020/04/20/github-hexo-init/"},{"title":"[GitHub] 깃허브 블로그(Jekyll) SEO 세팅","text":"검색 엔진 최적화(Search Engine Optimization)검색엔진이 이해하기 쉽도록 홈페이지 구조를 설정하여 포털 사이트 상위에 노출시키는 작업이다. jekyll으로 제작된 깃허브 블로그에 SEO 작업을 진행하겠다. Sitemap 웹 크롤링 로봇이 이용할 수 있는 웹사이트의 접근 가능한 페이지의 목록 사이트맵을 등록하면 구글에서 주기적으로 크롤링을 한 뒤 관련 검색어로 검색 시 해당 사이트가 노출이 된다. sitemap.xml 파일을 사용하면 사이트 구조를 구글, 네이버, 다음 등 검색엔진에 손 쉽게 제출할 수 있다. 검색엔진에 크롤링해야하는 URL을 알려줌으로써 색인을 생성하는 방법과 색인을 생성하는 방법을 제어한다. Sitemap.xml 생성하기아래 내용으로 sitemap.xml 파일을 만들고 root 경로 넣어준다. 1234567891011121314151617181920212223242526272829---layout: null---&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd&quot; xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt; {% for post in site.posts %} &lt;url&gt; &lt;loc&gt;{{ site.url }}{{ post.url }}&lt;/loc&gt; {% if post.lastmod == null %} &lt;lastmod&gt;{{ post.date | date_to_xmlschema }}&lt;/lastmod&gt; {% else %} &lt;lastmod&gt;{{ post.lastmod | date_to_xmlschema }}&lt;/lastmod&gt; {% endif %} {% if post.sitemap.changefreq == null %} &lt;changefreq&gt;weekly&lt;/changefreq&gt; {% else %} &lt;changefreq&gt;{{ post.sitemap.changefreq }}&lt;/changefreq&gt; {% endif %} {% if post.sitemap.priority == null %} &lt;priority&gt;0.5&lt;/priority&gt; {% else %} &lt;priority&gt;{{ post.sitemap.priority }}&lt;/priority&gt; {% endif %} &lt;/url&gt; {% endfor %}&lt;/urlset&gt; 해당 파일을 커밋, 푸쉬 한다. 블로그 주소/sitemap.xml 에 들어가서 제대로 사이트맵이 등록되었는지 확인해 보자 홈페이지의 모든글의 정보를 담고있는 사이트맵이 출력되는 것을 알 수 있다. 추후에 블로그 포스팅을 푸쉬 하면 jekyll이 빌드하면서 사이트맵도 자동으로 갱신된다. 사이트 맵에서 특정글의 정보를 변경하고 싶으면 아래와 같이 특정 글의 설정 값을 변경해 주면 된다. changefreq를 너무 짧게 하면 빈번한 접속으로 안좋은 영향을 미칠수 있다고 한다. 설정이 없을때 default 값은 사이트맵에 정의되어 있다. 12345678layout: posttitle: &quot;제목&quot;date: 0000-00-00 12:00:00 lastmod : 0000-00-00 12:00:00sitemap : changefreq : daily priority : 1.0--- 참고로 /sitemap.xml을 실행했을 때 제대로 안나오는 경우가 있는데, 주소 링크에 특수문자가 들어간 경우이다. 깃허브 블로그의 경우 포스팅 파일명으로 링크가 생성되므로 포스팅 파일명은 특수문자 및 한글 사용을 안하도록 한다. RSS RSS(Rich Site Summary)란 뉴스나 블로그 사이트에서 주로 사용하는 콘텐츠 표현 방식이며, 웹 사이트 관리자는 RSS 형식으로 웹 사이트 내용을 보여 준다. RSS피드는 정기적으로 업데이트 되는 웹 콘텐츠를 전달해 주는 형태이며, 글의 전체 혹은 요약된 정보와 작성자 등의 정보가 포함되어 있다. 즉 블로그의 글을 작성하면 RSS피드에도 전달이 되고, 구글, 네이버, 다음 등을 통해 글을 검색하면, 검색 엔진은 블로그의 RSS피드로부터 글을 받게 되어 해당 블로그로 들어오게 된다. RSS feed.xml 생성하기 사이트맵과 동일하게 아래 코드를 넣어준 뒤 feed.xml 파일을 만들고 root 경로에 넣어준다. 123456789101112131415161718192021222324252627282930---layout: null---&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;rss version=&quot;2.0&quot; xmlns:atom=&quot;http://www.w3.org/2005/Atom&quot;&gt; &lt;channel&gt; &lt;title&gt;{{ site.title | xml_escape }}&lt;/title&gt; &lt;description&gt;{{ site.description | xml_escape }}&lt;/description&gt; &lt;link&gt;{{ site.url }}{{ site.baseurl }}/&lt;/link&gt; &lt;atom:link href=&quot;{{ &quot;/feed.xml&quot; | prepend: site.baseurl | prepend: site.url }}&quot; rel=&quot;self&quot; type=&quot;application/rss+xml&quot;/&gt; &lt;pubDate&gt;{{ site.time | date_to_rfc822 }}&lt;/pubDate&gt; &lt;lastBuildDate&gt;{{ site.time | date_to_rfc822 }}&lt;/lastBuildDate&gt; &lt;generator&gt;Jekyll v{{ jekyll.version }}&lt;/generator&gt; {% for post in site.posts limit:30 %} &lt;item&gt; &lt;title&gt;{{ post.title | xml_escape }}&lt;/title&gt; &lt;description&gt;{{ post.content | xml_escape }}&lt;/description&gt; &lt;pubDate&gt;{{ post.date | date_to_rfc822 }}&lt;/pubDate&gt; &lt;link&gt;{{ post.url | prepend: site.baseurl | prepend: site.url }}&lt;/link&gt; &lt;guid isPermaLink=&quot;true&quot;&gt;{{ post.url | prepend: site.baseurl | prepend: site.url }}&lt;/guid&gt; {% for tag in post.tags %} &lt;category&gt;{{ tag | xml_escape }}&lt;/category&gt; {% endfor %} {% for cat in post.categories %} &lt;category&gt;{{ cat | xml_escape }}&lt;/category&gt; {% endfor %} &lt;/item&gt; {% endfor %} &lt;/channel&gt;&lt;/rss&gt; 해당 파일을 커밋, 푸쉬 하고 블로그 주소/feed.xml 에 제대로 등록되었는지 확인해 보자. robots.txtrobots.txt는 로봇 배제 표준을 따르는 일반 텍스트 파일이다. 쉽게 표현하면 검색 엔진이 해당 사이트의 콘텐츠를 가져가도 허락하는 부분과 가져가면 안된다 라는 설정을 하는 부분이라고 보면 된다. 위와 동일하게 root 경로에 위치한다. robots.txt 생성 robots.txt 파일을 만들고 아래와 같이 입력한다. 1234User-agent: *Allow: /Sitemap: https://recordboy.github.io/sitemap.xml User-agent는 허용할 검색엔진 명을 넣게 된다. 따로 설정하지 않으면(*) 모든 검색엔진을 허용하게 된다. Sitemap은 본인 블로그 사이트맵 주소를 넣어 주면 된다. 블로그 등록본인 블로그를 등록 해야 구글 및 네이버에서 검색이 가능하다. Google Search Console Google Search Console에 접속한다. SEARCH CONSOLE 버튼을 클릭한다. 속성 유형 선택화면이 나오면 URL 접두어 방식을 선택 후 해당 블로그 주소를 등록한다. 메타 태그를 이용한 사이트 소유권을 확인한 뒤 사이트맵을 등록해주면 된다. (여기에 설명이 참 잘 되어있다.) 구글 애널리틱스에 같은 계정으로 가입이 되어있으면 자동으로 소유 확인이 된다. Naver Webmaster 네이버 웹마스터 도구에 접속한다. 로그인하고 블로그 주소를 등록해 사이트를 추가해 준다. 웹마스터 도구에서 제공하는 html 파일을 다운받아 본인 블로그에 업로드하거나 메타태그를 이용하는 방법으로 사이트 소유권을 확인한다. 왼쪽 요청 메뉴로 들어가 사이트맵을 제출해준다. 깃허브에서 공식적으로 지원하는 jekyll블로그는 RSS2.0이 아닌, ATOM이라는 방식으로 feed.xml을 생산해준다. 그리고 ATOM방식으로 제작된 피드는 네이버 웹마스터도구에 등록이 안된다. References github blog를 google에서 검색되도록 설정하기구글(Google) 검색에 내 사이트 등록하기홈페이지 검색 잘 되도록 만들기RSS피드란?robots.txt 파일 만들기","link":"/2019/12/01/github-seo-setting/"},{"title":"[IATC] 웹 접근성 정의 및 대비 방법","text":"2019년 11월 22일 정보접근성 기술 컨퍼런스를 다녀온뒤 세미나 내용을 정리 및 웹 접근성에 대해 작성한 글이다. 웹 접근성이란?웹 접근성(Web Accessibility) 이란 장애인, 고령자 등이 웹 사이트에서 제공하는 정보에 비장애인과 동등하게 접근하고 이해할 수 있도록 보장하는 것이다. 법으로는 2017년 7월 26일부터 장애인차별금지법으로 시행되었다. 장애인 차별금지 및 권리구제 등에 관한 법률제 2조(장애와 장애인) 이 법에서 금지하는 차별행위의 사유가 되는 장애라 함은 신처적, 정신적 손상 또는 기능상실이 장기간에 걸쳐 개인의 일상 또는 사회생활에 상당한 제약을 초래하는 상태를 말한다. 장애인이라 함은 제1항에 따른 장애가 있는 사람을 말한다. 웹 접근성은 정보와 사용자의 디지털정보격차를 줄인다는 개념으로도 볼 수 있다. 디지털정보격차(Digital Divide)란? 정보통신기술에서의 접근, 역량, 활용에 있어서의 불평등 사회자원에서의 접근, 역량, 활용에 있어서의 불평등 또한 접근성에서의 ‘장애’는 개인의 건강상태가 아니라 인간 상호작용이 일치하지 않는 상황으로 볼 수 있고, 접근성은 아래와 같은 의미로도 해석할 수 있다. 각자 다른 능력을 가진 사람들이 모든 것을 경험할 수 있도록 가능성을 만들어 주는것 그리고 이를 달성하기 위해 전문가들이 노력하는 것 정보통신 환경의 장애유형과 보완대책 장애유형 특징 보완대책 시각장애(전맹) 모니터를 볼 수 없음 스크린리더 시각장애(저시력) 모니터 사용이 일부 가능함 화면확대/고대비 시각장애(색맹) 색을 구별할 수 없음 색상에만 의존하지 않기/고대비 청각장애 사운드, 오디오 등을 창취할 수 없음 수화, 시각정보 제공 지체장애(상지장애) 손을 사용할 수 없음 마우스 대체 방법, 키보드만 사용 지체장애(기타) 움직임이 어려움 충분한 시간 제공 언어장애 복잡한 용어, 어려운 용어의 이해 불가능 쉬운 용어 사용 웹 접근성 국제표준 검사항목(KWCAG)웹 접근성 한국표준이며 가이드는 한국형 웹 콘텐츠 접근성 지침 2.1 에서 확인해 볼 수 있다. 항목은 24가지 이며 국제표준(WCAG)은 더욱 엄격하여 항목으로는 78가지가 있다. 인식의 용이성 - 사람은 콘텐츠를 보거나 들을 수 있다. 적정한 대체 텍스트 텍스트 아닌 콘텐츠는 대체 가능한 텍스트와 함께 제공되어야 한다. 자막, 수화 등의 제공 영상이나 음성 콘텐츠에는 동등한 내용의 자막, 원고 또는 수화가 제공되어야 한다. 색에 무관한 콘텐츠 인식 화면에 표시되는 모든 정보는 색에 관계없이 인식될 수 있어야 한다. 명확한 지시사항 제공 특정한 감각(시각, 청각 등)에 의존하여 지시사항을 제공할 경우 해당 감각에 장애가 있다면 인식할 수 없으므로, 다른 감각을 통해서도 인식할 수 있도록 지시사항을 제공해야 한다. (3, 4번 항목의 예: 콘텐츠 구분 접근성) 텍스트 콘텐츠 명도 대비 화면에 표시되는 모든 사용자 인터페이스 컴포넌트와 텍스트는 전경색과 배경색이 구분될 수 있도록 제공되어야 한다.(예: 명도 대비 접근성) 자동 재생 금지 자동으로 재생되는 배경음을 사용하지 않아야 한다. 구글은 사용자가 원치 않은 미디어가 자동 재생되면서 데이터와 전력을 소모하고, 웹 탐색 중 소음을 유발한다는 이유로 2018년 1월부터 크롬 브라우저는 웹 사이트에서 자동으로 재생되는 영상을 기본 설정에서 차단한 사례가 있다. 콘텐츠 간의 구분 이웃한 콘텐츠는 구별될 수 있어야 한다. 운용의 용이성 - 사람이 타이핑이나 음성으로 컴퓨터를 사용할 수 있다. 키보드 사용 보장 모든 기능은 키보드만으로도 사용할 수 있어야 한다. 초점 이동 키보드의 Tab키(다음으로 이동)와 Shift + Tab(이전으로 이동)키로 확인해볼 수 있다. 초점 이동 순서가 순환적이며, 반복적이어야 한다. 페이지에 포함된 모든 링크, 버튼, 입력창에 초점이 가야한다. 사용자가 사용할 수 없는 비활성 요소(버튼, 입력창 등)에는 초점이 가지 않아야 한다. 조작 가능 손떨림이 심하여 미세한 조작이 어려운 경우와 같이 운동 장애가 있는 경우에도 사용자 입력 및 컨트롤은 조작이 가능하도록 제공되어야 한다. 응답시간 조절 웹 콘텐츠 제작 시 시간제한이 있는 콘텐츠는 가급적 포함하지 않는 것이 바람직하며, 보안 등의 사유로 시간제한이 반드시 필요할 경우에는 이를 회피할 수 있는 수단을 제공해야 한다.(일시 정지 등) 정지기능 제공 자동으로 변경되는 콘텐츠는 움직임을 제어할 수 있어야 한다. 깜빡임과 번쩍임 사용 제한 초당 3~50회 주기로 깜빡이거나 번쩍이는 콘텐츠를 제공하지 않아야 한다. 반복영역 건너뛰기 콘텐츠의 반복되는 영역은 건너뛸 수 있어야 한다.(스킵 네비게이션) 제목 제공 페이지, 프레임, 콘텐츠 블록에는 적절한 제목(헤딩 태그)을 제공해야 한다. 적절한 링크 텍스트 링크 텍스트는 용도나 목적을 이해할 수 있도록 제공해야 한다.(새창 열림 및 더보기) 이해의 용이성 - 사람이 명확하고 단순한 언어로 사용할 수 있다. 기본언어 표시 주로 사용하는 언어를 명시해야 한다. 웹 페이지에 주로 사용하는 언어를 &lt;html&gt; 요소에 lang 속성을 지정하여 명시 사용자 요구에 따른 실행 사용자가 의도하지 않은 기능(새 창, 초점 변화 등)은 실행되지 않아야 한다. 콘텐츠 선형구조 콘텐츠는 논리적인 순서로 제공해야 한다. 콘텐츠 및 마크업이 논리적인 순서로 구성해야 한다. 표의 구성 표는 이해하기 쉽게 구성 및 caption 및 scope을 꼭 명시해 준다. 복잡한 표의 경우 id, header 를 사용한다. 레이블 제공 입력 서식에는 대응하는 레이블을 제공해야 한다. 오류정정 입력 오류를 정정할 방법을 제공해야 한다. 견고성 - 사람들이 다른 보조 기술을 사용할 수 있다. 마크업 오류 방지 마크업 언어의 요소는 열고 닫음, 중첩 관계 및 속성 선언에 오류가 없어야 한다. 웹어플리케이션 접근성 준수 콘텐츠에 포함된 웹 애플리케이션은 접근성이 있어야 한다. 대비해야 할 대표 기술 8가지1. 시멘틱 마크업W3C는 텍스트를 시각적으로 표현하는 태그보다 프로그램적으로 의미를 전달할 수 있는 시멘틱 마크업 사용을 권장한다. 웹 사이트는 결론적으로 ‘웹으로 된 문서’이기 때문이다. 예시 보통 아이콘을 &lt;i&gt; 태그를 사용하지만 이 태그는 이태릭체를 의미하는 태그이다. 아이콘으로 쓰지 말도록 하자. 의미가 없는 태그는 가상선택자(:after, :before)를 이용하며, 의미가 있는 태그는 &lt;span&gt; 태그 등에 대체 텍스트를 활용해 준다. &lt;b&gt; 태그는 강조보단 두껍게를 의미하는 태그이다. &lt;i&gt; 태그와 마찬가지로 사용을 지양하며, 강조의 의미인 &lt;strong&gt; 및 &lt;em&gt; 태그를 사용하도록 하자. 쇼핑몰 사이트의 10,000원 이런 형태의 가격표를 많이 보았을 것이다. 이 경우 &lt;del&gt; 태그를 사용하면 스크린리더기가 10,000원 뒤에 ‘삭제’ 라고 읽어준다. 이런식으로 의미론적인 태그를 사용하여 마크업을 작성하도록 하자. 2. 텍스트를 포함하는 이미지W3C는 특별한 경우를 제외하고는 텍스트를 이미지 형태로 제공하지 않도록 권장한다.텍스트 이미지는 사용자의 요구사항에 따라 시각적으로 사용자 정의될 수 있어야 한다. 예를 하나 들면 번역을 해야 되는 경우가 있다. 꼭 이미지로 사용해야 하는 경우에는 대체 텍스트를 꼭 사용해주도록 한다.(alt 속성 등) 3. 텍스트 명도대비W3C는 기본적으로 텍스트와 배경과의 명도대비는 최소한 4.5 : 1 을 제공하도록 권장한다. 대신 비활성 상태의 인터페이스 요소나 텍스트, 순수한 장식, 로고 또는 상표명에 포함된 텍스트의 경우, 그림의 일부인 텍스트의 경우 어떠한 명도대비 요구사항도 없다. 명도 대비 검사는 Contrast Finder에서 테스트해볼 수 있다. 4. 비 텍스트 명도대비W3C는 UI요소 및 그래픽 콘텐츠에 한에서 명도대비를 3:1을 제공하도록 권장하고 있다. 예를들어 그래프의 경우 명도가 비슷한 색 끼리 맞닿은 경우 닿는면 사이를 흰색 라인으로 처리를 해준다. 색애 무관한 콘텐츠 인식에서 예시를 확인할 수 있다. 5. WAI-ARIA정적인 HTML과 단순한 JavaScript 환경이 아닌 동적인 JavaScript 및 Ajax와 같은 기술을 사용한 환경에서 스크린리더 및 보조기기등이 접근성 및 상호 운용성을 향상시키기 위하여 탄생되었으며, 역할(Role), 속성(Property), 상태(State) 정보를 추가하여 이를 개선 할 수 있도록 제공하고 있다. W3C가 권장을 하고 있지만, 느리다는 단점이 있다. 6. 반응형 웹콘텐츠는 정보 또는 기능 손실 없이, 2차원 스크롤 없이 제공해야 한다. 2차원 스크롤을 이용해 본 사람은 알겠지만 콘텐츠 이용이 상당히 불편하다. 2차원 스크롤은 아래을 의미한다. 가로 320px 넓이에서 가로 스크롤이 없이 수직으로 스크롤 세로 256px 높이에서 세로 스크롤이 없이 수평으로 스크롤 7. 동영상 실시간 자막동영상 제공 시 W3C는 특별한 경우를 제외하고 동기화된 자막을 제공하도록 권장한다. 단, 미디어가 텍스트에 대한 대체수단이 분명히 명시된 경우는 예외이다. 되도록이면 대화, 해설, 효과음 등의 자막 스타일을 다르게 하여 나타내는 것도 하나의 방법이다. 동영상 자막의 경우 게임 분야가 상당히 잘 되어있다. 청각 장애와 난청을 위한 게임 만들기에서 좋은 예시를 볼 수 있다. 8. 자동완성기능입력칸의 목적성을 규정하여 각각의 입력 필드가 가지는 의미는 계획하에 결정되어야 한다. 다른 말로 하면, 사용자들로부터 어떤 값들이 입력되길 기대하는지, 혹은 입력된 정보의 의미가 무엇인지를 나타내는 코드가 필요하다. 이를 정확하게 하면 사용자의 브라우저가 이전에 사용자가 입력한 데이터들을 활용하여 미리 해당 입력 필드를 자동적으로 채우는 것을 가능하게 해준다. 결론기술이 필요한 궁극적인 이유는 사람이다. 정보 접근성 준수 기술은 사용자를 이해하고 배려하는 것에서 시작된다. 웹 접근성을 꼭 준수하도록 하자 References 네이버 접근성 가이드다음 접근성 가이드웹 접근성이란?웹 접근성의 이해장애인차별금지 및 권리구제 등에 관한 법률한국형 웹 콘텐츠 접근성 지침 2.1[인식의 용이성] 1.3.1. 색에 무관한 콘텐츠 인식[웹표준]WCAG 2.1 가이드라인한국웹접근성성인인증평가원","link":"/2019/12/03/iat-conference-web/"},{"title":"[IATC] 입력 서식 관련 접근성","text":"2019년 11월 22일 정보접근성 기술 컨퍼런스를 다녀온뒤 세미나 내용을 정리 및 입력 서식 관련 접근성 대비에 관련한 내용이다. 입력 서식 관련 접근성1. 레이블이 시각적으로 노출된 경우&lt;label&gt;에 for와 &lt;input&gt;의 id를 동일하게 맞추어 준다. &lt;label&gt;을 클릭하면 해당 폼으로 커서가 이동한다. HTML 12&lt;label for=&quot;usr_id&quot;&gt;아이디&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;usr_id&quot; /&gt; 결과 아이디 2. 레이블이 시각적으로 노출되지 않은 경우&lt;input&gt;태그만 있는 경우는 title속성을 꼭 명시하여 스크린 리더기가 인식할 수 있도록 한다. HTML 1&lt;input type=&quot;text&quot; id=&quot;usr_id&quot; title=&quot;아이디&quot; /&gt; 스크린 리더기 소리: “아이디 편집 창” 3. 읽기 전용 편집 창인 경우title속성을 넣어주지 않으면 해당 편집 창의 제목을 건너 띄고 결과값만 읽는다. 꼭 title속성을 써주도록 한다. HTML 1&lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; value=&quot;25&quot; /&gt; 스크린 리더기 소리: “25 읽기전용 편집 창” 1&lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; value=&quot;25&quot; title=&quot;나이&quot; /&gt; 스크린 리더기 소리: “나이 25 읽기전용 편집 창” 4. placeholder가 있는 경우placeholder는 보조 수단으로 레이블 대체가 불가능하다. 이 역시 title속성을 꼭 넣어주도록 한다. HTML 1&lt;input type=&quot;text&quot; placeholder=&quot;user@naver.com&quot; /&gt; 스크린 리더기 소리: “user@naver.com 편집 창” 1&lt;input type=&quot;text&quot; placeholder=&quot;user@naver.com&quot; title=&quot;이메일&quot; /&gt; 스크린 리더기 소리: “이메일 편집 창” 5. 다수의 입력 서식이 존재하는 경우title속성에 입력 내용 및 자리수까지 상세히 명시한다. HTML 123&lt;input type=&quot;text&quot; placeholder=&quot;년(4자)&quot; title=&quot;태어난 년도 4자리&quot; /&gt;&lt;input type=&quot;text&quot; placeholder=&quot;월&quot; title=&quot;태어난 월&quot; /&gt;&lt;input type=&quot;text&quot; placeholder=&quot;일&quot; title=&quot;태어난 일&quot; /&gt; 6. id, for가 명시되어 있지 않고 암묵적 레이블로 제공하는 경우최신 버전의 스크린 리더기는 암묵적 레이블을 읽어 주긴 하지만 역시 많은 스크린 리더기 사용에 문제가 발생하고 있어 꼭 명시적으로 레이블을 사용하기를 권장하고 있다. HTML 1234&lt;label&gt; 아이디 &lt;input type=&quot;text&quot;&gt;&lt;/label&gt; 스크린 리더기 소리: “아이디 편집 창” 7. 커스터마이징이 되어 있는 경우커스터마이징이 되어있는 입력서식의 경우 키보드를 이용한 조작이 필수며, 마크업 형태는 기본서식과 동일하도록 권장하고 있다.(예: 라디오 버튼의 경우 키보드 좌, 우 버튼으로 조작 가능)복잡한 입력서식의 경우 아리아로 구현이 가능하지만 느리다는 단점이 있다. 접근성 교육 및 솔루션부스트코스 웹 접근성 강의웹 접근성 이해라는 사이트에서 웹 접근성 강의를 보다 쉽게 배울 수 있다. References 웹 접근성 이해레진 웹 접근성 가이드라인","link":"/2019/12/04/iat-conference-form/"},{"title":"[jQuery] IOS 스크롤 방지","text":"모달 팝업에서 백그라운드 영역의 스크롤을 방지하고자 할 때 Android는 body에 overflow: hidden 속성만 줘도 스크롤이 방지되지만 IOS의 경우는 먹히지 않는다. 이럴 경우 body를 position: fixed 로 고정시킨 뒤 스크롤, 터치, 마우스 휠 이벤트를 막아버리면 된다. 12345.scrollOff { position: fixed; overflow: hidden; height: 100%;} 1234567// ios 스크롤 방지$('body').addClass('scrollOff').on('scroll touchmove mousewheel', function (e) { e.preventDefault();});// ios 스크롤 방지$('body').removeClass('scrollOff').off('scroll touchmove mousewheel');","link":"/2018/06/11/ios-scroll-off/"},{"title":"[JavaScript] 자바스크립트 노드 생성 및 추가","text":"노드 생성 1var input = document.createElement('input'); 생성된 노드 속성 추가 1input.setAttribute('type', 'text'); 텍스트 노드 추가 1var txt = document.createTextNode('hello'); 부모 노드에 생성된 노드 추가 1부모노드.appendChild(input); 위 노드 추가 방법으로 테이블 추가 예제를 만들어 보자, 버튼을 계속 클릭하면 테이블이 추가된다. 1234&lt;div class=&quot;wrap&quot;&gt; &lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt; &lt;table id=&quot;tbl&quot;&gt;&lt;/table&gt;&lt;/div&gt; 1234567891011121314151617181920212223.wrap { position: relative; padding-top: 40px;}.wrap * { margin: 0; padding: 0}#tbl td { border: 1px solid #ccc; padding: 3px 10px; text-align: center;}#btn { position: absolute; top: 0; left: 0; width: 50px; height: 30px;} 1234567891011121314151617181920212223242526272829303132333435window.onload = function () { // 노드 선언 var btn = document.getElementById('btn'), tbl = document.getElementById('tbl'), tblTr = tbl.getElementsByTagName('tr'); // 버튼 이벤트 btn.addEventListener('click', function () { tblAdd(); }); // 테이블 추가 function tblAdd() { var tr = document.createElement('tr'); for (var i = 0; i &lt; 5; i++) { var td = document.createElement('td'); tr.appendChild(td); }; tbl.appendChild(tr); numAdd(); } // 테이블 번호 추가 function numAdd() { var num = 0; for (var i = 0; i &lt; tblTr.length; i++) { for (var j = 0; j &lt; tblTr[i].getElementsByTagName('td').length; j++) { num++; tblTr[i].getElementsByTagName('td')[j % 5].innerHTML = num; }; }; }} 아래 버튼을 클릭하여 결과를 확인할 수 있다. .wrap { position: relative; padding-top: 40px; } .wrap * { margin: 0; padding: 0; } #tbl td { border: 1px solid #ccc; padding: 3px 10px; text-align: center; } #btn { position: absolute; top: 0; left: 0; width: 50px; height: 30px; } window.onload = function () { // 노드 선언 var btn = document.getElementById('btn'), tbl = document.getElementById('tbl'), tblTr = tbl.getElementsByTagName('tr'); // 버튼 이벤트 btn.addEventListener('click', function () { tblAdd(); }); // 테이블 추가 function tblAdd() { var tr = document.createElement('tr'); for (var i = 0; i < 5; i++) { var td = document.createElement('td'); tr.appendChild(td); }; tbl.appendChild(tr); numAdd(); } // 테이블 번호 추가 function numAdd() { var num = 0; for (var i = 0; i < tblTr.length; i++) { for (var j = 0; j < tblTr[i].getElementsByTagName('td').length; j++) { num++; tblTr[i].getElementsByTagName('td')[j % 5].innerHTML = num; } } } } click References HTML DOM appendChild() Method","link":"/2017/12/12/javascript-append-child/"},{"title":"[Web] 이미지 캐싱","text":"웹사이트의 이미지가 변경된 경우 캐쉬가 남아있어 변경사항이 적용안되는 경우가 있다.이럴경우 강력 새로고침을 해주면 적용이 된다. 새로고침 : f5 ctrl + f5 : 강력 새로고침 shift + f5 : 강력 새로고침(크롬) shift + ctrl + r : 강력 새로고침(크롬) 하지만 수정이 빈번한 프로젝트의 경우 매번 캐쉬를 지우고 그러기에는 사용자 입장에서 썩 좋은 방법은 아니다.몇가지 방법이 있는데 수정이 될때마다 이미지명을 버전별로 바꾸는 것이다. 변경 전 : “img.png” 변경 후 : “img_v01.png” 브라우저는 이미지명이 다를경우 다른 이미지라고 인식하여 불러오기 때문인데, 위 방법은 수정사항이 잦아질 경우 리소스 관리가 까다롭기 때문에 그렇게 좋은 방법은 아니다.조금 더 효율적인 방법은 이미지를 불러오는 경로 마지막에 파라미터를 추가하는 방법을 사용하면 된다. 변경 전 : “img.png” 변경 후 : “img.png?ver=1.0”","link":"/2019/10/17/img-caching/"},{"title":"[JavaScript] ES5 Array.every","text":"Array.every메서드는 Array.some와 비슷하지만 모든 요소가 조건을 만족해야 true를 반환한다. Parameter 현재 배열 요소의 값 현재 배열 요소의 index 현재 돌고 있는 배열 자체 예제123456789var arr = [1, 3, 5, 6, 7, 9, 11];// 배열의 모든 요소가 10보다 작아야 true를 리턴var val = arr.every(function (item, index, array) { return item &lt; 10;});console.log(val);// false References [JavaScript] Array 객체에서 놓치기 쉬운 6개의 메서드Array.prototype.every()","link":"/2020/02/20/javascript-array-every/"},{"title":"[JavaScript] ES5 Array.forEach","text":"Array.forEach 매서드는 배열 전체를 돌때, 요소마다 콜백 함수를 실행한다. 배열의 요소에 직접 어떠한 작업을 수행하고 싶을 때 적합한 메서드이다. Array.forEach 메서드는 리턴 값이 없다. Parameter 현재 배열 요소의 값 현재 배열 요소의 index 현재 돌고 있는 배열 자체 예제123456789var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];arr.forEach(function (item) { console.log(item);});// a// b// c 12345678var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];// 배열의 모든 요소에 EDIT라는 문자열을 더하기arr.forEach(function (item, index, array) { array[index] = item + &quot;EDIT&quot;;});console.log(arr); References [JavaScript] Array 객체에서 놓치기 쉬운 6개의 메서드","link":"/2020/02/16/javascript-array-foreach/"},{"title":"[JavaScript] ES5 Array.filter","text":"Array.filter메서드는 배열의 각 요소를 순회하며 콜백 함수를 실행하며 특정 조건에 맞는 요소만 모아 배열로 리턴한다. 특정 케이스만 필터링해서 추출할 때 유용하다. Parameter 현재 배열 요소의 값 현재 배열 요소의 index 현재 돌고 있는 배열 자체 예제123456789var arr = [1, 3, 5, 6, 7, 9, 11];// 배열 요소중에서 모두 7보다 작은 요소만 모아 배열로 리턴var val = arr.filter(function (item, index, array) { return item &lt; 7;});console.log(val);// [1, 3, 5, 6] References [JavaScript] Array 객체에서 놓치기 쉬운 6개의 메서드Array.prototype.filter()","link":"/2020/02/18/javascript-array-filter/"},{"title":"[JavaScript] ES5 Array.map","text":"Array.map 메서드는 Array.forEach와 마찬가지로 배열의 각 요소를 순회하며 콜백 함수를 실행한다. 다만, 콜백에서 리턴되는 값을 배열로 만들어낸다. 원본 배열은 건들지 않고 그 요소들을 사용해서 혹은 약간 변형해서 새로운 배열을 만들어야 할 때 유용하다. Parameter 현재 배열 요소의 값 현재 배열 요소의 index 현재 돌고 있는 배열 자체 예제123456789101112131415var arr = ['a', 'b', 'c'];//배열의 모든 요소에 NEW라는 문자열을 더하기//메서드 수행 후 리턴값은 새로운 배열var newArr = arr.map(function (item, index, array) { return item + 'NEW';});//메서드 수행 후 원본 배열console.log(arr);// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]//메서드 수행 후 생성된 배열console.log(newArr);// [&quot;aNEW&quot;, &quot;bNEW&quot;, &quot;cNEW&quot;] 실용적인 예제Array.map 메서드는 아래와 같이 쓰일 수 있다. 12345678&lt;button type=&quot;button&quot; id=&quot;click&quot; onclick=&quot;render()&quot;&gt;데이터 얻기&lt;/button&gt;&lt;table id=&quot;tbl&quot;&gt; &lt;thead&gt; &lt;th&gt;이름&lt;/th&gt; &lt;th&gt;전화번호&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt; 1234567891011121314151617181920212223242526272829303132333435// ajax를 통해 가져온 데이터라고 가정var data = [ { name: 'a', phone: '010-1000-2000' }, { name: 'b', phone: '010-3000-4000' }, { name: 'c', phone: '010-5000-6000' }];// Array.map 메서드를 사용하여 배열 요소의 데이터를 html로 변경function makeDom() { var dom = data.map(function (item, index) { return '&lt;tr&gt;&lt;td&gt;' + item.name + '&lt;/td&gt;&lt;td&gt;' + item.phone + '&lt;/td&gt;&lt;/tr&gt;'; }); return dom;}// 배열을 하나의 값으로 만든 후 테이블에 html 추가function addTbl(dom) { var tblList = dom.join(''); document.getElementById('tbl').getElementsByTagName('tbody')[0].innerHTML = tblList;}// 위 로직을 실행function render() { var list = makeDom(); addTbl(list);} 결과데이터 얻기 이름 전화번호 // ajax를 통해 가져온 데이터라고 가정 var data = [ { name: 'a', phone: '010-1000-2000' }, { name: 'b', phone: '010-3000-4000' }, { name: 'c', phone: '010-5000-6000' } ]; // Array.map 메서드를 사용하여 배열 요소의 데이터를 html로 변경 function makeDom() { var dom = data.map(function (item, index) { return '' + item.name + '' + item.phone + ''; }); return dom; } // 배열을 하나의 값으로 만든 후 테이블에 html 추가 function addTbl(dom) { var tblList = dom.join(''); document.getElementById('tbl').getElementsByTagName('tbody')[0].innerHTML = tblList; } // 위 로직을 실행 function render() { var list = makeDom(); addTbl(list); } References [JavaScript] Array 객체에서 놓치기 쉬운 6개의 메서드자바스크립트 Array map","link":"/2020/02/17/javascript-array-map/"},{"title":"[JavaScript] ES5 Array.reduce","text":"Array.reduce메서드는 배열의 각 요소를 순회하며 콜백 함수를 실행하며 이전 리턴값을 넘겨 받는다. 이전 값을 넘겨 받아 현재 값과 어떠한 작업을 수행하고 싶을 때 적합한 메서드이다. 인자 값이 다른 메서드와 약간 다르며, 콜백 함수 뒤에 인자를 하나 더 줄 수 있다. 이 인자는 첫 콜백함수의 이전 값으로 주입된다. Parameter 이전 콜백 함수에서 리턴한 값 현배 배열 요소의 값 현재 배열 요소의 index 현재 돌고 있는 배열 자체 예제1234567891011121314var arr = [1, 2, 3, 4, 5];// 각 콜백 마다 리턴값을 previousItem로 넘겨받아 어떤 작업을 수행var val = arr.reduce(function(previousItem, currentItem, index, array) { // 콜백의 리턴 값을 받아 현재의 값과 더하려 다시 리턴 return previousItem + currentItem;// 첫번째 콜백의 previousItem값}, 0);console.log(val);// 15// 위 결과를 수식으로 나타내면 0 + 1 + 2 + 3 + 4 + 5 이다.(0부터 5까지의 합) References [JavaScript] Array 객체에서 놓치기 쉬운 6개의 메서드Array.prototype.reduce()","link":"/2020/02/21/javascript-array-reduce/"},{"title":"[JavaScript] 배열 메서드","text":"자바스크립트에서 자주 쓰이는 배열 메서드 정리 concat()배열을 하나로 합칠 때 사용한다. 인자로 들어온 배열의 순서대로 합쳐진다. 1234567891011var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];var arr3 = [7, 8, 9];var wrap = arr1.concat(arr2, arr2, arr3);console.log(wrap);// (12) [1, 2, 3, 4, 5, 6, 4, 5, 6, 7, 8, 9]console.log(arr1);// (3) [1, 2, 3] forEach()주어진 함수를 배열 요소 각각에 대해 실행한다. 12345678var arr = ['a', 'b', 'c'];arr.forEach(function (element) { console.log(element); // a // b // c}); map()배열을 반복하고, 콜백함수가 리턴한 값으로 새 배열을 반환한다. 1234567891011121314var users = [ { name: '철수', age: 20 }, { name: '영희', age: 25 }, { name: '민수', age: 23 }, { name: '주연', age: 27 }];var usersName = users.map(function (element) { return element.name; // 각 요소의 nama 값만 반환});console.log(usersName);// (4) [&quot;철수&quot;, &quot;영희&quot;, &quot;민수&quot;, &quot;주연&quot;] filter()배열을 반복하고, 콜백함수의 리턴값이 true인 요소로만 구성된 새 배열을 반환한다. 아래 예제는 age가 23 초과인 요소만 반환하였다. 1234567891011121314151617var users = [ { name: '철수', age: 20 }, { name: '영희', age: 25 }, { name: '민수', age: 23 }, { name: '주연', age: 27 }];var usersOld = users.filter(function (element) { return element.age &gt; 23;});console.log(usersOld);// (2) [{…}, {…}]// 0: {name: &quot;영희&quot;, age: 25}// 1: {name: &quot;주연&quot;, age: 27}// length: 2// __proto__: Array(0) sort()배열을 반복하고, 콜백함수의 리턴값이 true인 요소로만 구성된 새 배열을 반환한다. 아래 예제는 age가 23 초과인 요소만 반환하였다. 123456789101112131415var arr = [5, 2, 1, 3, 10, 4];arr.sort(function(a, b) { return a - b; // 오름차순});console.log(arr);// (6) [1, 2, 3, 4, 5, 10]arr.sort(function(a, b) { return b - a; // 내림차순});console.log(arr);// (6) [10, 5, 4, 3, 2, 1] indexOf()인자로 전달된 요소와 매치되는 첫번째 요소의 인덱스를 반환한다. 일치하는 요소가 없으면 -1을 반환한다. 1234var arr = ['a', 'b', 'c', 'd'];console.log(arr.indexOf('c')); // 2console.log(arr.indexOf('e')); // -1 every()함수의 리턴값이 false가 될 때 까지 배열 요소 각각에 대해 함수를 실행한다. 123456789var arr = [1, 2, 3, 4, 5];arr.every(function(element) { console.log(element); // 1 // 2 // 3 return element &lt; 3;}); References JavaScript 배열 메서드 ( Array method )Array.prototype.forEach()알아두면 좋은 자바스크립트 배열 메서드","link":"/2018/05/15/javascript-array-method/"},{"title":"[JavaScript] ES5 Array.some","text":"Array.some메서드는 배열의 각 요소를 순회하며 콜백 함수를 실행하며 하나의 요소라도 조건을 만족할 때 true를 반환하며, 만족하지 않을 때 false를 반환한다. 특정 조건을 만족하는지 알고 싶을 때 적합한 메서드다. Parameter 현재 배열 요소의 값 현재 배열 요소의 index 현재 돌고 있는 배열 자체 예제123456789var arr = [1, 3, 5, 6, 7, 9];// 배열 요소중에서 짝수가 있으면 메서드 수행을 중단하고 true를 리턴var val = arr.some(function (item, index, array) { return item % 2 === 0;});console.log(val);// ture References [JavaScript] Array 객체에서 놓치기 쉬운 6개의 메서드Array.prototype.some()","link":"/2020/02/19/javascript-array-some/"},{"title":"[JavaScript] Async&#x2F;Await를 이용한 비동기 처리","text":"Async/Await는 ECMAScript8에서 새롭게 추가된 자바스크립트 비동기 처리 패턴이다. 코드의 모습과 동작을 좀 더 동기 코드와 유사하게 작성할수 있어 기존의 콜백 패턴이나 프로미스 패턴보다 가독성이 높다는 장점이 있다. 123456789101112131415161718async function getData() { const result = await new Promise((resolve) =&gt; { // 1초뒤 data에 값 담음 setTimeout(() =&gt; { const data = &quot;my-data&quot;; resolve(data); }, 1000); }); // data 값 출력 console.log(result);}getData(); 기본적인 형태는 위와 같으며 아래에서 각 키워드를 알아본다. asyncasync 키워드를 function앞에 붙이면 AsyncFunction 함수가 되며 이 함수는 항상 프라미스를 반환한다. 1234async function func() { return &quot;my-data&quot;;}console.log(func()); // Promise { 'my-data' } 위 코드를 보면 func()는 my-data 값을 리턴하고 있지만 실제 리턴값은 프로미스 객체를 리턴하고 있다. 1234567async function func() { return &quot;my-data&quot;;}func().then((data) =&gt; { console.log(data); // my-data}); 위 코드는 반환된 프라미스 객체를 then 함수를 통해 data값을 받아 출력하고 있다. await또 다른 키워드 await는 async 함수 안에서만 동작한다. await는 프로미스 객체를 만나면 처리될 때까지 기다리고 결과는 그 이후에 반환되며 이 키워드로 비동기 패턴을 동기식으로 작성할 수 있다. 12345678910111213141516async function getData() { // promise 변수에 프로미스 객체를 담음 const promise = new Promise((resolve) =&gt; { // 1초뒤 resolve 함수를 호출하여 프로미스가 이행상태가 됨 setTimeout(() =&gt; { resolve(&quot;my-data&quot;); }, 1000); }); const result = await promise; // 프로미스가 이행될 때 까지 기다림 console.log(result); // my-data}getData(); await는 async 함수 외부에서 사용될 수 없다. 만약 사용된다면 문법 에러가 발생한다. 위 코드를 아래처럼 프로미스를 선언할 때 await 키워드를 사용할 수도 있다. 123456789101112131415async function getData() { // 프로미스가 이행되었을 때 결과값을 담음 const result = await new Promise((resolve) =&gt; { // 1초뒤 resolve 함수를 호출하여 프로미스가 이행상태가 됨 setTimeout(() =&gt; { resolve(&quot;my-data&quot;); }, 1000); }); console.log(result); // my-data}getData(); 기존 비동기 처리 방식과 비교기존의 비동기 방식과 비교해보자, 서버와 통신하여 1초뒤 my-data 값을 리턴하는 getData() 함수가 있다고 가정한다.(여기서는 비동기 통신을 setTimeout()로 대체한다.) 123456789function getData() { let data = &quot;&quot;; setTimeout(() =&gt; { data = &quot;my-data&quot;; }, 1000); return data;}console.log(getData()); // 출력 안됨 함수를 실행하면 리턴값은 아무것도 안나온다. 비동기 방식으로 통신되기 때문에 응답(1초)을 기다리지 않고 바로 값을 리턴하기 때문이다. 콜백함수 방식1234567891011function getData(callBack) { let data = &quot;&quot;; setTimeout(() =&gt; { data = &quot;my-data&quot;; return callBack(data); }, 1000);}getData(function(result) { console.log(result); // my-data}); 콜백 방식을 사용하면 위와 같다. getData() 함수에 콜백함수를 인자로 넣고 통신이 끝난 후 리턴하여 그 값을 출력하는데, 코드의 가독성이 좋지 않다. 프로미스의 then 방식12345678910111213function getData() { let data = &quot;&quot;; return new Promise((resolve) =&gt; { setTimeout(() =&gt; { data = &quot;my-data&quot;; resolve(data); }, 1000); });}getData().then(function(result) { console.log(result); // my-data}); 반환된 프로미스 객체를 then() 함수에 전달받는 방식이다. 콜백 지옥을 해결하고, 예외처리가 가능한 방식이지만, 여전히 가독성이 안좋은건 사실이다. Async/Await 방식12345678910111213141516function getData() { let data = &quot;&quot;; return new Promise((resolve) =&gt; { setTimeout(() =&gt; { data = &quot;my-data&quot;; resolve(data); }, 1000); });}async function getResult() { const result = await getData(); console.log(result); // my-data}getResult(); getResult() 함수에 async 키워드를 사용해 AsyncFunction으로 만들었다. getData()의 리턴값은 프로미스기 때문에 await 키워드를 만나 프로미스 실행이 완료되면 결과값이 result 변수에 할당된다. 예외처리Async/Await의 예외처리는 try, catch로 한다. 프로미스에서 catch()를 사용한 것처럼 async &amp; await에서는 catch{}를 사용하면 된다. 123456789101112131415161718192021222324function getData() { let data = &quot;&quot;; return new Promise((resolve) =&gt; { setTimeout(() =&gt; { data = &quot;my-data&quot;; resolve(data); }, 1000); });}async function getResult() { // 통신 성공 try { const result = await getData(); console.log(result); // my-data // 통신 실패 } catch (error) { console.log(error); // error }}getResult(); catch로 통신 오류 및 타입오류 등이 error 객체에 담기게 된다. 에러 유형에 맞게 코드를 작성하면 된다. References 자바스크립트 async와 awaitasync와 await자바스크립트의 Async/Await 가 Promises를 사라지게 만들 수 있는 6가지 이유","link":"/2020/11/20/javascript-async-await/"},{"title":"[JavaScript] 비동기 처리와 콜백 함수","text":"비동기 처리비동기 처리란 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고, 순차적으로 다음 코드를 먼저 실행하는 자바스크립트의 특성이다. 비동기의 반대로는 동기 처리가 있다. 동기: 요청을 보낸 후 해당 응답을 받아야 다음 동작을 실행(ex: 은행) 비동기: 요청을 보낸 후 응답에 관계 없이 다음 동작을 실행(ex: 카페) 비동기 예제비동기 처리의 대표적인 사례는 제이쿼리의 Ajax와 자바스크립트의 내장 함수인 setTimeout()이 있다. Ajax아래 처럼 Ajax로 통신을 하고 있다고 가정해 보자 1234567891011121314151617181920function getData() { let data; $.ajax({ type: 'post', url: 'https://recordboy.github.io/', data: { // 전송 데이터 }, success: function (result) { // 통신 성공시 결과값 할당 data = result; }, }); return data;}console.log(getData()); // undefined https://recordboy.github.io/주소로 data를 전송하고, 통신 성공시 응답값을 data변수에 할당하여 리턴하도록 되어있다. 정상적으로 응답값을 받아 올 것 같지만 리턴값은 undefined가 출력된다. 이유는 Ajax를 요청하고 응답값을 받기 전에 return data를 실행했기 때문이다. 결국 getData()의 리턴값은 초기 값을 설정하지 않는 undefined가 출력되는 것이다. 이렇게 특정 로직의 실행이 끝날 때까지 대기하지 않고, 나머지 코드를 먼저 실행하는 것이 비동기 처리이다. 자바스크립트에서 비동기 처리가 필요한 이유는 화면에서 서버로 데이터를 요청했을 때 서버가 응답값을 언제 줄지도 모르는데 마냥 기다릴 순 없기 때문이다. 만약 어플리케이션이 비동기 처리를 하지 않고 동기적 처리를 한다고 가정해 보자. 위에서는 1번만 요청하였지만, 만약 요청을 100번이상 보낸다면 해당 어플리케이션은 실행하는데 수십분이 걸릴 것이다. setTimeout()비동기 처리의 두번째 사례이다. 123456789101112function getData() { let data; setTimeout(function () { data = 'result'; }, 1000); return data;}console.log(getData()); // undefined 위에서의 setTimeout()은 1초 뒤에 data변수에 result값을 할당하도록 되어있다. Ajax와 마찬가지로 코드는 setTimeout()이 실행되는 것을 기다리지 않고 return data를 먼저 실행하기 때문에 리턴값은 undefined를 출력한다. 비동기 처리 방식의 문제 해결위와 같은 문제점들은 콜백 패턴으로 처리가 가능하다. 123456789101112function getData(callback) { let data; setTimeout(function () { data = 'result'; callback(data); }, 1000);}getData(function (data) { console.log(data); // result}); 함수를 실행할 때 인자값으로 콜백 함수를 넣는 것이다. getData()의 인자값으로 콜백 함수가 들어갔고, setTimeout()이 1초뒤 실행되고 결과값을 콜백 함수의 인자값으로 넣어 호출하였다. 이렇게 콜백 패턴을 사용하면 특정 로직이 끝났을 때 원하는 동작을 실행 시킬 수 있다. 콜백 지옥비동기 처리를 위해 콜백 패턴를 사용하면 처리 순서를 보장하기 위해 여러 개의 콜백 함수가 중첩되어 복잡도가 높아지는 콜백 함수가 발생하는 단점이 있다. 아래는 콜백 지옥이 발생하는 전형적인 사례이다. 1234567891011step1(function (value1) { step2(function (value2) { step3(function (value3) { step4(function (value4) { step5(function (value5) { // 탈출 }); }); }); });}); step1에서 어떤 처리 (주로 입출력) 이후 그 결과를 받아와, 인자로 전달된 익명 함수의 매개변수로 넘겨준다. 이후 step2에서 또 어떤 처리를 하고, 다음 익명 함수가 실행된다. 이를 반복하다보면 코드가 위에서 아래가 아니라 기묘한 피라미드 모양으로 기술되게 된다. 이러한 콜백 지옥은 가독성을 나쁘게 하며 실수를 유발하는 원인이 된다. 콜백 지옥 해결 방법일반적으로 콜백 지옥을 해결하는 방법에는 Promise나 Async를 사용하는 방법이 있으며, 만약 코딩 패턴으로만 콜백 지옥을 해결하려면 아래와 같이 각 콜백 함수를 분리해 주면 된다. 12345678step1(afterStep1);function afterStep1(value1) { step2(afterStep2);}function afterStep2(value2) { step3(afterStep3);}// 생략 위와 같은 방법으로 콜백 지옥을 해결할 수 있지만 Promise나 Async를 이용하면 더욱 편리하게 비동기 처리를 구현할 수 있다. References 자바스크립트 비동기 처리와 콜백 함수자바스크립트 비동기처리동기식 처리 모델 vs 비동기식 처리 모델동기와 비동기, 콜백함수프로미스콜백 지옥","link":"/2020/06/04/javascript-asynchronous-callback/"},{"title":"[JavaScript] 자바스크립트 호출 스택(Call Stack)","text":"호출 스택호출 스택이란 함수의 호출을 기록하는 자료구조이다. 기본적으로 우리가 프로그램 안에서 위치한 곳이며, 만약 우리가 어떤 함수를 실행시킨다면, 우리는 스택 위에 무언가를 올리는(push) 행위를 하는 것이다. 그리고 우리가 함수로부터 반환을 받을 때, 우리는 스택의 맨 위를 가져오는(pop) 것이다. 자료구조란 사전적인 의미는 자료(Data)의 집합의 의미하며, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것 123456789101112131415function func01() { throw new Error(&quot;Oops!&quot;);}function func02() { func01();}function func03() { func02();}func03();// Uncaught Error: Oops!// at func01 (index.html:27)// at func02 (index.html:30)// at func03 (index.html:33)// at window.onload (index.html:35) 위 코드를 실행해보면 콘솔창에 빨간 애러 스택들이 나온다. 보통 그것들은 호출 스택의 현재 상태를 나타내며, 실패함 함수를 스택처럼 위에서 아래로 나타낸다. 크롬 개발자 도구의 디버깅 기능을 활용하여 호출스택을 확인해 볼 수 있다. 1234567891011function func01() { console.log(&quot;hello&quot;);}function func02() { func01();}function func03() { func02();}debugger;func03(); 위 코드를 실행하면 디버깅 모드가 시작될 것이다. 개발자 도구에서 Sources 패널의 Call Stack을 확인해 보면 처음에는 (anonymous)이 출력되며, Step 버튼을 클릭하여 다음 함수를 들어갈 때 마다 스택이 점점 쌓이는 것을 볼 수 있다. 1234func01func02func03(anonymous) 그리고 함수를 빠져 나갈 때 마다 스택이 위에서 부터 빠져 나가는 것을 확인할 수 있다. 이러한 각 단계를 스택 프레임(Stack Frame) 이라고 한다. 스택 오버플로우스택의 사이즈를 초과했을 때 발생하는 오류인데 보통 재귀를 호출했을 때 나타난다. 123456789101112131415function func() { func();}func();// Uncaught RangeError: Maximum call stack size exceeded// at foo (index.html:25)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26) 엔진에서 이 코드를 실행할 때, func()에 의해서 func함수가 호출된다. 여기서 다시 func함수를 호출하고 반복적으로 함수를 호출하게 된다. 그러면 매번 실행할 때마다 호출스택에 func()가 쌓이며 최대 허용치를 넘으면 위처럼 에러를 발생시킨다. References Understanding Javascript Function Executions — Call Stack, Event Loop , Tasks &amp; more자바스크립트 개발자라면 알아야 할 33가지 개념 #1 콜스택 (번역)자료구조 : 자료구조란? (Data Structure)자바스크립트의 동작원리: 엔진, 런타임, 호출 스택","link":"/2018/02/01/javascript-call-stack/"},{"title":"[JavaScript] var, let, const 차이","text":"var는 변수를 선언하는 키워드이며, ES6부터 let과 const가 추가되었다.var는 함수 스코프를 가지고 let과 const는 블록 스코프를 가진다. 여기서 스코프란 코드가 실행되는 유효범휘이다. 블록 스코프블록 스코프는 중괄호{}로 감싸진 범위를 말한다. 아래는 조건문(if), 반복문(for), 함수(function)가 블록 스코프를 가지고 있는 모습이다. 1234567891011if (true) { // 블록 스코프}for (var i = 0; i &lt; 10; i++) { // 블록 스코프}function func() { // 블록 스코프} var기존의 var는 위 세개중 함수에서만 스코프를 가진다. 1234567891011121314151617if (true) { var a = 1;}console.log(a);// 1for (var i = 0; i &lt; 1; i++) { var b = 2;}console.log(b);// 2function func() { var c = 3;}console.log(c);// Uncaught ReferenceError: foo is not defined at window.onload var는 중복 선언이 가능하다. 1234var a = 1; a = 2;console.log(a);// 2 let, constES6부터 추가된 let, const는 조건문과 반복문에도 스코프를 가진다. 12345678910111213141516171819202122232425262728293031if (true) { let a = 1; const b = 2; console.log(a); // 1 console.log(B); // 2}console.log(a);// Uncaught ReferenceError: a is not defined at window.onloadconsole.log(b);// Uncaught ReferenceError: a is not defined at window.onloadfor (var i = 0; i &lt; 1; i++) { let c = 3; const d = 4; console.log(c); // 3 console.log(d); // 4}console.log(c); // Uncaught ReferenceError: a is not defined at window.onloadconsole.log(d); // Uncaught ReferenceError: a is not defined at window.onloadfunction func() { let e = 5; const f = 6; console.log(e); // 5 console.log(f); // 6}func()console.log(e);// Uncaught ReferenceError: foo is not defined at window.onloadconsole.log(f);// Uncaught ReferenceError: foo is not defined at window.onload let과 const의 차이는 const 가 좀 더 엄격하다. let은 중복선언이 되지만 const는 중복선언이 안되기 때문에 변수가 선언될 때 값을 할당하여야 한다. const는 DB환경정보, API응답값 등 변하지 않을 값을 담을 때 사용한다. 12345678let a;a = 1;console.log(a);// 1const b;b = 2;// Uncaught TypeError: Assignment to constant variable. 결론 var은 함수 스코프에서만 유효 let, const는 블록 스코프에서 유효 const는 선언과 동시에 할당이 일어나야하고, 재할당이 불가 References 자바스크립트 변수와 스코프(유효범위)","link":"/2019/06/05/javascript-block-scope/"},{"title":"[JavaScript] 생성자 함수에서의 This","text":"객체를 생성하는 방법은 크게 객체 리터럴 방식과 사용자 정의 생성자 함수 방식, 객체 생성자 함수 방식이 있다. 12345678// 리터럴var obj = {};// 사용자 정의 생성자 함수var obj = new Func();// 객체 생성자 함수var obj = new Object(); 이 세가지 중 사용자 정의 생성자 함수 방식에서의 this를 알아보겠다. 일반 함수의 this일반 함수에서의 this는 window를 가리킨다. 1234function func() { console.log(this); // window};func(); 생성자 함수의 this생성자 함수는 기존 함수에 new 키워드를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 생성자 함수에서의 this는 생성자 함수를 통해 생성되어 반환되는 객체에 바인딩 된다. 때문에 new 키워드를 잘못 사용해 원치 않은 상황이 나타날 수 있는데, 이를 피하기 위해 생성자 함수 이름의 첫 글자는 대문자로 작성하기를 권고하고 있다. 123456function Func(name) { this.name = name; console.log(this); // Func {name: &quot;foo&quot;} console.log(this.name); // foo};var obj = new Func(&quot;foo&quot;); References 자바스크립트에서 사용되는 this에 대한 설명 1함수 호출과 this","link":"/2018/11/02/javascript-constructor-this/"},{"title":"[JavaScript] 자바스크립트 클로저","text":"정의중첩함수에서 내부함수가 외부함수의 환경을 기억하는것을 클로저라고 한다. 123456function func() { var foo = 'data'; return function() { return foo; }} func라는 함수를 선언하고 foo변수에 ‘data’문자열을 추가한 뒤 foo변수를 리턴하는 익명함수를 선언하였다. 123var closure = func();console.log(closure());// 'data' func함수의 리턴값을 closure변수에 할당한 뒤 closure를 실행한 값을 콘솔로 찍어보았다. 결과는 ‘data’라는 문자열이 출력되었다. func의 지역변수로 있는 foo는 func함수가 끝나면서 소멸되어야하지만 값을 잃지 않고 ‘data’값을 가지고 있다. 이 현상을 클로저라 한다. 다른 구문도 살펴보겠다. 123456789101112131415function count() { var num = 0; return function() { num++; return num; }}var closure = count();console.log(closure());console.log(closure());console.log(closure());// 1// 2// 3 count함수의 지역변수인 num값이 소멸되지 않고 계속 카운트되는 것을 확인해 볼 수 있다. 특징변수의 은닉화자바스크립트에서는 인스턴스를 생성할때 Private Variables에 대한 접근 권한 문제가 있다. 1234567function Create(name) { this._name = name;}var obj = new Create('민수');console.log(obj._name);// 민수 위에서 생성된 obj객체의 _name프로퍼티는 변수명 앞에 _를 포함하였기 때문에 Private Variables로 쓰고싶다는 의도를 알 수 있다. 하지만 _name프로퍼티는 동적으로 변경될 수 있다. 123obj._name = '인성';console.log(obj._name);// 인성 이 경우 클로저를 사용하여 외부에서 내부변수에 접근하는것을 제한할 수 있다. 12345678910function create(name) { var _name = name; return function() { console.log(_name); }}var hello = create('민수');hello();// 민수 여기서는 외부에서 _name에 접근할 방법이 전혀 없다. 이렇게 클로저를 활용하여 은닉화를 해결할 수 있다. 고유한 환경클로저는 고유한 환경을 가지고 있다. 1234567891011121314function func(name) { var txt = name; return function() { return txt; }}var closure01 = func('민수');var closure02 = func('인성');var closure03 = func('한나');console.log(closure01()) // 민수console.log(closure02()) // 인성console.log(closure03()) // 한나 위의 구문을 보면 txt변수가 동적으로 변화하는 것처럼 보이지만, 실제로는 txt변수 자체가 여러번 생성된 것이다. 즉, closure01(), closure02(), closure03()은 서로 다른 환경을 가지고 있다. 서로 다른 환경을 가지고 있다는것은 그만큼 메모리면에서 큰 비효율을 낳는다. 123456789101112function Func(input) { this.name = input; this.get = function() { return this.name; } this.set = function (rename) { this.name = rename; }}var obj = new Func('민수');console.log(obj.get()); 위 코드는 생성자함수를 사용하여 인스턴스를 생성하는 구문인데, 클로저가 두번(get, set)이나 생성되었다. 이 상태에서 인스턴스를 계속 만들면 같은일을 하는 클로저가 중복으로 생성되고 메모리낭비가 심해질 것이다.따라서 클로저는 객체의 prototype안에 저장함으로써 같은 기능을 모든 인스턴스가 공유하는 형태로 코드를 만들어야한다. 123456789101112function Func(input) { this.name = input;}Func.prototype.get = function() { return this.name;};Func.prototype.set = function(rename) { this.name = rename;};var obj = new Func('민수');console.log(obj.get()); 이렇게 prototype안에 클로저를 넣으면, 인스턴스가 생성되더라도 중복으로 메모리를 낭비하지 않고, 생성자 내부의 prototype안의 클로저를 참조하기 때문에 메모리낭비를 방지할 수 있다. 정리 클로저는 독립적인(자유) 변수를 가리키는 함수 또는 클로저 안에 정의된 내부함수는 만들어진 환경을 기억한다. 클로저는 외부함수의 스코프 영역에 접근할 수 있고, 그것을 기억하고 있어야 한다. 외부함수가 종료된 후에도 내부함수는 외부함수를 계속 참조하고 있어야 한다. 데이터의 캡슐화 및 정보은닉에도 사용 가능하다. References JavaScript 클로저(Closure)","link":"/2020/02/01/javascript-closure/"},{"title":"[JavaScript] 날짜 구하기(Data 함수)","text":"Data 객체는 날짜와 시간을 제공하는 생성자 함수이다.인자 없이 객체를 선언하면 현재 날짜와 시간을 반환한다. 123var value = new Date();console.log(value);// Thu Jan 09 2020 14:44:13 GMT+0900 (한국 표준시) 특정 값을 구하는 메서드 메서드 값 getFullYear() 년 getMonth() 월 getDate() 날짜 getDay() 요일 응용2015년 12월 25일의 요일을 구하는 법 1234function func(a, b) { return ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'][new Date(2015, a - 1, b).getDay()];}console.log(func(12, 25)); // FRI References 프로그래머스 문제 풀이 Level 1","link":"/2017/12/13/javascript-date/"},{"title":"[JavaScript] 디바이스 구분 스크립트","text":"어떤 디바이스로 접속했는지 확인 가능한 코드 12345678var filter = &quot;win16|win32|win64|macintel|mac|&quot;; // PC일 경우 가능한 값if (navigator.platform) { if (filter.indexOf(navigator.platform.toLowerCase()) &lt; 0) { alert(&quot;모바일에서 접속하셨습니다&quot;); } else { alert(&quot;PC에서 접속하셨습니다&quot;); }}","link":"/2019/11/18/javascript-device-classification/"},{"title":"[JavaScript] 화살표 함수(Arrow Function)","text":"정의ECMAScript6(2015)에서 새로 추가된 화살표 함수(Arrow Function)는 function 키워드 대신 화살표(=&gt;)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 기존 함수함수 표현식123var func = function() { ...}; 함수 선언식123function func() { ...} 화살표 함수123const func = () =&gt; { ...}; 화살표 함수의 기본 문법12345678910111213141516171819202122// 매개 변수가 없을 경우const func = () =&gt; { ...};// 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.const func = x =&gt; { ...};// 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.const func = (x, y) =&gt; { ...}// 간단하게 한줄로 표현할 땐 중괄호를 생략할 수 있으며 암묵적으로 값이 반환된다. 아래 두 표현은 같다.const func = (x, y) =&gt; x + y;const func = (x, y) =&gt; { return x + y; }// 객체를 반환시 중괄호를 생략하면 소괄호를 사용한다. 아래 두 표현은 같다.const func = (x) =&gt; { return { a: x } };const func = (x) =&gt; ({ a: x }); 화살표 함수의 호출화살표 함수는 익명 함수로만 사용할 수 있다. 따라서 함수를 호출하기 위해서는 함수 표현식을 사용한다. 함수 표현식1234567891011// ES5var func = function(x, y) { return x + y;}console.log(func(5, 10)); // 15// ES6const func = (x, y) =&gt; { return x + y;}console.log(func(5, 10)); // 15 콜백 함수콜백 함수의 경우 함수 표현식보다 표현이 간결하다. 123456// ES5var arr = [1, 2, 3];var result = arr.map(function(x) { return x + x;});console.log(result); // [2, 4, 6] 1234// ES6const arr = [1, 2, 3];const result = arr.map(x =&gt; x + x);console.log(result); // [2, 4, 6] this기존의 function 키워드로 생선된 일반 함수와 화살표 함수의 큰 차이점 중 하나는 this이다. function 키워드 함수의 thisfunction 키워드로 생성된 함수는 함수가 어떻게 호출되었는지에 따라 this가 바인딩할 객체가 동적으로 결정된다. 일반 함수의 this일반 함수(여기서 일반 함수란 중첩 함수나 객체의 함수인 메서드, 콜백 함수가 아닌 전역 스코프에 있는 함수를 말한다.)를 호출하게 되면 this는 전역 객체인 window를 바인딩 한다. 1234function func() { console.log(this); // window}func(); 생성자 함수의 this하지만 new 키워드를 사용하여 생성자함수 호출 방식으로 obj 객체를 생성하면 함수 안에서의 this는 생성자 함수를 바인딩 한다. 1234function Func() { console.log(this); // Func {}}var obj = new Func(); 메서드의 thisfunction 키워드로 만들어진 메서드의 this는 자신을 포함하는 객체를 바인딩 한다. 12345678var obj = { myName: '나나', getName: function() { console.log(this); // {myName: &quot;나나&quot;, getName: ƒ} console.log(this.myName); // 나나 }}obj.getName(); obj 객체의 getName 메서드 안에서의 this는 obj 객체를 바인딩 하고 있다. this.myName 호출하면 값이 제대로 출력된다. 화살표 함수의 this화살표 함수는 자신의 this를 바인딩하지 않고 언제나 상위 스코프인 this를 바인딩 한다. 이를 Lexical this 라고 한다. 일반 함수의 this일반 함수의 경우 function 키워드와 마찬가지로 전역 객체인 window를 바인딩 한다. 1234const func = () =&gt; { console.log(this); // window}func(); 생성자 함수의 this화살표 함수는 생성자 함수로 사용할 수 없다. 1234const Func = () =&gt; { console.log(this);}const obj = new Func(); // Uncaught TypeError: Func is not a constructor 기존의 function 키워드로 만든 일반적인 생성자 함수는 prototype 프로퍼티를 가지며, prototype 프로퍼티가 가르키는 프로토 타입 객체의 constructor를 사용한다. 12function Func() {}console.log(Func.prototype); // {constructor: ƒ} 하지만 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다. 12const Func = () =&gt; {}console.log(Func.prototype) //undefined 메서드의 this12345678var obj = { myName: '나나', getName: () =&gt; { console.log(this); // window console.log(this.myName); // undefined }}obj.getName(); 화살표 함수로 만들어진 메서드의 this는 자신을 포함하는 객체를 바인딩하지 않고 window를 바인딩하기 때문에 화살표 함수는 메서드에 적합하지 않다. References 화살표 함수JavaScript - 화살표 함수(Arrow function)Arrow Function(화살표 함수)이란? :: 마이구미ES6 화살표 함수(arrow function) 변경점 요약 (사용법, this등)","link":"/2020/04/29/javascript-es6-arrow-function/"},{"title":"[JavaScript] ES5(ECMAScript 5)","text":"ECMAScript(ES)의 정의ECMAScript(ES)는 Ecma 인터내셔널의 ECMA-262 기술 규격에 정의된 표준화된 스크립트 프로그래밍 언어이다. 자바스크립트를 표준화하기 위해 만들어졌고 지금도 자바스크립트가 제일 잘 알려져 있지만, 액션스크립트와 J스크립트 등 다른 구현체도 포함하고 있다. ECMA스크립트는 웹의 클라이언트 사이드 스크립트로 많이 사용되며 Node.js를 사용한 서버 응용 프로그램 및 서비스에도 점차 많이 쓰이고 있다. ES5(ECMAScript 5)자바스크립트는 계속해서 발전하며 기술이 추가되었고, 새로운 표준이 발표될 때 마다 ECMAScript 1, 2, 3, 4, 5, 6 … 뒤에 숫자를 붙여서 명명하였다. 우리가 기존에 쓰고 있는 JavaScript는 2009년에 발표된 ECMAScript 5(ES5)라고 생각하면 된다. ES5는 IE9에서 use strict를 지원하지 않는 것 빼고는 대부분의 브라우저 버전에서 ES5 문법을 지원한다. ES5에서 추가된 메서드 및 키워드 use strict String.trim() Array.isArray() Array.forEach() Array.map() Array.filter() Array.reduce() Array.reduceRight() Array.every() Array.some() Array.indexOf() Array.lastIndexOf() JSON.parse() JSON.stringify() Date.now() References [Javascript] ES5 (ECMAScript 5)자바스크립트 Array forEachECMA스크립트","link":"/2020/02/13/javascript-es5/"},{"title":"[JavaScript] ES6 클래스(Class)","text":"ES6에서 class라는 문법이 추가되었고, 기존의 prototype 기반으로 클래스를 선언하는 것보다 명료하게 클래스를 선언할 수 있게 되었다. 기존(ES5) 클래스(생성자)함수를 만들 때는 함수 표현식과 선언식이 있으며, 선언식으로 작성한 클래스는 호이스팅이 일어난다. 여기서 호이스팅이란 함수를 선언했을 때 값들이 유효범위 최상단에 선언되는 것을 말한다. 함수 표현식클래스가 선언되기 전에 인스턴스를 생성하여 에러가 뜬다. 123456789var obj = new Person('한나');obj.getName(); // TypeErrorvar Person = function(name) { this.name = name; Person.prototype.getName = function() { console.log(this.name); }} 함수 선언식인스턴스를 함수 선언 전에 생성해도 오류가 나지 않는다. 클래스를 선언식으로 작성하여 호이스팅되었기 때문이다. 123456789var obj = new Person('한나');obj.getName(); // 한나function Person(name) { this.name = name; Person.prototype.getName = function() { console.log(this.name); }} 새로운(ES6) 클래스(생성자)1234567891011class Person { constructor(name) { this.name = name; } getName() { console.log(this.name); }}const obj = new Person('민수');obj.getName(); // 민수 위 코드는 새로운 클래스 키워드로 클래스를 선언하고 인스턴스를 만든 것이다. 함수 선언이 표현식과 선언식이 있듯이 클래스 키워드도 선언식과 표현식 두가지 방법으로 정의가 가능하다. 1234567891011const obj = new Person('민수');obj.getName(); // ReferenceErrorclass Person { constructor(name) { this.name = name; } getName() { console.log(this.name); }} 위 코드는 에러를 출력하고 있다. 이유는 새로운 클래스는 호이스팅이 일어나지 않는다. 아니 엄밀히 말해 호이스팅이 발생하지 않는 것처럼 동작하는건데 이거는 추후에 알아보도록 하겠다. constructorconstructor는 인스턴스를 생성하고 클래스 필드를 초기화하기 위한 특수한 메서드이다. 클래스 필드(class field)클래스 내부의 캡슐화된 변수를 말하며, 데이터 혹은 멤버 변수라고 부른다. 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 기반 객체지향 언어에서는 클래스 필드라고 부른다. 123456class Person { constructor(name) { // 여기서 this는 생성될 인스턴스를 바라보고 있다. this.name = name; }} constructor는 클래스 내에 한 개만 존재할 수 있으며 이 함수 안에 프로퍼티를 작성하면 되며, 이 안에서 this는 생성될 인스턴스를 바라보고 있다. 메서드 정의123456789class Person { constructor(name) { this.name = name; } // 클래스 몸체에는 메서드만 선언할 수 있다. getName() { console.log(this.name); }} 클래스 몸체 안에는 메서드만 선언할 수 있다. 클래스 몸체 안에 프로퍼티를 선언하면 오류를 출력한다. extendsES6 클래스는 extends키워드로 상속을 구현한다. 12345678910111213141516171819202122class Wrap { constructor(name) { this.name = name; } getName() { console.log(this.name + ' 슈퍼'); }}class Inner extends Wrap { getName() { super.getName() console.log(this.name + ' 상속 받은 클래스'); }}var obj = new Inner('안녕');obj.getName();// 결과// 안녕 슈퍼// 안녕 상속 받은 클래스 위 코드를 보면 Inner는 Wrap를 상속 받았으며, new Inner('안녕')를 실행하면 아래의 과정을 거치게 된다. Inner클래스의 constructor를 호출 Inner클래스의 constructor를 작성하지 않았기 때문에 super클래스(Wrap)의 constructor가 호출됨(내부적으로 프로토타입 체인으로 인해) super클래스의 constructor에서 this는 현재의 인스턴스를 참조하므로 인스턴스의 name프로퍼티로 전달받은 값을 설정 생성한 인스턴스를 Inner에 할당 super위에 코드에서도 잠깐 나왔지만 super키워드는 슈퍼 클래스의 메서드를 호출할 수 있다. 123456789101112131415class Wrap { msg() { console.log('안녕'); }}class Inner extends Wrap { msg() { // 슈퍼 클래스의 msg메서드를 실행한다. super.msg(); }}var obj = new Inner();obj.msg(); staticstatic키워드는 클래스를 위한 정적(static) 메서드를 정의한다. 정적 메서드는 prototype에 연결되지 않고 클래스에 직접 연결되기 때문에 클래스의 인스턴스 없이 호출되며, 클래스의 인스턴스에서는 호출할 수 없다. 123456789101112class Inner { // 인스턴스 없이 클래스에 바로 메서드를 선언해줌 static msg() { console.log('안녕'); }}Inner.msg(); // 안녕var obj = new Inner();obj.msg(); // TypeError 동일한 클래스 내의 다른 정적 메서드 내에서 정적 메서드를 호출하는 경우 키워드 this를 사용할 수 있다. 12345678910class Inner { static msg() { console.log('안녕'); } static msg2() { this.msg(); }}Inner.msg2(); // 안녕 정적 메서드는 어플리케이션을 위한 유틸리티 함수를 생성하는데 주로 사용된다. References super[JS] javascript - OOP Class, SuperES6 Class 파헤치기클래스","link":"/2020/03/04/javascript-es6-class/"},{"title":"[JavaScript] 비구조화 할당(Destructuring Assignment)","text":"정의ECMAScript6(2015)에서 새로 추가된 비구조화 할당(Destructuring Assignment)이란 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 자바스크립트 표현식(expression)이다. 기본 문법(배열)1234567const animalList = [&quot;CAT&quot;, &quot;DOG&quot;, &quot;TIGER&quot;];const cat = animalList[0];const dog = animalList[1];const tiger = animalList[2];console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // TIGER animalList는 “CAT”, “DOG”, “TIGER” 값을 가지고 있는 배열이다. 이 배열의 값을 각각 변수에 할당 하려면 위처럼 각각 하나씩 지정해 줘야 한다. 번거로운 작업이며, 코드도 복잡해보이는 단점이 있다. 1234const [cat, dog, tiger] = [&quot;CAT&quot;, &quot;DOG&quot;, &quot;TIGER&quot;];console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // TIGER 비구조화 할당을 이용하면 위처럼 간단하게 작성할 수 있다. 좌항이 호출될 변수명 집합, 우항이 할당할 값이다. 좌항의 각 요소에는 같은 index를 가지는 배열값이 할당된다. 나머지 패턴123const [cat, ...rest] = [&quot;CAT&quot;, &quot;DOG&quot;, &quot;TIGER&quot;];console.log(cat); // CATconsole.log(rest); // [&quot;DOG&quot;, &quot;TIGER&quot;] 전개연산자(...)를 활용하면 좌항에서 명시적으로 할당되지 않는 나머지 배열 값을 사용할 수 있다. 기본 문법(객체)1234567891011const animals = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot;, tiger: &quot;TIGER&quot;};const cat = animals.cat;const dog = animals.dog;const tiger = animals.tiger;console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // TIGER 객체도 배열과 마찬가지로 일일히 값을 따로 넣어주려면 번거롭다. 12345678const { cat, dog, tiger } = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot;, tiger: &quot;TIGER&quot;};console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // TIGER 위와 같이 작성하면 비구조화 할당을 수행하며, 배열의 경우 좌항의 index값에 값에 할당되었다면, 객체는 같은 key에 있는 값이 담긴다. 나머지 패턴1234567const { cat, ...rest } = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot;, tiger: &quot;TIGER&quot;}console.log(cat); // CATconsole.log(rest); // {dog: &quot;DOG&quot;, tiger: &quot;TIGER&quot;} 배열과 마찬가지로 객체도 나머지 패턴이 있다. 원래의 key 대신 다른 변수명 사용123456789const { cat: catName, dog: dogName, ...rest } = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot;, tiger: &quot;TIGER&quot;, monkey: &quot;MONKEY&quot;}console.log(catName); // CATconsole.log(dogName); // DOGconsole.log(rest); // {tiger: &quot;TIGER&quot;, monkey: &quot;MONKEY&quot;} 좌항의 변수에 다른이름으로 사용할 변수명을 대입하면 되며, 나머지 값을 뜻하하는 전개연산자는 우항의 key에 영향을 받지 않으므로 ...rest: restName이라는 표현식은 무의미 하며, 에러가 난다. 우항의 key 값이 변수명으로 사용 불가 경우12345const { 'cat-name', 'dog name' } = { 'cat-name': &quot;CAT&quot;, 'dog name': &quot;DOG&quot;}// error 좌항으로 전달 받는 key 값이 'cat-name'같이 사용 불가능한 문자열이 있는 경우 에러를 호출한다. 이럴 경우는 아래와 같은 방식으로 비구조화 할 수 있다. 1234567const key = 'dog name';const { 'cat-name': cat_name, [key]: dog_name } = { 'cat-name': &quot;CAT&quot;, 'dog name': &quot;DOG&quot;}console.log(cat_name); // CATconsole.log(dog_name); // DOG 다만 이 경우 'cat-name'과 매칭할 변수명 cat_name을 작성하지 않으면 에러가 발생한다. 객체 비구조화시 변수 선언 키워드가 없는 경우1234567let cat, dog;// { cat, dog } = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot; } // error({ cat, dog } = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot; }) // 괄호로 감싸줘야 함console.log(cat); // CATconsole.log(dog); // DOG 객체 비구조화시 변수 선언 키워드가 없을 경우 소괄호를 사용하여 감싸줘야 한다. 감싸주지 않으면 에러가 난다. 기본값 할당배열의 기본값 할당1234const [cat, dog, tiger] = [&quot;CAT&quot;, &quot;DOG&quot;];console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // undefined 비구조화의 범위를 벗어나는 값 할당을 시도하면 undefined를 반환한다. 이럴 경우를 방지하기 위해 아래처럼 호출될 변수명에 기본값을 할당할 수 있다. 1234const [cat, dog, tiger = &quot;TIGER&quot;] = [&quot;CAT&quot;, &quot;DOG&quot;];console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // TIGER 객체의 기본값 할당1234567const { cat, dog, tiger = &quot;TIGER&quot; } = { cat: &quot;CAT&quot;, dog: &quot;DOG&quot;};console.log(cat); // CATconsole.log(dog); // DOGconsole.log(tiger); // TIGER 배열과 마찬가지로 객체도 기본값을 지원한다. 12const { monkey: monkey_name = 'MONKEY' } = {};console.log(monkey_name); // MONKEY 위 코드처럼 객체의 key에 새로운 변수명을 할당하는 방식에도 기본 기본값 할당을 사용할 수 있다. 복사전개연산자를 사용하여 배열, 객체의 깊은 복사를 할 수 있다. 배열의 깊은 복사12345678910let arr = [1, 2, 3];let copy1 = arr;let [...copy2] = arr;let copy3 = [...arr];arr[0] = 'String';console.log(arr); // [ 'String', 2, 3 ]console.log(copy1); // [ 'String', 2, 3 ]console.log(copy2); // [ 1, 2, 3 ]console.log(copy3); // [ 1, 2, 3 ] 얕은 복사인 copy1은 arr를 참조하기 때문에 0번째 요소가 같이 수정되었지만, 전개연산자를 사용한 copy2와 copy3은 깊은 복사가 되었기 때문에 0번째 요소가 변경되지 않았다. 객체의 깊은 복사객체 역시 전개연산자로 깊은 복사를 사용할 수 있다. 무엇보다 강력한 점은 복사와 함께 새로운 값을 할당할 수 있다는 점이다. 1234567891011let prevState = { name: &quot;foo&quot;, birth: &quot;1995-01-01&quot;, age: 25};let state = { ...prevState, age: 26};console.log(state); // {name: &quot;foo&quot;, birth: &quot;1995-01-01&quot;, age: 26} 위와 같이 ...prevState를 사용하여 기존 객체를 복사함과 동시에 age에 새로운 값을 할당했다. 리액트의 props나 state처럼 이전 정보를 이용하는 경우 유용하게 사용할 수 있다. 함수에서의 비구조화 할당함수의 파라미터 부분에서도 비구조화 할당을 사용할 수 있다. 이러한 문법은 특히 API 응답값을 처리하는데에 유용하게 사용된다. 1234567891011121314151617181920212223function renderUser({name, age, addr}){ console.log(name); console.log(age); console.log(addr);}const users = [ {name: 'kim', age: 10, addr:'kor'}, {name: 'joe', age: 20, addr:'usa'}, {name: 'miko', age: 30, addr:'jp'}];users.map((user) =&gt; { renderUser(user);});// kim// 10// kor// joe// 20// usa// miko// 30// jp users 배열의 map 메서드로 인하여 renderUser 함수에 users의 객체가 각각 전달된다. 각 객체의 key 값이 renderUser함수의 파라미터 받는 부분에서 비구조화 할당을 받았기 때문에 함수 내에서 객체의 key 값을 각각 가져올 수 있게 된다. 1234567891011const users = [ {name: 'kim', age: 10, addr:'kor'}, {name: 'joe', age: 20, addr:'usa'}, {name: 'miko', age: 30, addr:'jp'}];users.map(({name, age, addr}) =&gt; { console.log(name); console.log(age); console.log(addr);}); 마찬가지로 위처럼 map 메서드의 파라미터에도 바로 사용할 수 있다. for of 문을 이용한 비구조화 할당배열 내 객체들은 for of 문을 사용하여 비구조화 할 수 있다. 12345678910const users = [ {name: 'kim', age: 10, addr:'kor'}, {name: 'joe', age: 20, addr:'usa'}, {name: 'miko', age: 30, addr:'jp'}];for(let {name : n, age : a} of users){ console.log(n); console.log(a);} 중첩된 객체 및 배열의 비구조화중첩된 객체 및 배열 역시 비구조화가 가능하다. 12345678910111213const kim = { name: 'kim', age: 10, addr: 'kor', friends: [ {name: 'joe', age: 20, addr:'usa'}, {name: 'miko', age: 30, addr:'jp'} ]};let { name: userName, friends: [ ,{ name: jpFriend }] } = kim;console.log(userName); // kimconsole.log(jpFriend); // miko References 자바스크립트 {…} […] 문법 (비구조화 할당/구조분해 할당)JavaScript ) 비구조화 할당 알아보기구조 분해 할당","link":"/2020/04/30/javascript-es6-destructuring-assignment/"},{"title":"[JavaScript] 전개연산자(Spread Operator)","text":"정의ECMAScript6(2015)에서 새로 추가된 전개연산자(Spread Operator)란 객체나 배열의 값을 하나 하나 넘기는 용도로 사용할 수 있다. 전개연산자를 사용하는 방법은 점 세개(...)를 붙이면 된다. 직관적이고, 배열의 아무 곳에 추가 가능하다.ES5 배열 내용 조합ES5 에서는 배열의 내용을 합쳐 새로운 배열을 만들기 위해서 concat 메서드를 활용한다. 123456const arr1 = [1, 2, 3];const arr2 = [4, 5, 6];const arr3 = [7, 8, 9];const arrWrap = arr1.concat(arr2, arr3);console.log(arrWrap); // [1, 2, 3, 4, 5, 6, 7, 8, 9] arr1 배열에 concat 메서드를 사용하여, 배열 arr2와 arr3를 배열에 이어붙였다. ES6 배열 내용 조합123456const arr1 = [1, 2, 3];const arr2 = [4, 5, 6];const arr3 = [7, 8, 9];const arrWrap = [...arr1, ...arr2, ...arr3];console.log(arrWrap); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 전개연산자를 활용하여 새로운 배열을 만들었다. concat 메서드를 사용한 코드보다 간결하고, 가독성도 개선되었다. 1234const arr = [4, 5, 6];const arrWrap = [1, 2, 3, ...arr, 7, 8, 9]console.log(arrWrap); // [1, 2, 3, 4, 5, 6, 7, 8, 9] concat 메서드는 인자로 전달받은 값 순으로 기존 배열 끝에서부터 값을 추가하지만, 전개연산자는 위처럼 배열의 아무 곳에나 추가 할 수 있다. 전개연산자로 할당하면 2차원 형태가 되지 않는다.배열의 경우concat 메서드로 새로운 배열을 만들어내는 것이 아닌, 기존 배열 요소에 값을 추가한다면 push 메서드를 사용할 것이다. 12345const arr1 = [1, 2, 3];const arr2 = [4, 5];arr1.push(arr2);console.log(arr1); // [1, 2, 3, [4, 5]] arr1 배열에 arr2 배열을 할당했지만 arr2 배열 전체가 들어가 2차원 배열이 되었다. 이 경우 기존 자바스크립트에서는 배열 객체의 프로토타입 매서드인 push.apply를 사용해야 한다. 12345const arr1 = [1, 2, 3];const arr2 = [4, 5];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4, 5] 원하는 결과를 얻었지만 코드가 복잡하다. 하지만 전개연산자를 활용하면 쉽게 구현이 가능하다. 12345const arr1 = [1, 2, 3];const arr2 = [4, 5];arr1.push(...arr2);console.log(arr1); // [1, 2, 3, 4, 5] 객체의 경우객체의 경우도 같다. 12345678910const obj1 = { a: 'A', b: 'B'};const obj2 = { c: 'C', d: 'D'};const objWrap = {obj1, obj2};console.log(objWrap); 12345678910{ obj1: { a: 'A', b: 'B' }, obj2: { c: 'C', d: 'D' }} obj1 객체와 obj2 객체를 하나의 objWrap 객체로 묶으면 객체 각각의 값이 아닌, 객체 자체가 들어가 2차원 객체가 되었다. 12345678910const obj1 = { a: 'A', b: 'B'};const obj2 = { c: 'C', d: 'D'};const objWrap = {...obj1, ...obj2};console.log(objWrap); 123456{ a: 'A', b: 'B', c: 'C', d: 'D'} 전개연산자를 사용하면 객체 자체가 할당되는 것이 아닌, 각각의 값이 할당 된다. 전개연산자를 이용한 복사에는 1차원에서만 유효하다.위에서 전개연산자로 할당하면 2차원 배열이 되지 않는다고 했다. 하지만 2차원 이상의 배열을 할당할 땐 1차원 요소만 같은 1차원 레벨로 할당이 되고 2차원 이상의 배열은 그대로 들어간다. 123const arr1 = [4, 5, [6, 7]];const arr2 = [1, 2, 3, ...arr1];console.log(arr2); // [1, 2, 3, 4, 5, [6, 7]] 기존 배열을 보존해야 할 때 유용하다.ES5 배열 요소를 역순으로 변경전개연산자는 원본 배열을 그대로 유지하면서 새로운 배열을 만든다. 예를 들어 reverse 메서드는 배열의 각 요소를 역순으로 바꾸는 메서드인데, 기존 배열도 바꿔버리는 단점이 있다. 12345const arr1 = [1, 2, 3];const arr2 = arr1.reverse();console.log(arr1); // [3, 2, 1]console.log(arr2); // [3, 2, 1] 원본 배열을 수정할 의도가 있었으면 문제가 되지 않지만, 원본 배열은 그대로 두고 배열 요소의 순서를 뒤집은 새로운 배열이 필요하다면 상황이 복잡해진다. 이 상황에서 전개연산자를 사용하면 편리해진다. ES6 배열 요소를 역순으로 변경12345const arr1 = [1, 2, 3];const arr2 = [...arr1].reverse();console.log(arr1); // [1, 2, 3]console.log(arr2); // [3, 2, 1] 원본 배열은 그대로 유지하면서 새로운 배열을 만들었다. 배열의 나머지 요소를 할당할 수 있다.비구조화 할당과 전개연산자를 사용하여 배열의 나머지 요소를 할당 받을 수 있다. 1234const [first, second, ...rest] = [1, 2, 3, 4, 5];console.log(first); // 1console.log(second); // 2console.log(rest); // [3, 4, 5] 변수 first과 second의 각각의 인덱스 값에 맞는 값이 차례로 들어가고(1, 2), rest에는 할당 받지 못한 나머지 값들이 대입된다. References ES6 문법으로 다시 시작하는 자바스크립트[번역]ES6 축약코딩 기법 19가지[JavaScript] 전개연산자 ( Spread Operator )3. 배열을 좀 더 직관적으로 활용, 전개연산자 (spread operator)전개 구문","link":"/2020/04/29/javascript-es6-spread-operator/"},{"title":"[JavaScript] 함수 메서드(call, apply, bind)","text":"함수의 기본 메서드중 call, apply, bind 에 대해 알아보겠다. 자바스크립트에서 상속개념을 자주 쓰다보면 불필요한 메서드에 프로토타입까지 상속받아 오기 때문에 메모리 낭비가 심해진다. 이때 다른 객체의 메서드를 가져와 쓸 수 있는데 그 기능을 가진 메서드가 call과 apply 이다. call 메서드 먼저 살펴보겠다. call12345func.call(obj, a, b);func = 가져올 메서드call = call 메서드obj = 메서드를 사용할(현재) 객체a, b = 메서드에 전달할 인자 1234567var obj1 = { name: &quot;obj1&quot;, funcThis: function() { return this; }};console.log(obj1.funcThis()); // Object {name: &quot;obj1&quot;} obj1 객체에 funcThis 메서드를 추가했다. funcThis 메서드는 자신을 감싼 obj1객체를 리턴하고 있다. 12345678910var obj1 = { name: &quot;obj1&quot;, funcThis: function() { return this; }};var obj2 = { name: &quot;obj2&quot;};console.log(obj1.funcThis.call(obj2)); // Object {name: &quot;obj2&quot;} call 메서드를 이용하여 obj1 의 funcThis 메서드를 obj2 객체에서 실행한다. obj2객체를 리턴하고 있다. 아무 값을 안넣으면(null) window를 반환한다. call 과 형제격인 apply 메서드는 call 메서드와 같지만 한가지 다른점이 있다. call은 인자값을 하나 하나 전달하지만 apply 메서드는 인자값을 배열로 전달한다. apply12345func.apply(obj, [arr]);func = 가져올 메서드apply = apply 메서드obj = 메서드를 사용할(현재) 객체arr = 메서드에 전달할 인자 목록 call 과 apply 는 보통 함수 내 arguments 객체와 같이 사용하는 모습을 많이 볼 수 있다. 처음에는 어려워 보이지만, 단순하게 보면 결국 arguments 객체에 다른 메서드를 빌려와 쓰는것으로 보면 된다. arguments 객체는 배열처럼 보이지만 실제 배열이 아닌 유사배열객체이기 때문에 배열 메서드가 없다(length 제외). 아래 구문은 arguments에 없는 배열의 메서드를 가져와 쓰는 것이다. 1234function func() { console.log(Array.prototype.slice.call(arguments, 0, 2));}func(&quot;눈&quot;, &quot;누&quot;, &quot;난&quot;, &quot;나&quot;); // [&quot;눈&quot;, &quot;누&quot;] 위 함수를 보면 배열의 프로토타입에 있는 slice 메서드를 arguments 객체에서 사용하는 것을 알 수 있다. 12345slice 메서드 : 문자열의 일정 부분을 반환obj.slice(start, end);obj = 필수. 반환할 배열 객체start = 필수. 지정된 부분의 시작입start = 선택. 지정된 부분의 끝 1234function func() { console.log(Array.prototype.join.call(arguments));}func(&quot;눈&quot;, &quot;누&quot;, &quot;난&quot;, &quot;나&quot;); // 눈-누-난-나 join 메서드 : 인자값으로 넘겨진 구문을 모든 배열 요소에 추가한다. 123obj.join(&quot;val&quot;);obj = 필수. 반환할 배열 객체val = 선택. 추가할 문자열 이다. 아무값도 안넣을 경우 쉼표(,)로 대체된다. bindbind 함수는 함수가 가르키는 this만 바꾸고 호출은 하지 않는다. 1234567891011var obj1 = { name: &quot;obj1&quot;, funcThis: function() { console.log(this); }};var obj2 = { name: &quot;obj2&quot;};var func = obj1.funcThis.bind(obj2);func(); // Object {name: &quot;obj2&quot;} obj1 의 funcThis 메서드를 obj2 객체로 가져와서 func 변수에 할당했다. func 함수를 실행하면 obj2 객체가 출력된다.","link":"/2018/11/08/javascript-function-method/"},{"title":"[JavaScript] 바닐라 자바스크립트로 인덱스 구하기","text":"제이쿼리의 index()를 바닐라 자바스크립트로 구현하는 방법이다. HTML123456&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; javascript123456789var ul = document.getElementById('ul'), li = ul.getElementsByTagName('li');for (var i = 0; i &lt; li.length; i++) { (function(idx) { li[idx].onclick = function() { alert(idx); } })(i);} 결과아래 리스트 요소를 클릭하면 인덱스가 alert에 출력되는 것을 확인할 수 있다. #ul { margin: 0; list-style: none; } #ul > li { border-radius: 5px; padding: 2px 10px; width: 50px; text-align: center; cursor: pointer; background-color: #ccc; color: #fff; } #ul > li:hover { background-color: #333; } 0 1 2 3 var ul = document.getElementById('ul'), li = ul.getElementsByTagName('li'); for (var i = 0; i < li.length; i++) { (function(idx) { li[idx].onclick = function() { alert(idx); } })(i); }","link":"/2018/01/15/javascript-get-index/"},{"title":"[JavaScript] Fetch API","text":"자바스크립트의 fetch 함수는 비동기 통신 API로써 서버에 네트워크 요청을 보내 새로운 정보를 받아올 수 있다. ES6부터 지원하며, 가독성이 매우 뛰어난 장점이 있다. 이곳을 클릭하면 {&quot;message&quot;: &quot;hello world&quot;}라는 JSON 데이터 화면이 나온다. fetch API를 이용해 이 JSON을 가져와 보자. 기본 형태fetch API의 기본 형태는 아래와 같다. 12345fetch(url, [options]) .then((res) =&gt; res.json()) .then((res) =&gt; { // data를 응답 받은 후 로직 }); url에는 접근하고자 경로를 넣으면 된다. options에는 method나 header등을 지정하여 요청할 수 있다. options에 아무값도 넘기지 않으면 요청은 GET 메서드로 진행된다. 화살표 함수를 함수 선언식으로 변경하면 아래와 같다. 1234567fetch(url, [options]) .then(function(res) { return res.json(); }) .then(function(res) { // data를 응답 받은 후 로직 }); 위에서 언급한 주소를 입력하여 JSON 데이터를 잘 가져오는지 확인해 본다. 요청 하기1234567891011121314fetch('https://recordboy.github.io/ui/dummy/data.json') .then(function(res) { // Response Object console.log(res); // 응답값 JSON 형태로 얻기 return res.json(); }) .then(function(res) { // 리턴 받은 JSON console.log(res); }); 응답값은 첫번째 then에 지정된 함수의 res에 담겨지며, 이 값은 http 응답값을 가지고 있는 Response Object이다. 첫번째 then의 응답값을 JSON 형태로 얻기 위해 Response Object의 json() 함수를 호출하여 값을 리턴한다. 두번째 then에서 응답 받은 JSON을 확인할 수 있다. References fetchfetch() 함수 사용법Javascript에서의 비동기 통신","link":"/2020/09/22/javascript-fetch-api/"},{"title":"[JavaScript] 이벤트 위임(Event Delegation)","text":"어플리케이션을 제작할 때 사용자가 페이지 요소들을 조작할 수 있도록 페이지의 버튼, 텍스트 등에 이벤트를 붙여야 할 때가 있다. 아래 리스트의 각 요소를 클릭하면 경고창이 뜨는 이벤트를 걸어줘야 된다고 가정해보면 아래처럼 구현할 것이다. html 1234567&lt;ul id=&quot;list&quot;&gt; &lt;li&gt;list01&lt;/li&gt; &lt;li&gt;list02&lt;/li&gt; &lt;li&gt;list03&lt;/li&gt; &lt;li&gt;list04&lt;/li&gt; &lt;li&gt;list05&lt;/li&gt;&lt;/ul&gt; javascript 12345678var item = document.getElementById('list').getElementsByTagName('li');for (var i = 0; i &lt; item.length; i++) { // 각 li에 이벤트 리스너를 등록한다. item[i].addEventListener('click', function(e) { alert(e.target.innerText); })} 결과 list01 list02 list03 list04 list05 var item = document.getElementById('list').getElementsByTagName('li'); for (var i = 0; i < item.length; i++) { // 각 li에 이벤트 리스너를 등록한다. item[i].addEventListener('click', function(e) { alert(e.target.innerText); }) } 리스트 요소가 많이 없는 경우 위 코드는 별 문제가 되지 않는다. 하지만 리스트 요소가 천개, 만개라면 일일히 분리된 이벤트 리스너를 생성하고, 그걸 각각 요소에 등록할 것이다. 이는 매우 비효율적인 방법이다. 아이템 갯수마다 이벤트 리스너를 생성, 등록하는 것보다는 감싸고 있는 리스트에 한개의 이벤트를 등록하고, 조건을 달아줘서 리스트의 요소를 클릭했을시에만 경고창을 출력하도록 구현하면 된다. javascript 1234567891011var list = document.getElementById('list');var item = list.getElementsByTagName('li');// 리스트에 이벤트를 등록list.addEventListener('click', function(e) { // 리스트 요소일 때 경고창 출력 if (e.target.nodeName === 'LI') { alert(e.target.innerText); }}) References 자바스크립트 코딩 면접에서 알고 있어야 할 3가지 질문","link":"/2020/03/02/javascript-event-delegation/"},{"title":"[JavaScript] 자바스크립트 eval() 함수","text":"eval() 정의 eval()은 전역 객체(window)의 함수 속성이다. eval()의 인자는 문자열이며 문자열 형태를 연산할 수 있다. 12345console.log('2 + 2');// 2 + 2console.log(eval('2 + 2'));// 4 eval() 문제점 굳이 eval() 함수를 쓰지 않아도 충분히 동일한 동작을 구현할 수 있는 경우가 많다. 보안상 위험한 javascript 코드를 실행할 수 있다는 위험때문에 eval() 함수는 권장되지 않는다. References eval()eval() 사용과 문제점 : #eval() is evilJavaScript eval 함수","link":"/2017/12/01/javascript-mehod-eval/"},{"title":"[JavaScript] 자바스크립트 소개","text":"자바스크립트는 프로토타입 기반의 스크립트 언어이며 넷스케이프사의 브렌던 아이크가 만들었다. 주로 웹 브라우저 내에서 주로 사용되며 node.js와 같은 런타입 환경에서 서버 사이드 프로그래밍으로도 사용되고 있다. 초창기 자바스크립트는 웹 페이지 제작에 있어서 보조적인 기능을 수행하기 위한 용도로써 사용되었다. 클라이언트인 웹 브라우저에서 서버로부터 받은 HTML과 CSS, 데이터로 렌더링을 해주는 수준이였다. 이 시절에 자바스크립트는 그다지 중요한 역할을 담당하지 못했다. 하지만 소수의 프로그래머들에 의해 여러 가지 연구가 이루어졌고, 웹 아키텍쳐에도 크고 작은 변화가 일어났다. 특히 과거에 서버에서 담당했던 역할들이 상당 부분 웹 브라우저로 이동하였고, 자바스크립트는 이 변화의 중점에 서게 된다. 게다가 jQuery 의 등장으로 보다 쉽게 DOM을 핸들링하게 되면서 많은 발전을 이루었다. 현재는 브라우저 기반의 자바스크립트 라이브러리 뿐만 아니라 Node.js와 같은 서버 기반의 자바스크립트 환경에서 동작할 수 있는 각종 라이브러리까지 쏟아져 나오고 있다. 이제는 자바스크립트만으로 웹 서버와 클라이언트인 웹 페이지 개발을 동시에 할 수 있는 수준까지 왔다고 볼 수 있다. 자바스크립트는 클래스를 지원하지 않아 클래스 상속을 이용한 객체 지향 프로그래밍은 할 수 없지만, 프로토타입의 복제 과정을 이용하여 상속을 흉내내도록 구현이 가능하다. 객체 지향 프로그래밍(OOP)줄여서 OOP 라고 부르겠다. OOP는 컴퓨터 프로그래밍 패러다임중 하나이며, 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 “객체” 들의 모임으로 파악하고자 하는 것이다. 각각의 객체들은 메시지를 주고받고, 데이터를 처리할 수 있다. 객체지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용되고, 보수를 간편하게 하며 보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있다.객체지향의 반대로는 절차지향 프로그래밍(procedural Programming)이라는 패러다임이 있다. 절차지향 프로그래밍이란 순차적인 처리가 중요시되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 대표적인 절차지향 언어에는 C언어가 있다. OOP의 특성으로는 추상화(Abstraction), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있다.","link":"/2017/02/01/javascript-introduce/"},{"title":"[JavaScript] 자바스크립트 반올림, 올림, 내림","text":"반올림Math.round(); 12var num = 3.5;console.log(Math.round(num)); // 4 올림Math.ceil(); 12var num = 3.5;console.log(Math.ceil(num)); // 4 내림Math.floor(); 12var num = 3.5;console.log(Math.floor(num)); // 3","link":"/2017/11/01/javascript-math-round/"},{"title":"[JavaScript] 자바스크립트 모듈 패턴","text":"모듈 패턴이란?모듈이란 전제 어플리케이션의 일부를 독립된 코드로 분리하여 만들어 놓은 것이다. 모듈화를 했을 때 장점 자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 활용할 수 있다. 코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다. 코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다. 필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다. 한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드할 때 시간과 네트워크 트래픽을 절약할 수 있다.(브라우저에서만 해당) 객체 리터럴을 사용한 모듈 패턴자바스크립트에서 모듈을 구현하는 가장 쉬운 방법은 객체 리터럴을 사용하는 방법이다. 123456789var module = { key: 'data', publicMethod: function() { return this.key; }}console.log(module.key); // dataconsole.log(module.publicMethod()); // data 객체 리터럴은 모듈 패턴이기도 하며, 하나의 객체라는 점에서 싱글톤 패턴이라고도 할 수 있다. 동일한 코드를 어떠한 관점에서 보느냐에 따라 다양한 패턴이 될 수 있다. 객체 리터럴은 간단하지만 모든 속성이 공개되어있다는 단점이 있다. 독립된 모듈은 자체적으로 필요한 내부 변수 및 내부 함수를 모두 갖고 있어야 하므로 클로저를 이용해야 한다. 아래는 클로저를 활용한 모듈패턴이다. 클로저를 활용한 모듈 패턴1234567891011121314151617181920212223242526var module = (function() { /** * ----------------------- * 모듈 패턴을 구현할 클로저 코드 * ----------------------- */ // 은닉될 멤버 정의 var privateKey = 0; function privateMethod() { return privateKey++; } // 공개될 멤버(특권 메서드) 정의 return { publicKey: privateKey, publicMethod: function() { return privateMethod(); } }})()console.log(module.publicMethod()); // 0console.log(module.publicMethod()); // 1 모듈 패턴의 반환값은 함수가 아닌 객체이다. 위의 코드를 순서대로 보면 익명함수가 자동으로 실행되고 반환된 객체를 module 변수에 할당한다. 따라서 module.publicMethod()처럼 메서드를 호출할 수 있다. 자동 호출되는점을 제외하고 클로저와 유사하다. 클로저 경우12345678910function func() { var private = 0; return function() { private++; return private; }}var val = func();console.log(val()); // 1console.log(val()); // 2 그리고 인스턴스를 여러개 만들어 낼 수 있는 구조라는 점에서 싱글톤 패턴과 차이가 있다. 싱글톤 패턴 경우12345678910111213141516171819202122232425var singleton = (function() { var instance; var private = 0; function init() { return { publicKey: private, publicMethod: function() { return publicKey; } } } return function() { // 싱글톤 패턴은 아래 조건문에서 처음 인스턴스가 선언되면 다시 인스턴스를 만들지 않고 기존의 인스턴스를 리턴한다. if (!instance) { instance = init(); } return instance; }})()var singleton1 = singleton();var singleton2 = singleton();console.log(singleton1 === singleton2); // true 하나의 인스턴스를 선언하지 않고 여러개의 인스턴스를 생성하려면 익명함수를 사용하지 않고 생성자 함수 방식으로 만들면 된다. 1234567891011121314151617181920212223var Module = function() { var privateKey = 0; function privateMethod() { return privateKey++; } return { publicKey: privateKey, publicMethod: function() { return privateMethod(); } }}var obj1 = Module();console.log(obj1.publicMethod()); // 1console.log(obj1.publicMethod()); // 2var obj2 = Module();console.log(obj2.publicMethod()); // 1console.log(obj2.publicMethod()); // 2 위처럼 Module 함수를 정의하여 함수를 호출하면 여러개의 인스턴스를 생성할 수 있다. 클로저 인스턴스와 유사하지만, 한가지 차이점은 내부의 익명함수에서 반환값이 함수가 아니라 객체를 반환한다는 점이다. 모듈 패턴과 네임 스페이스 패턴을 함께 사용하면 더욱 깔끔한 코드가 완성된다. 123456789101112131415161718var app = app || {};app.module = (function() { var privateKey = 0; function privateMethod() { return privateKey++; } return { publicKey: privateKey, publicMethod: function() { return privateMethod(); } }})();console.log(app.module.publicMethod()); // 0console.log(app.module.publicMethod()); // 1 References module pattern (모듈패턴) #1[JS_Design Pattern] 2. 모듈 패턴 (Module Pattern)","link":"/2020/02/03/javascript-module-pattern/"},{"title":"[JavaScript] 자료형(원시 타입)","text":"자료형이란?자료형은 데이터 값의 유형이다.원시타입과 객체(참조)타입으로 나눌 수 있다. 원시타입 문자열(String) 숫자(Number) 논리형(Boolean) 언디파인드(Undefined) 널(Null) 객체(참조)타입 객체(Object) 배열(Array) 함수(Function) 여기서 객체(참조)타입과 객체(Object)의 차이에 대해 혼동하기 쉽다. 객체(참조)타입은 기본타입을 제외한 모든 자바스크립트의 객체를 가르키며, 객체(Object), 배열(Array), 함수(Function)도 객체(참조)타입 에 포함된다. 객체(Object)는 자바스크립트에서 표현되는 자료형의 값이며 객체(참조)타입중에 하나인 객체(Object)이다. 원시타입문자(string)우리가 실생활에서 쓰고 있는 글자를 문자열이라고 생각하면 된다. 변수에 담는 방식은 큰따옴표나 작은 따옴표로 감싸서 저장하시면 된다. 문자열에 따옴표를 포함하고 싶으면 다른 따옴표로 감싸주면 된다. 12var str = 'data'; // 문자열을 담을 때var str = &quot;'data'&quot;; // 작은 따옴표를 문자열에 추가하고 싶을때 참고로 따옴표를 문자열로 인식하고 싶을때는 역슬래쉬를 따옴표 앞에 붙여 사용하면 된다. 이 작업을 이스케이핑이라고 부른다. 1var str = &quot;'data'&quot;; // 작은 따옴표를 문자열로 인식하고 싶을때 숫자(number)우리가 알고있는 숫자라고 생각하면 된다. 자바스크립트는 모든 숫자를 64비트 부동소숫점 형태로 저장하기 때문에 하나의 타입만 존재하며 형태는 크게 정수형(10진수, 16진수), 실수형으로 나뉜다. 정수형(10진수) : 평상시에 사용하는 10진수이며, 소숫점이 없다. 정수형(16진수) : Ox로 시작하며 숫자 09와 문자 AF를 사용해서 숫자를 표현한다. 보통 색상을 나타낼때 사용한다.(예 : 0xF00) 실수형 : 소숫점을 갖는 숫자 자바스크립트는 소숫점을 계산할때 한가지 오류가 있는데 확인하고 넘어가자하단의 코드를 보면 1console.log(0.1 + 0.2); 결과는 0.3 이 나올겉 같지만 0.30000000000000004 가 출력이 된다. 이것이 부동소수점 오류며 아래와 같은 방법으로 해결을 할 수 있다. 주의하도록 하자. 1console.log(((0.1 * 10) + (0.2 * 10)) / 10); 논리형(boolean)쉽게 설명해서 참, 거짓이라고 생각하면 된다. 참 : true 거짓 : false 데이터 타입마다 true, false로 변환되는 값이 다르다. 데이터 타입 true로 변환되는 값 false로 변환되는 값 불리언 true flase 문자열 비어 있지 않은 모든 문자열 “”(빈 문자열) 숫자 0이 아닌 모든 숫자(무한대 포함) 0, NaN 객체 모든 객체 null Undefined 해당 없음 undefined 언디파인드(undefined)언디파인드는 아무 값도 없는 상태이다. 1var val; // undefined 널(null)널은 아무것도 참조하고 있지 않다라는 의미이다. 여기서 언디파인드와 널이 조금 헷갈리는데, 언디파인드는 값 자체가 선언이 되지 않은거고 널은 임의로 빈 값으로 선언한 상태라고 보면 된다. 널은 객체를 담을 변수를 초기화할때 많이 사용한다. 각 자료형의 초기화1234var num = 0; // 숫자 초기화var str = ''; // 문자 초기화var boolean = false; // 논리형 초기화var obj = null; // 객체 초기화","link":"/2017/05/03/javascript-primitive-data-type/"},{"title":"[JavaScript] 자바스크립트 변수 명명 규칙","text":"변수, 함수명은 카멜 케이스를 사용한다.첫글자는 소문자, 단위로 첫글자 대문자를 사용, 중간에 언더바(_)사용 금지한다. 대표적인 표기법으로 카멜 케이스, 파스칼 표기법, 헝가리안 표기법, 스네이크 표기법이 있으며 사용하는 언어에 따라 권장사항이 다르다. 1var pageName; 상수는 영문 대문자 스네이크 표기법을 사용한다.1var SYMBOLIC_NAME; 여러 단어가 합쳐져 만들어진 약어(HTML, XML)의 경우는 전부 대문자로 사용한다. 1var HTML; 생성자 함수는 대문자 카멜 케이스를 사용한다.123function Func() { ...} 지역변수 혹은 private 변수는 언더바(_)로 시작한다.1var _private; 예약어를 사용하지 않는다.12345// badvar if;var for;var this;... 전역 변수를 사용하지 않는다.모든 컴파일 단위는 하나의 공용 전역 객체(window)에 로딩된다. 전역 변수는 언제든지 프로그램의 모든 부분에서 접근할 수 있기 때문에 편하지만, 바꿔 말하면 프로그램의 모든 부분에서 변경될 수 있고, 그로 인해 프로그램에 치명적인 오류를 발생시킬 수 있다. 1var global = 'data'; 암묵적 전역 변수를 사용하지 않는다.12345678910111213141516171819202122// badfunction sum(x, y) { result = x + y; return result;}// badfunction foo() { var a = b = 0; // var a = (b = 0);와 같다. b가 암묵적 전역이 된다.}// goodfunction sum(x, y) { var result = x + y; return result;}// goodfunction foo() { var a, b; a = b = 0;} References 코딩 컨벤션","link":"/2020/02/05/javascript-naming-convension/"},{"title":"[JavaScript] 함수형 프로그래밍의 순수 함수","text":"함수형 프로그래밍부수 효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임 부수 효과: 외부 상태를 변경하거나 함수로 들어온 인자 상태를 변경하는 것 순수 함수 동일한 입력에 대해 항상 동일한 출력을 반환하는 함수 외부의 상태를 변경하거나 영향을 받지 않는 함수 순수한 함수12345function func(a, b) { return a + b;}console.log(func(2, 2)); // 4 위 func 함수는 순수하다. 언제나 이 함수를 수백번 실행시켜도 입력값이 2, 2면 출력값이 4로 동일하기 때문이다. 또한 이 함수는 외부의 값에 영향을 주거나 받지 않는다. 순수하지 않은 함수1234567891011let c = 1;function func(a, b) { return a + b + c;}console.log(func(2, 2)); // 5c = 2; // c 값이 변경됨console.log(func(2, 2)); // 6 위 함수는 외부 값인인 c에 영향을 받기 때문에 순수함수가 아니다. c가 변하면 동일한 입력에 대해 출력이 다르기 때문이다. 12345678910let c = 1;function func(a, b) { c += 1; // 외부의 값에 변화를 주며, 이를 부수효과라 함 return a + b;}func(2, 2); // 함수 실행console.log(c); // c 값이 2로 변화됨 위 함수도 함수가 실행되면 외부값인 c를 변경시키기 때문에 순수 함수가 아니며, 이를 부수 효과라 한다. 1234567891011let obj = { a: 1};function func(obj) { return obj.b = 1; // 인자로 받은 객체에 b 값을 추가하여 리턴}func(obj);console.log(obj); // { a: 1, b: 1 } 객체의 경우도 살펴보자. 위 함수도 외부 obj 객체에 b가 추가되었기 때문에 순수함수가 아니다. 123456789let obj = { a: 1};function func(obj) { return obj; // 인자로 받은 객체를 그대로 리턴}let obj2 = func(obj); 위의 경우는 어떨까? 함수 안에서는 객체를 받고 아무런 변화를 주지 않고 리턴하였으며, 새로운 변수에 리턴된 객체를 할당했다. 위 함수에서는 객체에 아무런 변화를 주지 않았으니 순수 함수라고 할 수 있을까? 1234567891011121314let obj = { a: 1};function func(obj) { return obj; // 인자로 받은 객체를 그대로 리턴}let obj2 = func(obj); // 새로운 변수에 리턴된 객체를 할당obj2.a = 2; // 새로운 객체 obj2의 a 값을 변경console.log(obj2); // { a: 2 }console.log(obj); // { a: 2 } 정답은 아니다. func 함수를 실행하여 새로운 변수에 리턴받은 객체를 할당했으며, 새로운 객체 obj2의 a 값을 변경하였다. 그랬더니 기존의 obj 객체의 값도 변경이 되었다. 바로 객체의 참조(주소) 값도 같이 복사되어 새롭게 만든 obj2가 변화함에 따라 기존의 obj 객체도 변경되기 때문이다. 이처럼 함수 내에서 직접 값을 변경하지 않았더라도 함수에 들어온 인자값을 그대로 사용하면 순수 함수가 아니다. 12345678910111213141516171819let obj = { a: 1};function func(obj) { // 객체의 값만 참조하여 새로운 객체를 리턴 return { a: obj.a, b: 2 };}let obj2 = func(obj);obj2.a = 2;console.log(obj2); // { a: 2, b: 2 }console.log(obj); // { a: 1 } 위에서는 인자로 받은 객체를 직접 사용하지 않고 obj.a 값만 참조해서 새로운 객체를 생성하여 리턴하고 있다. 이럴 경우는 참조(주소)값이 복사가 안되기 때문에 obj2 객체의 값이 변경되도 obj의 값이 변경되지 않는다. 그러므로 위 함수는 순수 함수라 할 수 있다. 결론모든 함수가 순수 할수일 수는 없다. 모든 함수가 순수 함수라면 외부의 어떤 데이터에도 변형을 주지 않기 때문에 프로그램은 구동되지 않을 것이다. 단지, 이런 스타일로 코딩하는것이 함수형 프로그래밍의 패러다임 이며, 이 패러다임의 목적은 외부 상태의 변화를 최소함으로 유지하고, 함수 실행 결과 예측을 용이하게 하여 버그 발생 가능성을 줄이는 것에 목적이 있다. [번역] JavaScript 함수형 프로그래밍 3단계로 설명하기순수 함수란 무엇인가요… 별거 없음…JS 함수형 프로그래밍을 위한 사전 지식 : 순수함수, 일급함수자바스크립트의 함수형 프로그래밍 1 : 순수 함수란?순수 함수란? (함수형 프로그래밍의 뿌리, 함수의 부수효과를 없앤다)","link":"/2020/12/09/javascript-pure-function/"},{"title":"[JavaScript] 재귀 함수(Recursive Function)","text":"재귀(Recursive)를 정의한다면 한 함수가 자기 자신을 호출하는 순간이다. 재귀함수를 이해하기 전에는 팩토리얼 이라는 개념이 필요하다. 팩토리얼이란 자기 자신의 수에 1 작은 수를 곱하고 또 1 작은 수를 곱하고 해서 1 작은 수가 1이 될때까지 곱하는 것이다. 팩토리얼의 기호는 !이며 아래의 예제는 5!의 팩토리얼을 나타내고 있다. 15 * 4 * 3 * 2 * 1 = 120 이제 팩토리얼의 개념을 알았으니 재귀함수가 무엇인지 확인해 본다. 123456function factorial(x) { if (x &lt; 0) return; if (x === 0) return 1; return x * factorial(x - 1);}console.log(factorial(3)); // 6 결과 값이 나오는 과정을 순서대로 살펴보겠다. factorial 함수에 인자값으로 3을 담아 함수를 실행한다. 파라미터로 3을 받아 처음 조건문을 거친다. 3은 0보다 크기 때문에 다음 조건문으로 이동한다. 3은 0이 아니기 때문에 아래 구문으로 넘어간다. 3에 factorial 함수에 2를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 2를 넣어 실행한다. 2는 0보다 크고 0이 아니니 다시 아래 구문으로 내려간다. 2에 factorial 함수에 1를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 1를 넣어 실행한다. 1역시 0보다 크고 0이 아니니 다시 아래 구문으로 내려간다. 1에 factorial 함수에 0를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 0를 넣어 실행한다. 위와는 다르게 0은 두번째 조건문에서 걸려 1을 리턴한다. 결국은 3 * 2 * 1라는 값을 리턴하게 되는 것이다. 이렇게 함수가 자기 자신을 호출하는 순간을 재귀 라고 한다. References 재귀 함수자바스크립트 개발자라면 알아야 할 33가지 개념 #23 자바스크립트 : 자바스크립트 재귀(Recursion) 이해하기","link":"/2017/12/16/javascript-recursive/"},{"title":"[JavaScript] 프로토타입(Prototype)","text":"자바스크립트는 클래스라는 개념이 없다. 클래스는 자바, 파이썬, 루바 등 객체지향 언어에서 빠질수 없는 개념이다. 하지만 자바스크립트도 객체지향언어인데, 클래스 대신 프로토타입(Prototype)을 기반으로 클래스의 상속 기능을 흉내내도록 구현하여 사용한다. 그래서 자바스크립트는 프로토타입 기반의 객체 지향 언어라고 한다. 자바스크립트의 모든 객체는 자신의 부모역할을 담당하는 객체와 연결되어 있다. 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메서드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 프로토타입 이라 한다. 프로토타입은 언제 쓰는가123456789101112function Person() { this.eyes = 2; this.nose = 1;}var kang = new Person();var park = new Person();console.log(kang.eyes); // 2console.log(kang.nose); // 1console.log(park.eyes); // 2console.log(park.nose); // 1 kang과 park은 eyes와 nose를 공통적으로 가지고 있는데, 메모리는 eyes와 nose가 두개씩 총 4개에 할당된다. 객체를 100개를 만들면 200개의 변수가 메모리에 할당된다. 이런 메모리 낭비 문제를 프로토타입으로 해결할 수 있다. 12345678910function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kang = new Person();var park = new Person();console.log(kang.eyes); // 2console.log(park.nose); // 1 간략히 설명하면 Person.prototype라는 빈 객체가 어딘가에 존재하고 Person함수로부터 생성된 객체(kang, park)은 어딘가에 존재하는 객체의 값을 모두 갖다쓸 수 있다. 즉, eyes와 nose를 어딘가에 있는 빈 객체(Person.prototype)에 넣어두고, kim과 park이 공유해서 사용하는 것이다. 프로토타입 객체와 프로토타입 링크자바스크립트에서는 프로토타입 객체(prototype object)와 프로토타입 링크(prototype link)라는 것이 존재한다. 그리고 이 둘을 통틀어 프로토타입이라고 부른다. 객체는 언제나 함수로 생성된다.12function Person() {} // 함수var obj = new Person(); // new 키워드와 함수로 객체를 생성 obj 객체는 Person이라는 함수로 생성된 객체이다. 일반적인 객체 리터럴 방식도 예외는 아니다. 1var obj = {}; 객체 리터럴 방식으로 객체를 생성하였는데 이 방식은 아래 방식과 같다. 1var obj = new Object(); Object도 객체를 만드는 생성자 함수이다. Object와 마찬가지로 Function, Array도 모두 생성자 함수이다. 이 사실은 프로토타입과 밀접하게 관련이 있는데 함수가 정의될 때는 2가지 일이 동시에 일어나기 때문이다. 함수가 정의될 때해당 함수에 constructor(생성자) 자격 부여constructor 자격이 부여되면 new 키워드를 통해 객체를 만들수 있다. 오직 함수만 new 키워드를 사용할 수 있다. 123var obj = {}; // 객체 선언var a = new obj();// Uncaught TypeError: obj is not a constructor obj는 생성자 자격이 없다고 나온다. 오직 함수만이 constructor 자격을 가질 수 있다. 해당 함수의 프로토타입 객체 생성 및 연결함수를 정의하면 함수만 생성되는 것이 아니라 프로토타입 객체도 같이 생성이 된다. 생성된 함수는 prototype라는 속성을 통해 프로토타입 객체에 접근할 수 있다. 프로토타입 객체는 일반적인 객체와 같으며, 기본적인 속성으로 constructor와 __proto__를 가지고 있다. 12345function Person() {}console.log(Person.prototype);// {constructor: ƒ}// &gt; constructor: ƒ Person()// &gt; __proto__: Object constructor는 프로토타입 객체와 같이 생성되었던 함수를 가르키고 있다. __proto__은 프로토타입 링크다. 프로토타입 링크는 아래에서 다시 알아보도록 하고 위에서 언급된 eyes, nose예제를 다시 살펴보겠다. 1234567891011121314function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kang = new Person();var park = new Person();console.log(Person.prototype);// {eyes: 2, nose: 1, constructor: ƒ}// &gt; eyes: 2// &gt; nose: 1// &gt; constructor: ƒ Person()// &gt; __proto__: Object Person.prototype라는 빈 객체가 어딘가에 존재하고, 그 객체에 eyes, nose값을 할당한 것을 확인할 수 있다. 프로토타입 객체는 일반적인 객체이므로 속성을 마음대로 추가, 삭제할 수 있으며 kang과 park은 Person함수를 통해 생성되었으니 Person.prototype를 참조할 수 있게 된다. 프로토타입 링크12345678function Person() {}Person.prototype.eyes = 2;var kang = new Person();console.log(kang);// Person {}console.log(kang.eyes);// 2 kang객체에 따로 eyes속성을 선언하지 않았지만 kang.eyes를 실행하면 2라는 값을 참조한다. 위에서 설명했듯이 프로토타입 객체의 eyes속성을 참조한 것인데, 이것이 가능한 이유는 kang이 가지고 있는 __proto__속성이 프로토타입 객체를 가르키고 있기 때문이다. 12console.log(kang.__proto__);// {eyes: 2, nose: 1, constructor: ƒ} kang.__proto__ 속성을 확인해보니 프로토타입 객체를 가르키고 있다. kang객체는 직접 eyes속성을 가지고 있지 않아 eyes속성을 찾을 때 까지 상위 프로토타입을 탐색한다. 최상위인 Object의 프로토타입 객체까지 도달했는데도 못찾을 경우 undefined를 리턴한다. 이렇게 __proto__속성을 통해 상위 프로토타입과 연결되어있는 형태를 프로토타입 체인이라고 한다. 이런 프로토타입 체인 구조 때문에 모든 객체는 Object의 자식이라고 하며, Object에 있는 모드 속성을 사용할 수 있다. References [Javascript ] 프로토타입 이해하기Javascript 기초 - Object prototype 이해하기JavaScript : 프로토타입(prototype) 이해","link":"/2018/12/17/javascript-prototype/"},{"title":"[JavaScript] 비동기 처리를 위한 프로미스","text":"자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 콜백 패턴은 가독성이 나쁘고, 비동기 처리 중 발생한 에러의 예외처리가 곤란하며, 여러개의 비동기 처리 로직을 한꺼번에 처리하는 것도 한계가 있다. ES6에서 비동기 처리를 위한 또 다른 패턴으로 프로미스(Promise)를 도입하였다. 프로미스는 비동기적으로 요청한 결과(성공/실패)를 나타내는 객체로서, 콜백 패턴이 가진 단점을 보완하며, 비동기 처리 시점을 명확하게 표현한다. 기존의 콜백 함수 패턴기존의 비동기 처리 방식은 콜백 패턴을 이용하는 방법이였으며 코드는 아래와 같다. 12345678910111213function findUser(id, callback) { setTimeout(function () { const user = { id: id, name: 'my name is ' + id }; callback(user); }, 1000);}findUser('foo', function (user) { console.log(user); // { id: 'foo', name: 'my name is foo' }}); user객체의 정보를 받아오는 구조다. getUser() 함수를 호출할 때 두번째 인자로 콜백 함수가 할당된다. setTimeout()함수로 인하여 1초 뒤 user객체의 정보를 담는 로직이 실행되며 결과물이 두번째 인자로 들어간 콜백 함수의 인자에 할당되어 콜백 함수가 호출된다. 프로미스 패턴상단의 비동기 처리 방식을 프로미스를 이용하면 아래와 같이 작성할 수 있다. 123456789101112131415function findUser(id) { return new Promise(function (resolve, reject) { setTimeout(function () { const user = { id: id, name: 'my name is ' + id, }; resolve(user); }, 1000); });}findUser('foo').then(function (user) { console.log(user); // { id: 'foo', name: 'my name is foo' }}); 위 코드는 콜백 함수를 인자로 넘기는 대신에 프로미스 객체를 생성하여 리턴을 하고, 리턴받은 프로미스 객체의 then()메서드를 호출하여 실행할 로직을 인자값으로 넣어줬다. 실행할 로직은 resolve 메서드에 할당되어 user객체의 결과값을 콘솔창에 출력하고 있다. resolve()와 then()가 생소하다. 아래에서 천천히 알아보도록 하겠다. 프로미스의 3가지 상태프로미스는 3가지의 상태(states)를 가지며, 여기서 상태란 프로미스의 처리 과정을 의미한다. new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 가진다. Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태 Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태 Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태 Pending(대기)아래처럼 new Promise()생성자를 호출하면 대기 상태가 된다. new Promise() 생성자를 호출할 때 인자로 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject이다. 123const promise = new Promise(function (resolve, reject) { // ...}); 실제로는 변수에 할당하기 보단 어떤 함수의 리턴값으로 많이 사용되며, 생성자의 인자로 화살표 함수를 많이 사용한다. 12345function returnPromise() { return new Promise((resolve, reject) =&gt; { // ... });} Fulfilled(이행)넘겨 받은 인자에서 resolve를 함수로 실행하면 이행(완료) 상태가 된다. 12345function returnPromise() { return new Promise((resolve, reject) =&gt; { resolve(); });} 이행 상태에서 아래와 같이 then()메서드를 이용하면 결과값을 받을 수 있다. 12345678910function returnPromise() { return new Promise((resolve, reject) =&gt; { const data = 'my name is foo'; resolve(data); });}returnPromise().then((data) =&gt; { console.log(data); // my name is foo}); Rejected(실패)넘겨 받은 인자에서 reject를 함수로 실행하면 실패 상태가 된다. 실패 상태가 되면 실패 처리의 결과값을 catch()메서드를 통해 받을 수 있다. 1234567891011function returnPromise() { return new Promise((resolve, reject) =&gt; { reject(new Error('Request is failed')); });}returnPromise() .then() .catch((err) =&gt; { console.log(err); // Error: Request is failed }); 사용 방법기본 코드아래는 응답값에 따라 결과를 출력하는 예제이다. 12345678910111213141516171819202122function getData() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { const data = 'my-data'; // data 값이 있다면 data 값을 출력 // const data = ''; // data 값이 없다면 에러를 출력 if (data) { resolve(data); } reject(new Error('Request is failed')); }, 1000); });}getData() .then((data) =&gt; { console.log(data); // my-data }) .catch((err) =&gt; { console.log(err); // Error: Request is failed }); setTimeout()함수로 1초 뒤 data값을 받아오며, data값이 있을 경우 then()메서드를 호출하고, data값이 없을 경우 catch() 메서드를 호출한다. 프로미스 연결(Promise Chaining)프로미스의 특징으로 여러개의 프로미스를 연결하여 사용할 수 있다. then()메서드를 호출하면 새로운 프로미스 객체가 반환된다. 아래처럼 각 프로미스를 연결하여 사용할 수 있다. 1234567891011121314151617181920212223242526272829function getData() { return new Promise((resolve, reject) =&gt; { setTimeout((data) =&gt; { const data = 10; // data 값이 10일 경우 if (data) { resolve(data); } reject(new Error('Request is failed')); }, 1000); });}getData() .then((data) =&gt; { console.log(data); // 10 return data + 10; }) .then((data) =&gt; { console.log(data); // 20 return data + 10; }) .then((data) =&gt; { console.log(data); // 30 }) .catch((err) =&gt; { console.log(err); // Error: Request is failed }); setTimeout()함수에서 data값이 10으로 왔다고 가정해 본다. 첫번째 then()메서드의 data에 10을 더하여 리턴하고 두번째 then()에 더한 data를 인자로 넣어 호출한다. 이와 같은 방법으로 then()함수를 연결하여 사용할 수 있다. References [자바스크립트] 비동기 처리 2부 - Promise자바스크립트 Promise 쉽게 이해하기JavaScript 비동기 처리를 위한 promise 이해하기Promise프로미스","link":"/2020/06/05/javascript-promise/"},{"title":"[JavaScript] 자료형(참조 타입)","text":"이전 포스팅에서도 언급했지만 참조타입으로는 객체(Object), 배열(Array), 함수(Function)가 있다. 원시타입과 참조타입을 비교하는것에 초점을 두어 간단히 알아본다. 객체(Object)자바스크립트에서 객체는 단순하게 표현하면 속성명(Key), 값(value) 형태의 속성(property)을 저장하는 그릇이라고 생각하면 된다. 즉 여러 값을 표현하는 묶음을 만들때 사용된다. 간단한 객체를 만들어 보겠다. 1234var person = { name: '철수', age: '20'} 속성명(name, age)과 값(‘철수’, ‘20’)인 객체를 선언했다. 객체 선언 방식은 {}(중괄호)로 한다. 이 선언 방식은 객체 리터럴 방식이라고 하며, 리터럴이란 용어의 의미는 표기법이라고 생각하면 된다. 리터럴 방식은 간단한 표기법만으로도 객체룰 생성할 수 있는 자바스크립트의 강력한 문법이다. 객체의 프로퍼티에 접근하려면 마침표 표기법과 대괄호 표기법이 있다. 1console.log(person.name); // 철수 배열(Array)배열은 변수에 여러가지의 값을 한번에 담을 수 있는 그릇이라고 볼 수 있다. 위에 언급한 객체와 비슷해 보일 수 있지만 배열의 속성명은 각 프로퍼티의 인덱스 값이다. 선언방식은 [](대괄호)로 하고 객체와 마찬가지로 이는 배열 리터럴이다. 1var person = ['철수', '20']; 객체와는 다르게 배열의 속성명은 인덱스 값이라고 했다. 그러므로 person의 첫번째 값인 ‘철수’의 속성명(Key)은 배열의 첫번째 인덱스인 0이고, 두번째 값(value)인 ‘20’의 속성명은 1이 되는 것이다. 배열의 프로퍼티에 접근하려면 대괄포 표기법을 이용하면 된다. 12console.log(person[0]); // 철수 console.log(person[1]); // 20 함수(Function)함수는 특정 기능을 하는 구문(알고리즘, 로직)을 독립된 부품으로 만들어 재사용하고자 할때 사용하는 문법이다. 함수를 선언할때는 function키워드를 사용하며 구조는 아래에서 확인할 수 있다. 1234function 함수이름(파라미터) { // 알고리즘 return 값 // 리턴 값} 객체(참조)타입이 무엇이 있나 간단히 봤다. 원시타입과 객체(참조)타입의 차이점을 알아보도록 하자. 원시 타입과 참조 타입의 차이자바스크립트에서는 원시타입인 숫자, 문자열, 논리형, 널, 언디파인드 다섯가지를 제외한 모든 값은 객체(참조)타입 이다. 참조 타입이라고 불리는 이유는 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문이다. 아래 예제를 살펴 보자. 원시타입은 값 자체를 복사한다.12345var num1 = 10, num2 = num1;console.log(num2); // 10 num1 = 20;console.log(num2); // 10 변수 num1에다가 10을 대입하고 num1를 num2에 대입했다. 변수에 할당된 값 자체를 복사하였기 때문에 num2의 값은 10이다. num2에 20을 대입해도 num2의 값은 변하지 않는다. num2에 직접적으로 값을 대입하지 않았기 때문이다. 아래 참조타입을 보자. 참조타입은 참조(주소)값을 복사한다.1234567var obj1 = { val: 10}var obj2 = obj1;console.log(obj2.val); // 10obj1.val = 20;console.log(obj2.val); // 20 우선 obj1에 객체 리터널을 선언하고, val 프로퍼티에 10을 담았다. 그리고 obj2에 obj1을 할당했다. obj2의 val프로퍼티의 값은 10이 출력된다. 여기서 obj1의 val에 20을 담았다. obj2의 val값을 건들지도 않았는데 obj1 처럼 val값이 20으로 봐뀌어있다. 어떻게 된 것일까? 값 자체가 복사되는 원시값과는 달리 참조타입은 참조(객체를 가르키는 참조값 혹은 메모리 주소)만 복사되고 실제 값은 복사되지 않는다. 즉 obj1과 obj2는 실제 데이터를 가지고 있는 객체의 참조(주소)값만 가지고 있는 것이다.","link":"/2017/05/05/javascript-reference-data-type/"},{"title":"[JavaScript] 정규표현식","text":"정의정규표현식은 문자열에 포함된 문자 조합을 찾기 위해 사용되거나 그 문자열을 다른 문자열로 치환해 주는 패턴이다. 예를 들면 회원가입 화면에서 사용자로 부터 입력받는 전화번호가 유효한지 체크할 필요가 있을 때 정규표현식을 사용하면 간단하게 처리할 수 있다. 1234var tel = '0101234567팔';var regExp = /^[0-9]+$/;console.log(regExp.test(tel)); // false 정규표현식은 하나의 언어라고 할 만큼 모든것을 다루기에는 너무 방대하다. 정규표현식 패턴은 zvon의 정규표현식 tutorials에서 확인할 수 있다. 정규표현식은 리터럴 표기법과 생성자 함수로 생성할 수 있다. 리터럴 방식1var re = /ab + c/; 리터럴 방식은 스크립트가 불어와질 때 컴파일 된다. 정규직이 상수라면 이렇게 사용하는 것이 성능을 향상시킨다. 생성자 함수 방식1var re = new RegExp(&quot;ab + c&quot;); 생성자 함수 방식은 정규식이 실행 시점에 컴파일 된다. 정규식의 패턴이 변경될 수 있는 경우, 혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는 경우에 생성자 함수 방식을 쓴다. 정규 표현식 리터럴은 아래와 같이 표현한다. 1var re = /pa/i; / 는 시작, 종료기호 이며, pa는 패턴, i는 프래그 이다. 정규표현식 메서드자바스크립트에서 정규표현식 패턴들은 RegExp의 exec 메서드와 test 메서드, 그리고 String의 match메서드, replace메서드, search메서드, split 메서드와 함께 쓰인다. 메서드 설명 RegExp.exec() 어떤 문자열에서 정규표현식과 일치하는 문자열 검색을 수행한다. 결과로 배열을 리턴하거나 null을 반환한다. RegExp.test() 대상 문자열 속에 일치하는 문자열이 포함되어 있는지 검사하고 true 또는 false를 반환한다. String.match() 문자열이 정규식과 매치되는 부분을 검색한다. String.replace() 대응되는 문자열을 찾아 다른 문자열로 치환하는 String 메서드이다. String.search() 대응되는 문자열이 있는지 검사하는 String 메서드 이다. 대응된 부분의 인덱스를 반환한다. 대응되는 문자열을 찾지 못했다면 -1을 반환한다. String.split() 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 String 메서드이다. 123456789101112var str = 'this is a pen.';var regexr = /is/ig;// RegExp 객체의 메서드console.log(regexr.exec(str)); // [&quot;is&quot;, index: 2, input: &quot;this is a pen.&quot;, groups: undefined]console.log(regexr.test(str)); // true// String 객체의 메서드console.log(str.match(regexr)); // (2) [&quot;is&quot;, &quot;is&quot;]console.log(str.replace(regexr, 'is')); // this is a pen.console.log(str.search(regexr)); // 2console.log(str.split(regexr)); // (3) [&quot;th&quot;, &quot; &quot;, &quot; a pen.&quot;] References 정규표현식5.26 RegExp 정규표현식정규 표현식","link":"/2018/03/02/javascript-regexp/"},{"title":"[JavaScript] 스코프(Scope)","text":"자바스크립트에서의 스코프란 코드가 실행되는 컨텍스트(유효범위)이며 전역 스코프, 지역 스코프, eval 스코프로 나눌 수 있다. 전역 스코프 함수나 객체의 밖에서 선언되었다면 전역 스코프로 정의된다. 모든 곳에서 전역 스코프에 있는 변수를 사용할 수 있다. 12345678// 전역 스코프var foo = 1;console.log(foo); // 1function func() { // foo가 전역에서 선언되었기 때문에 함수 내부에서도 foo값을 사용할 수 있다. console.log(foo); // 1} 지역 스코프 함수나 객체의 안에서 선언되었다면 지역 스코프로 정의된다. 해당 함수나 객체에서만 지역 스코프를 사용할 수 있다. 함수 지역 스코프123456789function func() { // 지역 스코프 var foo = 1; console.log(foo); // 1}// foo가 func 함수 내부에서 선언되었기 때문에 함수 외부에서 사용을 할 수 없다.console.log(foo); // Uncaught ReferenceError: foo is not defined 객체 지역 스코프12345var obj = { foo: 1};console.log(obj.boo); // 1console.log(boo); // Uncaught ReferenceError: foo is not defined eval 스코프 eval의 경우 eval()을 사용해 매개변수를 사용하면 이를 사용했을 경우에만 해당 스코프에 담긴 값을 불러온다. 각각 선언할때 고유한 스코프를 가지는 것이 특징이다.","link":"/2017/12/02/javascript-scope/"},{"title":"[JavaScript] 얕은 복사, 깊은 복사","text":"깂은 복사와 얕은 복사에 대해 알아보겠다. 이 글의 초반 내용은 이전 포스팅의 (원시 타입과 참조 타입의 차이)과 맥락이 비슷하며, 위 포스팅은 원시 타입과 참조 타입의 차이점이라면 아래는 참조 타입의 깊은 복사하는 방법에 대해 알아보도록 하겠다. 얕은 복사(shallow copy)얖은 복사는 참조(주소)값의 복사를 나타낸다. 1234567const obj = { vaule: 1 }const newObj = obj;newObj.vaule = 2;console.log(obj.vaule); // 2console.log(obj === newObj); // true obj 객체를 새로운 newObj 객체에 할당하였으며 이를 참조 할당이라 부른다. 복사 후 newObj 객체의 value값을 변경하였더니 기존의 obj.value값도 같이 변경된 것을 알 수 있다. 두 객체를 비교해도 true로 나온다. 이렇게 자바스크립트의 참조 타입은 얕은 복사가 된다고 볼 수 있으며, 이는 데이터가 그대로 생성되는 것이 아닌 해당 데이터의 참조 값(메모리 주소)를 전달하여 결국 한 데이터를 공유하는 것이다. 깊은 복사(deep copy)깊은 복사는 값 자체의 복사를 나타낸다. 12345678let a = 1;let b = a;b = 2;console.log(a); // 1console.log(b); // 2console.log(a === b); // false 변수 a를 새로운 b에 할당하였고 b 값을 변경하여도 기존의 a의 값은 변경되지 않는다. 두 값을 비교하면 false가 출력되며 서로의 값은 단독으로 존재하다는 것을 알 수 있다. 이렇게 자바스크립트의 원시 타입은 깊은 복사가 되며, 이는 독립적인 메모리에 값 자체를 할당하여 생성하는 것이라 볼 수 있다. 객체의 깊은 복사객체를 그대로 복사하여 사용할 경우 기존 객체의 원본 데이터가 더럽혀 질 수 있기 때문에 객체의 깊은 복사는 매우 중요하다. 객체를 깊이 복사하는 방법에 대해 몇가지 알아보자. Object.assign()Object.assign() 메서드를 활용하는 방법이다. 문법Object.assign(생성할 객체, 복사할 객체) 메서드의 첫번째 인수로 빈 객체를 넣어주며, 두번째 인수로 할당할 객체를 넣으면 된다. 1234567const obj = { a: 1 };const newObj = Object.assign({}, obj);newObj.a = 2;console.log(obj); // { a: 1 }console.log(obj === newObj); // false 새로운 newObj 객체를 Object.assign() 메서드를 사용하여 생성하였으며, newObj.a 값을 변경하여도 기존의 obj는 변하지 않았다. 서로의 객체를 비교해도 false로 뜨며 서로 참조값이 다르다는 것을 알 수 있다. Object.assign()는 2차원 객체는 깊은 복사가이루어지지 않는다하지만 Object.assign()를 활용한 복사는 완벽한 깊은 복사가 아니다. 123456const obj = { a: 1, b: { c: 2, },}; 위처럼 obj 객체의 b 프로퍼티의 값으로 { c: 2 } 객체를 가진 2차원 객체일 경우는 경우는 어떨까? 12345678910111213const obj = { a: 1, b: { c: 2, },};const newObj = Object.assign({}, obj);newObj.b.c = 3;console.log(obj); // { a: 1, b: { c: 3 } }console.log(obj.b.c === newObj.b.c); // true 2차원 객체를 newObj에 복사하고, newObj.b.c의 값을 변경하였다. 기존 obj 객체를 출력해보면 newObj.b.c의 값도 3으로 변경되었다. 복사된 하위 객체 { c: 2 }도 결국 객체이기 때문에 얕은 복사가 이루어진 것이다. 이는 Object.assign() 메서드의 한계이며, 전개연산자(Spread Operator) 를 이용한 객체의 복사에도 같은 문제가 있다. 전개연산자(Spread Operator)1234567const obj = { a: 1 };const newObj = Object.assign({}, obj);newObj.a = 2;console.log(obj); // { a: 1 }console.log(obj === newObj); // false 전개연산자를 활용해도 객체의 깊은 복사가 가능하다. 12345678910111213const obj = { a: 1, b: { c: 2, },};const newObj = { ...obj };newObj.b.c = 3;console.log(obj); // { a: 1, b: { c: 3 } }console.log(obj.b.c === newObj.b.c); // true 하지만 Object.assign()와 마찬가지로 2차원 객체는 얕은 복사가 되는 것을 확인할 수 있다. JSON 객체 메서드를 이용객체의 깊은 복사를 위해 JSON 객체의 stringify(), parse() 메서드를 사용할 수 있다. 문법JSON.stringify() 메서드는 인수로 객체를 받으며 받은 객체는 문자열로 치환되며, JSON.parse() 메서드는 문자열을 인수로 받으며, 받은 문자열을 객체로 치환한다. 12345678910111213const obj = { a: 1, b: { c: 2, },};const newObj = JSON.parse(JSON.stringify(obj));newObj.b.c = 3;console.log(obj); // { a: 1, b: { c: 2 } }console.log(obj.b.c === newObj.b.c); // false obj 객체를 JSON.stringify() 메서드를 이용하여 문자열로 변환한 뒤 다시 JSON.parse() 메서드로 객체로 변환하였다. 문자열로 변환한 뒤 다시 객체로 변환하였기에 2차원 객체에 대한 참조가 사라졌다. 하지만 이 방법도 2가지 문제가 있는데, 다른 방법에 비해 성능이 느린 점과 JSON.stringify() 메서드는 함수를 만났을 때 undefined로 처리한다는 점이다. 12345678910111213const obj = { a: 1, b: { c: 2, }, func: function() { return this.a; }};const newObj = JSON.parse(JSON.stringify(obj));console.log(newObj.func); // undefined 복사된 newObj는 func가 없고 undefined로 출력되고 있다. 커스텀 재귀 함수이 문제를 원칙적으로 해결하려면 직접 깊은 복사를 구현하는 커스텀 재귀 함수를 사용하는 것이다. 123456789101112131415161718192021222324252627function deepCopy(obj) { if (obj === null || typeof obj !== &quot;object&quot;) { return obj; } let copy = {}; for (let key in obj) { copy[key] = deepCopy(obj[key]); } return copy;}const obj = { a: 1, b: { c: 2, }, func: function () { return this.a; },};const newObj = deepCopy(obj);newObj.b.c = 3;console.log(obj); // { a: 1, b: { c: 2 }, func: [Function: func] }console.log(obj.b.c === newObj.b.c); // false deepCopy 함수의 인수로 obj 객체를 넣었다. 인수값이 객체가 아닌 경우는 그냥 반환하며, 객체인 경우 객체의 값 만큼 루프를 돌며 재귀를 호출하여 복사된 값을 반환한다. 복사된 newObj 객체를 보면 2차원 객체의 값도 깊은 복사가 이루어 졌으며, 객체의 함수도 제대로 표현되는 것을 확인할 수 있다. 하지만 이미 객체의 깊은 복사를 위한 오픈 소스가 존재하며 lodash 모듈의 cloneDeep()을 이용하면 된다. lodash 모듈의 cloneDeep()lodash 모듈의 cloneDeep() 메서드를 이용하여 객체의 깊은 복사가 가능하다. 해당 모듈을 설치해 준 뒤 아래 코드를 실행시켜 보자. 1&amp; npm i lodash 1234567891011121314151617const lodash = require(&quot;lodash&quot;);const obj = { a: 1, b: { c: 2, }, func: function () { return this.a; },};const newObj = lodash.cloneDeep(obj);newObj.b.c = 3;console.log(obj); // { a: 1, b: { c: 2 }, func: [Function: func] }console.log(obj.b.c === newObj.b.c); // false 간단히 객체의 깊은 복사를 구현할 수 있다. 실제로 웹 개발을 하다보면 lodash 모듈은 흔히 사용되며, 가장 손쉽게 객체의 깊은 복사를 해결하는 방법이라 할 수 있다. References 자바스크립트 객체 복사하기Javascript 깊은 복사의 함정[Java Script] 얕은 복사와 깊은 복사JavaScript로 Deep Copy 하는 여러 방법Javascript:Shallow and Deep Copy :: 마이구미","link":"/2020/12/15/javascript-shallow-copy-deep-copy/"},{"title":"[JavaScript] switch 조건문","text":"switch키워드 오른쪽 ()안의 값과 case키워드 오른쪽의 값을 비교하여 true일시 콜론 오른쪽 구문을 실행하게 된다. 12345678var a = 0;switch (1) { case 1: console.log('ok'); break; case 2: console.log('no'); break;}// ok 조건을 만족시 구문을 실행하고, break키워드를 만나면 로직을 빠져나가게 된다. break키워드가 없을 경우 로직을 벗어나지 않고 계속 아래 조건을 읽어내려간다. 123456switch (1) { case 1: console.log('ok'); case 1: console.log('no');}// ok// no","link":"/2018/01/01/javascript-switch/"},{"title":"[JavaScript] 자바스크립트 싱글톤 패턴","text":"전체 시스템에서 하나의 인스턴스만 존재하도록 보장하는 객체 생성패턴을 의미한다. 대표적으로 $를 활용해서 DOM을 조작하고 이벤트도 다루는 jQuery가 있으며, 객체 리터럴도 싱글톤 패턴이라고 할수 있다.(자바스크립트에서 객체 리터럴로 생성한 객체는 다른 객체와 같을 수 없다. 객체 내부의 내용이 같더라도 참조하는 객체가 다르기 때문이다.) 객체 리터럴은 한계가 있는데 비공개 프로퍼티 및 함수를 선언할 수 없다. 1234567var obj = { name: 'myName', get: function() { return this.name; }}console.log(obj.get()); // myName 비공개 프로퍼티 및 함수를 정의하려면 클로저(closure)를 활용해야 한다. 즉 제대로 된 싱글톤 패턴은 객체 리터럴 + 클로저의 조합이 필요하다고 할 수 있다. 아래 코드를 확인해보면 1234567891011121314151617181920212223242526272829303132333435363738394041424344var singleton = (function() { // 비공개 프로퍼티 정의 var instance; // 비공개 메서드 정의 function init() { // singleton 인스턴스 정의 return { // 공개 프로퍼티 정의 prop: 'value', // 공개 메서드 정의 method: function() { return 'hello' } }; } // 공개 메서드인 getInstance를 정의한 객체, 비공개 프로퍼티 및 메서드에 접근 가능(클로저) return { getInstance: function() { // 인스턴스가 선언이 안되있는경우 인스턴스 생성 if (!instance) { instance = init(); } // 인스턴스가 선언이 되있는 경우 인스턴스 반환 return instance; } }})()var singleton1 = singleton.getInstance();console.log(singleton1.method());var singleton2 = singleton.getInstance();console.log(singleton1 === singleton2); // true 위 코드는 비공개 메서드인 init()의 return문에서 객체 리터럴로 정의되는 인스턴스가 싱글톤 객체이며, 전체 시스템에서 하나만 존재하게 된다. 순서대로 보면 익명함수의 return문에는 싱글톤 객체를 구하는 공개 메서드(getInstance)를 포함한 객체를 반환하며, getInstance메서드는 instance값을 확인해 인스턴스가 선언이 안되있는 경우 비공개 메서드인 init를 호출하여 singleton인스턴스를 생성하여 instance에 할당하게 된다. 이렇게 일반적으로 싱글톤 패턴에서는 이미 객체가 생성되었는지 여부를 알려주는 instance와 같은 내부 변수가 필요하다. 그리고 싱글톤 패턴에서는 내부 변수에 접근할 수 있는 객체를 반환하는 클로저를 이용해야 한다. 정리를 하면 내부의 getInstance메서드에서 비공개 프로퍼티인 instance에 접근할 수 있다는 것과, getInstance메서드의 호출이 끝나더라도 instance의 값은 계속 유지되는 특성(클로저)를 이용해 prop, method()이 포함된 객체를 유일하게 생성하게 된다. 그래서 singleton.getInstance()를 몇번이나 호출하더라도 얻는 객체는 모두 동일한 싱글톤 객체를 가리키게 된다. References 싱글톤(singleton) 패턴","link":"/2020/02/04/javascript-singleton-pattern/"},{"title":"[JavaScript] 문자열 자르기","text":"split()특정 문자열을 기준으로 잘라 배열로 반환한다. 123var str = '가, 나, 다, 라, 마';console.log(str.split(','));// (5) [&quot;가&quot;, &quot; 나&quot;, &quot; 다&quot;, &quot; 라&quot;, &quot; 마&quot;] substring(시작인덱스, 종료인덱스)시작인덱스를 기준으로 종료인덱스 까지 자른다. 123var str = '가나다라마';console.log(str.substring(1, 4));// 나다라 substr(시작인덱스, 길이)시작인덱스를 기준으로 문자열 길이로 자른다. 123var str = '가나다라마';console.log(str.substr(2, 2));// 다라","link":"/2017/12/04/javascript-truncate-string/"},{"title":"[JavaScript] 자바스크립트 This","text":"this는 함수가 호출되면 함수 내부로 암묵적으로 전달 되며, 함수를 호출한 방식에 의해 this에 바인딩할 객체가 동적으로 결정된다. 다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다. this가 만들어지는 경우 일반 함수에서의 this 중첩 함수에서의 this 이벤트 리스너에서의 this 메서드에서의 this 메서드 내부의 중첩 함수의 this 일반 함수에서의 this1234function func() { console.log(this); // window}func(); 일반 함수 내부에서는 this는 전역객체인 window가 된다. 중첩 함수에서의 this1234567function func() { function func2() { console.log(this); // window } func2();}func(); 일반 중첩 함수에서의 this 도 window 가 된다. 이벤트 리스너에서의 this123document.addEventListener('click', function() { console.log(this); // #document}); 이벤트 리스너에서의 this는 이벤트를 발생시킨 객체가 된다. 메서드에서의 this123456var obj = { func: function() { console.log(this); // {func: ƒ}; }}obj.func(); 메서드에서의 this는 메서드를 호출한 객체가 된다. 메서드 내부의 중첩 함수의 this123456789var obj = { func: function() { function func2() { console.log(this); // window } func2(); }}obj.func(); 메서드의 this와는 다르게 window를 가리킨다. 메서드의 내부함수는 결국 중첩함수이기 때문에 window를 바라본다. 이를 방지하기 위해선 아래 방법으로 해결할 수 있다. 12345678910var obj = { func: function() { var that = this; function func2() { console.log(that); // {func: ƒ} } func2(); }}obj.func(); 메서드를 포함한 객체를 참조하도록 부모함수의 this를 내부함수가 접근 가능한 변수에 저장하면 된다. 보통 관례상 this 값을 저장하는 변수의 이름을 that 이라고 선언한다. 자바스크립트는 위와 같은 바인딩의 한계를 극복하려고 this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다. 제이쿼리 등 자바스크립트 라이버리들의 경우 bind 메서드를 통해, 사용자가 원하는 객체를 this에 바인딩 하는 기능을 제공하고 있다.","link":"/2018/11/01/javascript-this/"},{"title":"[JavaScript] try...catch를 이용한 에러 핸들링","text":"자바스크립트에서 에러가 발생하면 코드는 멈추게 되고, 콘솔에 에러가 출력된다. 하지만 try...catch 문법을 사용하면 스크립트가 죽는 것을 방지하고, 에러 상황을 잡아 예외처리를 할 수 있게 한다. 기본적인 형태는 두 블록으로 구성되며 예시 코드는 아래와 같다. 기본 형태123456789try { // 이 구간에서 에러가 발생하면 catch로 이동} catch (err) { // 에러 핸들링} 먼저 try 블록의 코드가 실행된다. try 블록 안에 에러가 없다면 catch 블록은 건너 뛴다. try 블록 안에서 에러 코드를 만나면 try 블록의 실행이 중단되고 catch 블록의 코드가 실행된다. err 객체에는 에러에 대한 정보가 있다. 실제 작동 코드 살펴보자. 1234567891011121314try { console.log(&quot;아직 에러 없음&quot;); a; // 에러 시작 console.log(&quot;이곳은 실행 안됨&quot;);} catch (err) { console.log(err); // a is not defined console.log(&quot;에러가 나도 이곳의 코드는 실행됨&quot;);} try 블록에서 에러가 나면 아래의 console.log()는 실행이 안되며 바로 catch 블록으로 넘어간다. err 객체가 콘솔창에 어떤 에러인지 표시해 주며, 에러가 발생해도 catch 블록의 코드는 계속 실행되는 것을 확인할 수 있다. 이 부분에 에러 예외 처리를 작성해 주면 된다. try...catch는 런타임 에러에만 작동한다try...catch는 실행이 가능한 코드에만 동작하며, 중괄호가 들어가는 등 자바스크립트 엔진이 해석할 수 없는 문법적 오류(SyntaxError)같은 경우는 작동하지 않는다. 1234567891011try { {{ // SyntaxError console.log(&quot;자바스크립트 엔진은 이 코드를 이해할 수 없어 실행 자체가 안됨&quot;);} catch (err) { console.log(&quot;여기도 실행 안됨&quot;);} try...catch는 동기적으로 동작한다try...catch는 setTimeout와 같이 비동기적으로 실행되는 코드의 에러는 잡아낼 수 없다. 12345678910111213try { setTimeout(() =&gt; { a; // 에러가 발생하지만 catch가 잡아낼 수 없음 }, 1000);} catch (err) { console.log(&quot;try 블록의 에러를 잡아낼 수 없음&quot;);} 1초뒤 setTimeout의 익명함수가 실행되고 에러가 발생하지만 이미 자바스크립트 엔진은 try...catch 블록을 떠났기 때문에 오류를 잡아낼 수 없다. 비동기로 실행되는 코드의 에러를 잡으려면 반드시 해당 함수 안에서 try...catch 구문을 사용해야 한다. 12345678910111213setTimeout(() =&gt; { try { a; // 에러가 발생하지만 catch가 잡아낼 수 있음 } catch (err) { console.log(&quot;try 블록의 에러를 잡아냄&quot;); } }, 1000); 에러 객체에러가 발생하면 자바스크립트는 에러 내용이 담긴 객체를 생성하고 catch 블록의 인수로 전달한다. 1234567891011try { a; // 에러 시작} catch (err) { console.log(err); // ReferenceError: a is not defined console.log(err.name); // ReferenceError console.log(err.message); // a is not defined } name 프로퍼티는 에러의 이름을 나타내고 message는 에러에 대한 상세 내용을 가지고 있다. 직접 에러를 생성해 던지기throw 연산자throw 연산자는 예외를 던질 수 있으며, catch 블록에 전달된다. throw 연산자는 함수의 실행을 중단한다는 표현과 같다. 1234567891011try { throw &quot;예외 처리를 던짐&quot;; console.log(&quot;여긴 실행 안됨&quot;);} catch (err) { console.log(err); // 예외 처리를 던짐 } 위 코드에서 throw는 예외를 던지고 있으며, throw 아래의 로직은 실행이 안된다. throw 연산자자와 에러 객체 생성자를 이용하여 예외 처리를 해보자. 에러 객체 생성자12345const error = new Error(&quot;에러 발생&quot;);const syntaxError = new SyntaxError(&quot;문법 에러 발생&quot;);console.log(error); // Error: 에러 발생console.log(syntaxError); // SyntaxError: 문법 에러 발생 자바스크립트는 Error, SyntaxError, ReferenceError, TypeError 등 표준 애러 객체 생성자를 지원하며, 이 생성자들을 이용해 에러 객체를 만들 수 있다. 생성한 에러 던지기123456789101112131415161718const person = { name: &quot;foo&quot;, age: 20,};try { if (!person.gender) { throw new SyntaxError(&quot;성별이 없음&quot;); } console.log(&quot;이곳은 실행이 안됨&quot;); // person.gender 값이 없기 때문에 실행이 안됨} catch (err) { console.log(err); // Error: 성별이 없음 } 위 코드의 try 블록에서는 성별 값이 있는지 체크하고 있는데, 체크 대상인 person 객체에는 이름과 나이만 있고 성별이 없다. 때문에 성별이 없을 때 직접 생성한 에러를 던지고 있고, catch 블록에서 에러를 받아 출력하고 있다. 참고로 위 에러는 직접 생성한 에러이기 때문에 실제 SyntaxError 에러는 아니다. 에러 다시 던지기try...catch는 애초에 try 블록에서 발생한 모든 에러를 잡는 목적으로 만들어졌다. 에러의 종류와 상관 없이 모든 에러를 잡는것은 디버깅에 어려움을 주기 때문에 예상치 못한 에러를 다시 던져서 에러의 종류에 따라 대응을 해줘야 한다. 123456789101112131415161718192021222324252627const person = { name: &quot;foo&quot;, age: 20,};const getError = () =&gt; { try { if (!person.gender) { throw new SyntaxError(&quot;성별이 없음&quot;); // throw new ReferenceError(&quot;성별이 없음&quot;); } } catch (err) { if (err instanceof SyntaxError) { console.log(&quot;이 에러는 &quot; + err); // SyntaxError일 경우 } else { throw err; // SyntaxError가 아닐 경우 밖으로 다시 던짐 } }};try { getError();} catch (err) { if (err instanceof ReferenceError) { console.log(&quot;이 에러는 &quot; + err); // ReferenceError일 경우 }} getError()가 실행되면서 SyntaxError를 잡아내고 있으며, 만약 SyntaxError 에러가 아닐 경우는 다시 에러를 함수 밖으로 던지며, 함수 외부에서 에러를 다시 잡고 있다. 함수 밖에서는 ReferenceError일 경우를 잡아내고 있다. SyntaxError일 경우는 함수 내부에서 에러를 잡고 ReferenceError일 경우는 함수 외부에서 잡는다고 보면 된다. finallyfinally절은 에러의 유무와 상관없이 마지막으로 사용되는 블록이며, 마지막 제어가 필요할 때 사용하면 된다. 12345678910111213try { throw new Error(&quot;에러 발생&quot;);} catch (err) { console.log(err); // 에러 발생} finally { console.log(&quot;항상 실행&quot;); // 항상 실행} References ‘try..catch’와 에러 핸들링에러 처리를 어떻게 하면 좋을까? - 1예외 ( throw,[try/catch/finally])","link":"/2020/12/01/javascript-try-catch/"},{"title":"[JavaScript] 자바스크립트 변수","text":"정의프로그래밍에서 데이터를 담는 공간이다. 1var 변수이름 = 저장데이터; 선언 방법은 var 키워드를 사용하며, =는 대입 연산자로서 우측에 있는 값을 왼쪽에 있는 변수에 담는 연산자다. ;(세미콜론)은 문장의 끝을 알린다. 오류를 방지하기 위해 문장이 끝나면 꼭 선언해 주도록 하자. 참고로 함수 선언식에서는 마지막에 세미콜론을 붙이지 않는데 이건 하나의 관습이고, 코드 작성시 권장되는 방식이다. 그리고 자바스크립트에서는 세미콜론 사용을 강제하지는 않는다. 그 이유는 자바스크립트 인터프리터가 자동으로 세미콜론을 삽입시켜 주기 때문이다. 하지만 세미콜론을 꼭 선언해 주는 습관을 가지도록 해야한다. 신경을 안쓴다면 코드를 압축하거나 디버깅중에 심각한 오류를 가지게 될수 있기 때문이다. 종류변수는 크게 네가지로 나뉠수 있으며 종류는 아래와 같다. 전역변수(Global Variable): 전역에서 사용되는 변수로서 어디서든 접근이 가능하다. 지역변수(Local Variable): 특정 지역에서 사용되는 변수로서 보통 함수 내부에 만들어 지는 변수 인자 &amp; 매개변수(Parameter): 함수 외부에서 데이터를 받을 때 사용되는 변수 인수(Arguments)와 인자 &amp; 매개변수(Parameter)에 대해 많이 헷갈려 했었는데, 인수는 함수를 호출할때 대입하는 값을 의미하고 인자 &amp; 매개변수는 함수 외부에서 전달받은 값을 의미한다고 볼 수 있다. 1234function func(foo) { return foo; // foo = 인자 &amp; 매개변수}func(&quot;value&quot;) // &quot;value&quot; = 인수 속성(Property): 객체의 속성값으로 쓰이는 변수이다. 참고로 전역 객체는 window 객체이다. 전역변수를 선언한다면 자동으로 window 객체의 프로퍼티가 된다고 생각하면 된다. 12345var obj = { name: &quot;foo&quot;};// name = 속성(프로퍼티, 아니면 키)// foo = 속성의 값(프로퍼티 값 아니면 키값) 명명 규칙변수를 만들때는 주의사항이 네가지 있다. 변수명은 대소문자를 구분해야 한다. 변수명은 소문자로 시작하고, 관례상 카멜기법을 사용한다. 여기서 카멜기법이란 문자모양이 낙타와 비슷하다고 해서 지어졌다. 네이밍 기법은 3가지로 분류할수 있다. 카멜기법(myName) 스네이크 기법(my_name) 파스칼 기법(my-name) 한번 저장하고 변하지 않는 상수값은 모두 대문자로 작성한다. 자바 언어 같은 경우 상수 값을 만드는 방법이 지원되지만 자바스크립트는 없다. 그래서 관례상 대문자로 작성하는 것이다. 예가 몇가지 있는데 슬라이드 플러그인에서 사용자가 정의하는 변수나, 그누보드의 config.php 에 나와있는 상수 선언 등이 있다. 키워드(예약어)를 사용하면 안된다.(예: var, function, break 등등 아주 많음) 예약어로 변수를 선언하면 브라우저에서 오류 메세지가 출력되므로 많은 예약어를 굳이 따로 외울 필요는 없다.","link":"/2017/05/02/javascript-variable/"},{"title":"[Linux] APM(Apache, Mysql, PHP)","text":"웹서버 구축을 하기위해 APM(Apache, Mysql, PHP) 3개의 패키지가 설치되어야 한다. Apache아파치는 Apache Software Foundation에서 개발한 HTTP 웹서버로서 프리 소프트웨어로 누구든지 수정, 재배포 등이 가능하고 오픈소스 프로그램이다. Linux, Unix, Windows, FreeBSD, Mac OS X 등과 같은 거의 모든 운영 체제에서 설치 및 사용이 가능하다. 웹서버는 크게 아파치/톰캣 과 IIS 로 나뉘게 된다. 아파치/톰캣은 프리소프트웨어에 오픈소스이고 IIS 는 MS사에서 제공하는 웹서버로서 MS사로부터 양질의 지원을 받을 수 있다. MysqlMySQL은 DBMS의 종류중 하나로서 전세계적으로 가장 널리 사용되고 있는 오픈 소스 데이터베이스(DataBase)이다. 제작사는 MySQL AB이다. PHPPHP는 웹서버쪽에서 실행 되는 스크립트 언어로서 주로 HTML 코드를 프로그래밍적으로 생성한다. 장점으로는 빠른 생산성, 저렴한 유지비용, 거의 모든 운영 체제에 구현이 가능하다.","link":"/2019/10/21/linux-apm/"},{"title":"[JavaScript] while 반복문","text":"while문은 조건을 검사하여 true일경우 계속 구문을 실행시키는 반복문이다. 123while (조건) { 구문} 12345678var i = 0;while (i &lt; 3) { console.log(i); i++;}// 0// 1// 2 do-while은 whild문과 비슷하지만 처음은 조건과 상관없이 구문을 실행하고 이후에 조건을 검사하여 true일때 구문을 실행한다. 123do { 구문} while (조건); 처음 구문을 실행하여 0이 출력되고, i는 3이 아니므로 로직이 실행이 안된다. 12345var i = 0;do { console.log(i);} while (i == 3);// 0","link":"/2018/01/16/javascript-while/"},{"title":"[Linux] 리눅스 명령어","text":"체크리눅스 버전체크 1# uname -a CentOS 버전체크 1# cat /etc/redhat-release 하드용량체크 1# df -h 디렉토리현재 디렉토리 확인하기 1# pwd 현재 디렉토리 목록 보기 1# ls 현재 디렉토리 목록 자세히 보기 1# ll 파일/폴더파일 생성 123# touch [파일명]# cat [파일명]# vi [파일명] 폴더 생성 1# mkdir [폴더명] vi 편집기 실행 1# vi [파일명] vi 편집기 저장 후 끝내기(ESC 누른뒤) 1# wq vi 편집기 저장하지 않고 끝내기(ESC 누른뒤) 1# q! 파일 삭제 1# rm [파일명] 파일 삭제 확인을 거치지 않고 삭제 1# rm -f [파일명] 해당 폴더 삭제 1# rm -r [폴더명] 폴더 삭제 확인을 거치지 않고 삭제 1# rm -rf [폴더명] 압축tar 압축하기 1234# tar -cvf [파일명.tar] [폴더명]ex) foo라는 폴더를 boo.tar로 압축하고자 한다면# tar -cvf boo.tar foo tar 압축 풀기 1234# tar -xvf [파일명.tar]ex) foo.tar라는 tar파일 압축을 풀고자 한다면# tar -xvf foo.tar tar.gz 압축하기 1234# tar -zcvf [파일명.tar.gz] [폴더명]ex) foo라는 폴더를 boo.tar.gz로 압축하고자 한다면# tar -zcvf boo.tar.gz foo tar.gz 압축 풀기 1234# tar -zxvf [파일명.tar.gz]ex) aaa.tar.gz라는 tar.gz파일 압축을 풀고자 한다면# tar -zxvf aaa.tar.gz MySQLMySQL 설치 유무 1# rpm -qa | grep mysql MySQL 설치 1# yum install mariadb MySQL 설치 경로 확인 1# find / -name mysql","link":"/2019/10/10/linux-command/"},{"title":"[Linux] 리눅스 MySQL 시작, 정지, 재시작, 상태확인","text":"리눅스 MySQL 시작, 정지, 재시작, 상태확인 작업 우분투 명령어 CentOS6 명령어 CentOS7 명령어 시작 # service mysql start # service mysqld start # systemctl start mysqld 정지 # service mysql stop # service mysqld stop # systemctl stop mysqld 재시작 # service mysql restart # service mysqld restart # systemctl restart mysqld 상태확인 # service mysql status # service mysqld status # systemctl status mysqld References 리눅스 MySQL 시작, 정지, 재시작, 상태확인","link":"/2019/12/12/linux-mysql-status-command/"},{"title":"[Linux] 리눅스 서버 세팅","text":"목적 가상 호스팅을 설정하여 자신의 웹서버로 이용 IWINV 서비스를 이용하여 리눅스 서버를 구매 리눅스 운영체제의 특징 리누스 토발즈가 개발한 컴퓨터 운영체제의 한 종류이며 커널 자체를 의미 자유 라이센스와 오픈 소스 개발의 가장 유명한 표본 다중 스레드를 지원하는 네트워크 운영 체제(NOS)로, 여러 사람이 하나의 리눅스 시스템에 접속하여 다수의 프로그램을 동시에 실행할 수 있다. MS에서 개발된 MSSQL을 제외한 대부분의 DB를 지원 IWINV 서버 신청IWINV 서버 신청 가이드를 참조 https://www.iwinv.kr로 접속해 회원가입 관리 콘솔로 들어가 서버 선택 가상서버와 물리서버로 상품이 있으며 가상서버는 [Real Core 서버], [vCore 서버] 나누어 짐 논리적인 머신이냐, 물리적인 머신이냐에 따른 분류 이며 vCore &gt;&gt; Real Core &gt;&gt; RealServer 순으로 사양 이 높아 진다. 스탭 별로 필요한 옵션을 선택(아래는 필자가 선택한 옵션) Step01. ZONE 선택 &gt;&gt; KR1-Lite-Z01 Step02. 운영체제 선택 &gt;&gt; CentOS 7.X(64bit) Step03. 하드웨어 선택 &gt;&gt; SINGLE SSD &gt;&gt; vCore.V1-Lite Step04. 블록 스토리지 추가 &gt;&gt; 건너뛰기(데이터 손실을 방지하기 위해 블록 스토리지에 백업하는 서비스라 추정된다) Step05. 이름 설정 &gt;&gt; recordboy Step06. 수량 선택 &gt;&gt; 1개 Step07. 확인 서버 접속대부분의 리눅스 웹 서버는 SSH라는 터미널 프로그램에 접속 명령어를 직접 입력하면서 관리를 한다. 이번에 신청한 서버도 리눅스 서버 호스팅 상품이며, SSH접속정보만이 제공 된다.SSH 접속 프로그램은 PuTTY라는 프로그램을 쓸 것이다. SSH클라이언트: SSH 접속을 지원하는 서버에 접속하기 위한 사용자 프로그램 PuTTY 사이트에 접속해 해당 프로그램 설치 프로그램 실행 후 Host Name(or IP address)란에 IWINV서버의 IP주소를 입력하고, **포트(22), 프로토콜(SSH)**를 선택하여 접속한다. 본인의 IWINV 로그인 비밀번호를 이용해, 관리자(root) ID 로 로그인 한다. 운영체제 재설치를 했을 경우 IWINV 가입할 때 입력한 본인 이메일로 초기 비밀번호를 받을 수 있다. 비밀번호 인증이 성공하면 쉘 프롬프트가 떨어지며, #기호가 표시된다. root 가 아닌 일반 사용자일 경우에는 #기호 대신 $기호로 표시된다. SSH 접속 비밀번호는 Console 을 통한 시스템 로그인 비밀번호와 동일하다. root 계정은 Linux 시스템 내에서 최고 권한의 관리자 계정이므로, 비밀번호 보안에 각별한 주의를 기울여야 한다. 초기 비밀번호가 복잡하니 아래 명령어로 패스워드를 변경해 준다. 1$ passwd 해당 서버의 이름을 설정해 주자. 처음에는 root@서버이름: ~]# 식으로 보여진다. References 한번에 끝내는 CentOS 웹서버세팅 (센토스 서버세팅)IWINV 서버 신청 가이드Yum - 위키백과[리눅스 서버 구축하기] 1. 기초 지식 알아보기","link":"/2019/10/21/linux-server-init/"},{"title":"[Mac] 맥 터미널 명령어","text":"명령어 Windows 커맨드 Mac OS 터미널 현재 디렉토리 cd pwd 현재 디렉토리 파일 리스트 보기 dir ls 디렉토리 이동 cd cd 디렉토리 생성 mkdir mkdir 디렉토리 삭제 rmdir rmdir 화면 클리어 cls clear null 파일 생성 type NUL &gt; touch 파일 삭제 del rm 파일 이동 move mv 디렉토리 이름 바꾸기 ren mv Explorer/Finder 에서 열기 start open","link":"/2020/01/19/mac-terminal-command/"},{"title":"[Linux] Yum 명령어","text":"패키지 설치 1# install [패키지명] 패키지 삭제 1# yum remove [패키지명] 패키지 업데이트 1# yum update [패키지명] 패키지 정보 확인 1# yum info [패키지명] 패키지 검색 1# yum search [검색어] 패키지 목록 보기 1# yum list 설치된 패키지 목록 보기 1# yum list installed 패키지 설치, 변경, 삭제로 변경된 정보 보기 1# yum history list 저장소 확인하기 1# yum repolist","link":"/2019/10/23/linux-yum-command/"},{"title":"[Network] 포트(Port)","text":"포트(Port) 컴퓨터의 주변 장치와 연결하기 위한 연결단 IP 내에서 프로세스 구분을 하기 위해 사용 쉽게 말해 각 프로토콜의 데이터가 통하는 논리적 통로 각 포트는 번호로 구별되며 이 번호를 포트 번호라고 함 포트 번호는 IP 주소와 함께 쓰여 해당하는 프로토콜에 의해 사용됨 포트 번호는 크게 세 종류로 구분된다. 0번 ~ 1023번: 잘 알려진 포트 (well-known port) 1024번 ~ 49151번: 등록된 포트 (registered port) 49152번 ~ 65535번: 동적 포트 (dynamic port) 잘 알려진 포트 번호의 대표적 예는 다음과 같다. 20 : FTP(data) 21 : FTP(제어) 22 : SSH 23 : 텔넷 53 : DNS 80 : 월드 와이드 웹 HTTP 119 : NNTP 443 : TLS/SSL 방식의 HTTP References 포트 (컴퓨터 네트워킹)포트","link":"/2019/10/18/network-port/"},{"title":"[Mac] 맥 터미널 쉘 접속","text":"윈도우에서는 Putty라는 프로그램으로 ssh접속을 하였지만 맥에서는 터미널로 바로 접속이 가능하다. 1$ ssh [ID]@[HOST] 예를들어 webapp이 아이디이고 127.0.0.1가 호스트 번호 라면 1$ ssh webapp@127.0.0.1 라고 입력한 뒤 패스워드를 입력하면 된다.","link":"/2020/01/21/mac-terminal-ssh/"},{"title":"[Network] GET과 POST 차이","text":"HTTP 웹상에서 클라이언트와 서버 간에 데이터를 주고 받을 수 있는 프로토콜 HTTP 메서드에는 2가지 방식이 있는데, 그것이 GET 방식과 POST 방식 GETURL에 파라미터를 포함시켜 요청하는 방식이다. 예를들어 https://recordboy.github.io/login?id=user&amp;pw=1234 라는 페이지가 있다고 치자, ? 마크를 통해 URL의 끝을 알리고, id라는 키(key)에 대해선 user라는 값(value)를, pw라는 키(key)에 대해서는 1234라는 값(value)을 전송한 것을 볼 수 있다. 여러개의 키와 값을 보낼 때는 &amp;를 사용하여 이어준다. 이처럼 데이터가 노출되기 때문에 보안에 취약하며, 개인정보가 포함되지 않는 상황에서 캐싱을 하여 페이지 로딩 속도를 높일 때 사용된다. 특징 URL에 파라미터를 포함시켜 요청한다. 데이터를 Header(헤더)에 포함하여 전송한다. URL에 파라미터가 노출되어 보안에 취약하다. 캐싱할 수 있다. GET 방식은 글자수 제한이 있지만, 256자 라는 말은 사실이 아니다. 익스 9의 경우 2083자/최대 5120자를 지원사파리는 40만자를 넘기면 브라우저가 크러쉬파이어폭스/오페라는 길이 제한이 없고 50만자를 넘겨도 별다른 이상 없음크롬의 경우 4만자를 기준 POSTPOST는 제출하다라는 뜻으로 BODY에 데이터를 넣어 전송하며 길이의 제한이 없다. 따라서 GET과 다르게 대용량 데이터를 전송할 수 있으며, BODY에 전송되어 내용이 눈에 보이지 않아 보안적으로 안전하다고 할 수 있다. 하지만 POST요청도 크롬 개발자 도구같은 툴로 요청내용을 확인할 수 있기 때문에 민감한 데이터는 반드시 암호화 하여 전달해야 한다.그리고 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 명시해야 한다. 종류는 여러가지가 있지만 몇가지 나열해보면 application/x-www-form-urlencoded GET방식과 마찬가지로 BODY에 key와 value쌍으로 데이터를 넣는다. 똑같이 구분자 &amp;를 쓴다. text/plain BODY에 단순 텍스트를 넣는다. multipart/form-data 파일전송을 할때 많이 쓰는데 BODY의 데이터를 바이너리 데이터로 넣는다는걸 알려준다. 특징 BODY에 데이터를 넣어 전송하며 길이의 제한이 없어 대용량 데이터를 전송할 수 있다. BODY에 데이터가 들어가기 때문에 GET보다는 보안상 유리하지만 민감한 데이터는 꼭 암호화를 해줘야 한다. 요청 헤더의 Content-Type에 요청 데이터의 타입을 명시해야 한다. References GET과 POST의 차이[Web] GET과 POST의 비교 및 차이get 방식의 글자 256자 제한은 잘못된 상식GET방식 과 POST방식","link":"/2017/12/04/network-get-post/"},{"title":"[Network] REST(Representational State Transfer)","text":"RESTREST는 웹에서 데이터를 전송하고 처리하는 방법을 정의한 인터페이스를 말하며, 모든 데이터 구조와 처리 방식은 REST에서 URL을 통해 정의된다. 때문에 매우 직관적이고 이해하기 쉬우며 사용자에게 더 쉽게 서비스를 제공할 수 있다. RESTfullRESTfull API라고도 하며, HTTP 프로트콜과 REST의 원칙을 사용하여 구현된 웹 서비스이다. 리소스(Resource)는 모든 인터넷 환경에서 사용이 가능한 표준화 된 형식(일반적으로 XML 또는 JSON)으로 표현된다. REST 중심 규칙URL는 정보의 자원을 표현해야 한다URL은 의미를 명확히 전달하기 위해 명사로 구성한다. 예를 들어 요청 URL이 /user면 사용자 정보에 관한 요청이며, /post라면 게시글에 관한 요청하는 것으로 추측이 가능하다. 자원에 대한 행위는 HTTP Method로 표현한다REST에선 HTTP Method를 사용하며 주요 메서드는 아래와 같다. HTTP Method GET(자원 정보 조회): 서버의 자원을 가져올 때 사용한다. 요청의 본문에 데이터를 넣지 않으며 쿼리스트링을 사용하여 서버에 데이터를 보낸다. 또한 GET 메서드는 브라우저에서 캐싱(기억)할 수도 있다. 쿼리스트링URL에 미리 협의된 데이터를 파라미터를 통해 넘기는 것을 말한다. 정해진 주소 이후에 ?를 쓰는것으로 쿼리스트링 시작을 의미한다. 형태는 parameter=value이며 =로 파라미터와 값이 구분되며 파라미터가 여러개의 경우 &amp;를 붙여 각 값을 구분한다. 예시: https://recordboy.github.io/?파라미터=값&amp;파라미터=값 POST(자원 생성): 서버에 자원을 새로 등록할 때 사용된다. 요청의 본문에 새로 등록할 데이터를 넣어 보낸다. PUT(자원 업데이트): 서버의 자원을 요청에 있는 자원으로 치환할 때 보낸다. 요청의 본문에 치환할 데이터를 넣어 보낸다. PATCH(자원 일부 업데이트): PUT이 자원 전체를 업데이트한다면 PATCH는 자원 일부를 수정할 때 사용한다. 요청의 본문에 수정할 데이터를 넣어 보낸다. DELETE(자원 삭제): 자원을 삭제할 때 사용되며, 요청의 본문에 데이터를 넣지 않는다. OPTIONS(옵션 설명): 요청을 하기 전에 통신 옵션을 설명하기 위해 사용된다. REST 구성 요소 구성 요소 내용 표현 방법 Resource 자원 HTTP URI Verb 자원에 대한 행위 HTTP Method Representations 자원에 대한 행위의 내용 HTTP Message Pay Load REST 특징클라이언트/서버 구조(Client - Server)자원이 있는 서버와 자원을 요청하는 클라이언트의 구조를 가진다. REST 서버는 클라이언트에게 API만 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실하게 구분되어 일관적인 인터페이스로 분리되고 작동할 수 있게 한다. 무상태성(Stateless)HTTP는 무상태 프로토콜 이므로 REST 역시 무상태성을 가진다. 다시 말해 작업을 위한 상태 정보를 따로 저장하고 관리하지 않는다. 세션이나 쿠키를 별도로 저장, 관리하지 않기 때문에 API 서버는 들어오는 요청만 단순히 처리하면 된다. 그래서 서비스의 자유도가 높아지며, 불편한 정보를 관리하지 않음으로써 구현이 단순해진다. 캐시 처리 가능(Cachealble)REST에서는 웹 표준 HTTP 프로토콜을 그대로 사용하므로, 웹의 기존의 인프라를 그대로 활용 가능하다. 때문에 REST에서도 캐싱 기능을 사용할 수 있다. 계층화(Layered System)REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조를 변경할 수 있다. 또한 Proxy, Gateway와 같은 네트워크 기반의 중간매체를 사용할 수 있다. 하지만 클라이언트는 서버와 직접 통신하는지 중간 서버와 통신하는지 알 수 없다. 자체 표현 구조(Self-descriptiveness)REST는 JSON 메세지 포멧을 이용하여 직관적으로 이해할 수 있고, 그 요청이 어떤 행위를 하는지 쉽게 알수 있는 자체 표현 구조로 되어있다. JSON은 하나의 옵션일뿐, 메시지 포맷을 꼭 JSON으로 적용해야할 필요는 없다. 유니폼 인터페이스(Uniform Interface)URL에 대한 요청을 통일되고 한정적으로 수행하는 이키텍쳐 스타일을 의미하며, HTTP 표준에만 따른다면 모든 플랫폼에서 사용이 가능하다. REST 장점쉬운 사용HTTP 프로토콜 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다. 클라이언트와 서버의 명확한 역할 분리클라이언트는 REST API만을 통해 서버와 정보를 주고받는다. 때문에 REST의 무상태성에 따라 사용자의 컨텍스트를 따로 관리할 필요가 없다. 특정 데이터 표현 사용가능REST는 헤더 부분에 URL 처리 메서드를 명시하고 실제 필요한 데이터는 BODY에 표현할 수 있도록 분리하여 JSON , XML 등 원하는 언어로 사용이 가능하다. REST 단점메서드의 한계REST API는 HTTP 메서드를 이용하여 URI를 표현하기 때문에 쉬운 사용이 가능한 장점이 있지만 반대로 메서드 형태가 제한적이라는 단점이 있다. 표준이 없음REST는 설계 가이드일 뿐 표준이 아니며 명확한 표준이 없다. References RESTNode.js 교과서REST란REST API의 이해와 설계-#1 개념 소개[Server] Restful API란?REST 아키텍처를 훌륭하게 적용하기 위한 몇 가지 디자인 팁","link":"/2020/12/10/network-rest/"},{"title":"[Nginx] Nginx 기본 세팅","text":"Nginx 설치12345# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# yum install nginx.x86_64# systemctl start nginx# systemctl enable nginx PHP 설치12345678910111213141516# yum install yum-plugin-replace# yum install mod_php71w php71w-common# yum install php71w-gd# yum install php71w-fpm# yum install php71w-opcache# yum install php71w-cli# yum install php71w-mysqlnd# yum install php71w-xml# yum install php71w-mbstring# sed -i 's/;date.timezone =/date.timezone = Asia\\/Seoul/g' /etc/php.ini# yum install -y make automake gcc gcc-c++ kernel-devel openssl-devel php php-devel php-pear bzip2-devel libvpx-devel yum-utils bison re2c libmcrypt-devel libpqxx-devel libxslt-devel pcre-devel libcurl-devel libgsasl-devel openldap-devel libmemcached-devel libjpeg-devel libpng-devel readline-devel# systemctl start php-fpm# systemctl enable php-fpm nginx.conf 파일찾기 1# sudo find / -name nginx.conf nginx.conf 수정하기 1# vi /etc/nginx/nginx.conf nginx 다시 로드 하기 1# sudo service nginx reload","link":"/2019/11/19/nginx-install/"},{"title":"[Nginx] Nginx 리눅스 명령어","text":"명령어 동작 # systemctl status nginx 상태 확인 # sudo systemctl stop nginx 웹서버 정지 # sudo systemctl start nginx 웹서버 재시작 # sudo systemctl reload nginx 설정 리로드","link":"/2020/01/04/nginx-command/"},{"title":"[Node.js] http 서버 만들기","text":"Node.js 환경에서 간단한 http 서버를 만들어 보자. Node.js는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임(특정 언어로 만든 프로그램들을 실행할 수 있는 환경)이다. 기존의 자바스크립트는 웹 브라우저에서만 실행할 수 있었지만, Node.js를 사용하면 자바스크립트를 서버 환경에서도 사용할 수 았다. 노드 환경에서 서버를 만들려면 노드 기본 모듈인 http가 필요하다. 이 모듈은 말그대로 HTTP의 각종 기능을 가지고 있다. 모듈을 불러오고 아래 코드를 입력한다. HTTP 모듈 생성1234567891011121314const http = require(&quot;http&quot;);http .createServer((req, res) =&gt; { res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;, }); res.write(&quot;&lt;div&gt;hello world&lt;/div&gt;&quot;); res.end(&quot;&lt;div&gt;end&lt;/div&gt;&quot;); }) .listen(8080, () =&gt; { console.log(&quot;8080포트에서 서버 대기중&quot;); }); 아래 명령어를 시용하여 서버를 구동시켜 보자. 1$ node server 8080포트에서 서버 대기중이란 문구가 터미널에 출력되면 http서버가 정상 작동하는 것이다. http://localhost:8080 주소로 들어가보면 hello world를 확인할 수 있다. http 모듈의 createServer메서드로 서버 객체를 생성하였고 요청이 들어올 때 마다 매번 이 콜백함수가 실행된다. 콜백의 인수로 res(request)는 요청에 관한 정보들을, res(respone)은 응답에 관한 정보들을 담고있다. res.writeHead 메서드는 응답에 대한 정보를 기록하는 메서드이며, 첫번째 인수로 요청이 성공했다는 상태 코드 200을 넣어주고, 두번째 인수로 응답에 대한 정보인 형식(HTML)과 문자셋(utf-8)를 넣어준다. 이 정보가 기록되는 부분을 헤더(header) 라고 한다. 상태 코드res.writeHead 메서드의 첫번째 인수로 넣어주는 200이나 500과 같은 숫자는 응답 상태를 나타내는 값으로서 브라우저는 상태 코드를 보고 요청이 성공/실패했는지 판단한다. 2XX: 성공을 알리는 상태코드며, 대표적으로 아래가 있다. 200(성공) 201(작성됨) 3XX: 리다이렉션(다른 페이지로 아동)을 알리는 상태코드로 넘겨받은 URL을 브라우저가 열려고 하면 다른 URL로 갈 때 이 코드가 사용된다. 대표적으로 아래가 있다. 301(영구 이동) 302(임시 이동) 302(수정되지 않음, 요청의 응답으로 캐시를 사용했음) 4XX: 요청 오류를 알리는 코드로서 요청 자체에 오류가 있을 때 표시된다. 대표적으로 아래가 있다. 400(잘못된 요청) 401(권한 없음) 403(금지됨) 404(찾을 수 없음) 5XX: 서버 오류를 나타내며, 요청은 제대로 왔지만 서버에 오류가 있을 때 발생한다. 이 오류는 res.writeHead에서 직접 보내는 경우는 거의 없고, 예기치 못한 에러가 발생 시 서버가 알아서 5XX대 코드를 보낸다. 대표적으로 아래가 있다. 500(내부 서버 오류) 502(불량 게이트웨이) 503(서비스를 사용할 수 없음) res.write 메서드는 클라이언트로 보낼 데이터이며, 인수로 지정한 값이 바디 부분의 컨텐츠로 작성된다. 여러번 호출해서 데이터를 여러개 보낼 수 있다. res.end 메서드는 출력을 완료하는 메서드이며, 인수로 값을 지정하면 해당 인수의 값을 작성한 뒤 내용을 완료한다. 이 메서드로 인해 응답 처리는 종료되고, 그 요청의 처리가 종료된다. res.writeHead, res.write, res.end 이 3개의 메서드로 클라이언트에 대한 응답 내용을 사용할 수 있다. createServer 메서드 뒤에 listen 메서드에 클라이언트에게 공개할 포트번호를 인수로 넣고 두번째 인자로 포트연결 완료 후 살행될 콜백 함수를 넣었다. HTML 불러오기res.write나 res.end에 HTML 코드를 일일히 작성하는 것은 비효율적이므로 미리 HTML 파일을 만들고 fs 모듈로 파일을 읽어 전송할 수 있다. 간단한 HTML 코드를 작성하고 index.html 파일로 루트경로에 저장한다, 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;contents&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435const http = require(&quot;http&quot;);// fs 모듈 로드const fs = require(&quot;fs&quot;).promises;http .createServer(async (req, res) =&gt; { // 통신 성공 시 try { // fs 모듈로 index.html 로드 const data = await fs.readFile(&quot;./index.html&quot;); res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;, }); // html 응답 res.end(data); // 에러 발생 시 } catch (err) { console.error(err); res.writeHead(500, { &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;, }); // 에러 메세지 응답 res.end(err.message); } }) .listen(8080, () =&gt; { console.log(&quot;8080포트에서 서버 대기중&quot;); }); 요청이 들어오면 fs 모듈로 HTML 파일을 읽어 클라이언트의 응답 값으로 보낼 수 있다. 라우팅라우팅이란 특정한 URL에 대해 특정한 화면으로 연결하는 역할이라 정의할 수 있다. 주소가 http://localhost:8080/index.html면 index.html 화면을 보여주고 http://localhost:8080/about.html면 about.html 화면을 보여주는 역할이라 보면 된다. 간단히 라우팅을 구현해 보겠다. index.html 파일을 아래와 같이 수정해 주고, about.html 파일도 새롭게 추가해 준다. index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;nav&gt; &lt;a href=&quot;/&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;/about&quot;&gt;about&lt;/a&gt; &lt;/nav&gt; &lt;div&gt;메인 페이지&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; about.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;nav&gt; &lt;a href=&quot;/&quot;&gt;home&lt;/a&gt; &lt;a href=&quot;/about&quot;&gt;about&lt;/a&gt; &lt;/nav&gt; &lt;div&gt;소개 페이지&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; server.js 파일은 아래와 같이 수정해 준다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344const http = require(&quot;http&quot;);// fs 모듈 로드const fs = require(&quot;fs&quot;).promises;http .createServer(async (req, res) =&gt; { // 통신 성공 시 try { if (req.url === &quot;/&quot;) { // index.html 로드 const data = await fs.readFile(&quot;./index.html&quot;); res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;, }); res.end(data); } else if (req.url === &quot;/about&quot;) { // about.html 로드 const data = await fs.readFile(&quot;./about.html&quot;); res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/html; charset=utf-8&quot;, }); res.end(data); } // 에러 발생 시 } catch (err) { console.error(err); res.writeHead(500, { &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;, }); // 에러 메세지 응답 res.end(err.message); } }) .listen(8080, () =&gt; { console.log(&quot;8080포트에서 서버 대기중&quot;); }); 특정 링크를 클릭하면 지정한 화면으로 이동하는 것을 확인할 수 있다. References Node.js 교과서[Node.js코드랩] 2.기본 모듈 http기본 스크립트와 http 객체","link":"/2020/08/04/node-http-server/"},{"title":"[React] 리액트 초기 세팅 및 컴포넌트","text":"리액트는 제이쿼리처럼 단순히 &lt;script src=&quot;...&quot;&gt;&lt;script&gt;의 형태로 사용했던 것처럼 사용하지 않는다. 이렇게 하려면 가능은 하지만 굉장히 제한적이다. 리액트를 제대로 작업하려면 로컬에 Node, Npm, Webpack, Babel 등의 도구를 설치하여 프로젝트를 설정해주어야 한다. 리액트 프로젝트를 바닥부터 설정하는 것은 꽤나 복잡하지만, 페이스북에서 제공해주는 create-react-app도구 를 통하여 간단히 리액트 프로젝트를 준비할 수 있다. 프로젝트 시작하기설치 환경 node.js npm 전역에 create-react-app 설치1$ npm install -g create-react-app 프로젝트 생성12// 자바스크립트를 사용$ create-react-app 프로젝트명 --use-npm 12// 타입스크립트 사용$ create-react-app 프로젝트명 --use-npm --template typescript 프로젝트 실행해당 디렉토리로 이송해서 명령어를 실행하면 리액트 앱이 localhost:3000에 실행된다. 12$ cd 프로젝트명$ npm start 디렉토리 구조기본적인 디렉토리 구조는 아래와 같다. 프로젝트마다 디렉토리 구조는 약간씩 다르기 때문에 정확히 어느 구조가 맞다고 정의하긴 힘들다. 123456789101112131415└── project ├── build // npm run build 커맨드를 통해 생성된 react 배포 폴더 │ └── static │ ├── css │ ├── js │ └── media ├── node_modules // npm install 을 통해 설치된 모듈들이 위치하는 폴더 ├── public // 서버 root ├── src // components / containers / pages / store 등이 위치하는 폴더 │ ├── components // 컴포넌트 파일들이 위치하는 폴더 │ ├── containers // 컨테이너 파일들이 위치하는 폴더 │ ├── pages // routing을 위한 페이지 파일들이 위치하는 폴더 │ ├── store // redux 작업을 위한 폴더, 내부에 actions, reducers 폴더 존재 │ └── .. └── package .. // version, dependencies, proxy 등의 정보가 들어있는 파일 컴포넌트 파일 살펴보기src 폴더의 App.js파일을 열어본다. 12345678910111213141516171819202122232425import React from 'react';import logo from './logo.svg';import './App.css';function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );}export default App; App.js파일의 코드가 무엇을 의미하는지 위에서부터 알아보겠다. 123import React from 'react';import logo from './logo.svg';import './App.css'; import는 파일을 불러오겠다는 것이다. 첫번째 코드는 리액트와 그 내부의 Component를 불러온다. 파일에서 JSX를 사용하려면, 꼭 React를 import해주어야 한다. 그 아래에는 같은 디렉토리의 logo.svg와 App.css를 불러온다는 것이다. 함수를 이용한 컴포넌트 생성123456789101112131415161718192021222324function App() { return ( // 여기서부터 JSX &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; // 여기서까지 JSX );} App함수를 생성하여 컴포넌트를 만들었다. 리액트에서 컴포넌트를 만드는 방법은 두가지가 있으며 위처럼 함수를 이용하여 만드는 방법과, 클래스를 이용하여 만드는 방법이 있다. 함수형 컴포넌트와 클래스형 컴포넌트의 주요 차이점은 함수형 클래스는 state와 life cycle이 빠져있다는 점이다. 그래서 컴포넌트 초기 마운트가 아주 미세하게 빠르고, 메모리 자원을 덜 사용하지만 컴포넌트를 무수히 많이 랜더링하는게 아니라면 성능에 큰 차이는 없다. state와 life cycle는 추후에 알아보도록 하고, 지금부터는 클래스형 컴포넌트로 작성하도록 하겠다. 클래스를 이용한 컴포넌트 생성1234567891011121314151617181920212223242526class App extends Component { render() { return( // 여기서부터 JSX &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; // 여기서까지 JSX ) }} 클래스 형태로 만들어진 컴포넌트에는 꼭, render함수가 있어야 하며, 그 내부에서는 JSX를 리턴해줘야 한다. 위에 보이는 HTML같은 코드가 JSX이다. 또 하나, 클래스형 컴포넌트를 작성하기위해선 import에 아래처럼 { Component }를 추가하여 작성해야 한다. 1import React, { Component } from 'react'; App.js의 마지막줄은 생성된 컴포넌트를 내보내고 있으며, 다른곳에서 사용할 수 있도록 해준다. 아래처럼 작성하면 된다. 1export default App; 이제 컴포넌트를 생성하고 내보냈으니, 이 컴포넌트를 불러오는 index.js파일을 열어보겠다. 1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import * as serviceWorker from './serviceWorker';ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById('root'));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: https://bit.ly/CRA-PWAserviceWorker.unregister(); 우리가 만든 컴포넌트를 아래처럼 import로 불러오고 있다. 1import App from './App'; 받은 컴포넌트를 브라우저상에 보여주려면 ReactDOM.render함수를 사용한다. 첫번째 파라미터는 렌더링 할 결과물이고, 두번째 파라미터는 컴포넌트를 어떤 DOM에 그릴지 정해준다. 123456ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 위처럼 첫번째 파라미터로 랜더링할 컴포넌트를 받고 있으며(&lt;React.StrictMode&gt;는 리액트의 엄격한 모드이다.), 두번째 파라미터로 document.getElementById('root')를 받고있다. id가 root인 돔을 찾아 그리도록 설정이 되어있으며, 해당 DOM은 public/index.html파일 안의 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;를 찾아서 랜더링을 하게 된다. References 누구든지 하는 리액트 2편: 리액트 프로젝트 시작하기[React] 프로젝트 디렉토리 구조 파악하기","link":"/2020/03/06/react-component/"},{"title":"[Express] Puppeteer, React, Express를 활용한 크롤러 만들기 및 Heroku에 배포하기","text":"이번에는 Puppeteer를 활용하여 웹 크롤러를 만들어 보겠다. 클라이언트는 React, 서버는 Express를 사용하고 로컬에서 작업이 끝나면 Heroku에 배포까지 해보자. 결과물과 소스는 아래에서 확인할 수 있다. 결과물: https://recordboy-scrap-sample.herokuapp.com 소스: https://github.com/recordboy/scrap-sample 결과물은 헤로쿠에 배포되었기 때문에 처음 페이지가 열릴때 로딩시간이 10초에서 30초정도 걸릴수 있다. PuppeteerPuppeteer는 Google Chrome 개발팀에서 직접 개발한 Chrome(혹은 Chromium) 렌더링 엔진을 이용하는 node.js 라이브러리이다. Puppeteer는 headless 모드를 지원하며, 이는 브라우저를 띄우지 않고 렌더링 작업을 가상으로 진행하고 실제 브라우저와 동일하게 동작한다. Puppeteer는 다양한 기능을 가지고 있으며 아래와 같은 기능들이 있다. 웹페이지의 스크린샷과 PDF를 생성한다. SPA(단일 페이지)를 크롤링하고 미리 렌더링된 콘텐츠(예: SSR)를 생성한다. 폼 입력, UI 테스트, 키보드 입력 등을 자동화 할 수 있다. 최신 자바스크립트 및 브라우저 기능을 이용해 최신버전의 크롬에서 직접 테스트할 수 있다. 사이트의 Timeline Trace를 기록하여 성능이나 문제를 진단할 수 있다. 크롬 확장 프로그램을 테스트 할 수 있다. 프로젝트 초기화이 부분은 [Express] Express + React 연동 및 Heroku에 배포하기 포스팅과 비슷한 부분이 많기 때문에 각 단계의 추가 설명 없이 진행하도록 하겠다. 디렉토리 생성 및 필요 모듈 설치디렉토리를 생성하고 이그노 파일을 생성한 뒤 npm 초기화 및 필요한 모듈을 설치한다. TERMINAL12345$ mkdir my-app$ cd my-app $ echo node_modules &gt; .gitignore$ npm init -y$ npm install express nodemon concurrently 이제 서버로 사용할 index.js 파일을 생성하고 아래 내용을 입력한다. index.js12345678910111213141516// express 모듈 불러오기const express = require(&quot;express&quot;);// express 객체 생성const app = express();// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 미들웨어 함수를 특정 경로에 등록app.use(&quot;/api/data&quot;, function (req, res) { res.json({ greeting: &quot;Hello World&quot; });});console.log(`server running at http ${port}`); package.json 파일을 열고 scripts 항목에 &quot;start&quot;: &quot;nodemon index.js&quot;를 추가한다. package.json123&quot;scripts&quot;: { &quot;start&quot;: &quot;nodemon index.js&quot;} 리액트 초기화이제 클라이언트로 사용할 리액트를 생성하며, 이름은 client로 한다. TERMINAL1$ create-react-app client --use-npm --template typescript 프록시 설정설치가 완료되면 client 디렉토리로 이동해서에 아래 모듈을 설치한다. TERMINAL12$ cd client$ npm install http-proxy-middleware 설치한 뒤 /client/src/ 디렉토리로 가서 setupProxy.js 파일을 생성하고 아래 코드를 입력해준다. setupProxy.js12345678910const { createProxyMiddleware } = require(&quot;http-proxy-middleware&quot;);module.exports = function (app) { app.use( createProxyMiddleware(&quot;/api/data&quot;, { target: &quot;http://localhost:5000&quot;, changeOrigin: true, }) );}; 서버(express), 클라이언트(react) 동시 시작 설정루트로 가서 package.json의 scripts항목을 아래처럼 수정해준다. package.json123456&quot;scripts&quot;: { &quot;start&quot;: &quot;nodemon index.js&quot;, &quot;dev&quot;: &quot;concurrently \\&quot;npm run dev:server\\&quot; \\&quot;npm run dev:client\\&quot;&quot;, &quot;dev:server&quot;: &quot;npm start&quot;, &quot;dev:client&quot;: &quot;cd client &amp;&amp; npm start&quot;} 이제 아래 명령어로 서버와 클라이언트를 동시에 시작할 수 있다. TERMINAL1$ npm run dev 이제 작업하기 위한 전반적인 준비가 끝났다. 우선 클라이언트 영역부터 작업해보자. 클라이언트에서 요청 작업검색 폼 및 리스트 추가/client/src/ 디렉토리에 components 폴더를 생성하고 SearchForm.tsx, SearchList.tsx 파일을 생성하고 각각 아래처럼 입력해 준다. SearchForm.tsx SearchForm.tsx1234567891011121314151617181920212223242526import React from &quot;react&quot;;const SearchForm = () =&gt; { return ( &lt;div className=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; className=&quot;form-text&quot; /&gt; &lt;button type=&quot;button&quot; className=&quot;form-btn&quot; onClick={() =&gt; { fetch(&quot;api/data&quot;) .then((res) =&gt; { return res.json(); }) .then((data) =&gt; { console.log(data); }); }} &gt; search &lt;/button&gt; &lt;/div&gt; );};export default SearchForm; SearchList.tsx SearchList.tsx123456789import React from &quot;react&quot;;const SearchList = () =&gt; { return ( &lt;div className=&quot;card-list&quot;&gt;&lt;/div&gt; );};export default SearchList; App.tsx은 아래처럼 변경해준다. App.tsx1234567891011121314import React from &quot;react&quot;;import SearchForm from &quot;./components/SearchForm&quot;;import SearchList from &quot;./components/SearchList&quot;;function App() { return ( &lt;div className=&quot;App&quot;&gt; &lt;SearchForm /&gt; &lt;SearchList /&gt; &lt;/div&gt; );}export default App; search 버튼을 클릭하면 fetch 함수로 서버(http://localhost:5000/api/data)에 요청을 하게 되고 응답값으로 콘솔창에 { greeting: &quot;Hello World&quot; }가 출력되는 것을 확인할 수 있다. fetch 함수를 App 컴포넌트로 이동이제 검색키워드를 서버에 보내기 위헤 SearchForm, App 컴포넌트를 아래처럼 수정해 준다. SearchForm.tsx SearchForm.tsx12345678910111213141516171819202122232425262728293031323334353637import React, { useState } from &quot;react&quot;;const SearchForm = (props: { getData: any }) =&gt; { const { getData } = props; const [keyword, setKeyword] = useState(&quot;&quot;); return ( &lt;div className=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; className=&quot;form-text&quot; onChange={(e: any) =&gt; { setKeyword(e.target.value); }} onKeyPress={(e: any) =&gt; { if (e.charCode === 13) { if (keyword) { getData(keyword); } } }} /&gt; &lt;button type=&quot;button&quot; className=&quot;form-btn&quot; onClick={() =&gt; { if (keyword) { getData(keyword); } }} &gt; search &lt;/button&gt; &lt;/div&gt; );};export default SearchForm; App.tsx App.tsx123456789101112131415161718192021222324import React from &quot;react&quot;;import SearchForm from &quot;./components/SearchForm&quot;;import SearchList from &quot;./components/SearchList&quot;;function App() { const getData = (keyword: string) =&gt; { console.log(&quot;검색 키워드: &quot; + keyword); fetch(`api/data?keyword=${keyword}`) .then((res) =&gt; { return res.json(); }) .then((data) =&gt; { console.log(data); }); }; return ( &lt;div className=&quot;App&quot;&gt; &lt;SearchForm getData={getData} /&gt; &lt;SearchList /&gt; &lt;/div&gt; );}export default App; SearchForm에 있던 fetch함수를 상위 App컴포넌트의 getData 함수에 넣어놨다. 이 함수를 SearchForm에 전달하였고, 검색버튼을 클릭하면 getData가 실행되며, input 태그의 검색 키워드가 쿼리스트링에 할당되어 서버에 전달되게 된다. 검색폼에서 엔터를 눌러도 요청할 수 있도록 onKeyPress 이벤트도 추가해 주자. 이제 응답값을 받기 위해 서버 작업을 해보자. 서버에서 요청 받기이제 루트로 가서 index.js를 아래처럼 수정해 준다. index.js1234567891011121314151617// express 모듈 불러오기const express = require(&quot;express&quot;);// express 객체 생성const app = express();// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 미들웨어 함수를 특정 경로에 등록app.use(&quot;/api/data&quot;, function (req, res) { console.log(&quot;검색 키워드: &quot; + req.query.keyword); res.json({ greeting: &quot;Hello World&quot; });});console.log(`server running at http ${port}`); 요청을 하면 서버 터미널에 검색 키워드가 출력될 것이다. 위 코드를 보면 미들웨어 함수에서 요청값(req.query.keyword)을 받기 때문이다. Puppeteer 설치이제 브라우저로 검색하기 위해 루트 디렉토리에 Puppeteer를 설치해주자. TERMINAL1$ npm install puppeteer Puppeteer는 기본적으로 Chrome 혹은 Chromium 런더링 엔진을 사용하기 때문에 기본적으로 Chromium 브라우저를 내장하고 있다. 따로 Chromium 브라우저를 다운받지 않으려면 $ npm install puppeteer-core 명령어를 사용하면 되며, Puppeteer는 로컬에 있는 Chrome 혹은 Chromium을 사용하게 될 것이다. 검색해보기Puppeteer를 설치했으면 이제 브라우저를 실행해 검색을 해보자. index.js를 아래처럼 수정해준다. index.js123456789101112131415161718192021222324252627282930313233343536373839404142// express 모듈 불러오기const express = require(&quot;express&quot;);// express 객체 생성const app = express();// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 미들웨어 함수를 특정 경로에 등록app.use(&quot;/api/data&quot;, function (req, res) { console.log(&quot;검색 키워드: &quot; + req.query.keyword); openBrowser(req.query.keyword);});console.log(`server running at http ${port}`);// puppeteer 모듈 불러오기const puppeteer = require(&quot;puppeteer&quot;);/** * 브라우저 오픈 함수 * @param {string} keyword 검색 키워드 */async function openBrowser(keyword) { // 브라우저 실행 및 옵션, 현재 옵션은 headless 모드 사용 여부 const browser = await puppeteer.launch({ headless: false }); // 브라우저 열기 const page = await browser.newPage(); // 포탈로 이동 await page.goto(&quot;https://www.google.com/&quot;); // 키워드 입력 await page.type(&quot;input[class='gLFyf gsfi']&quot;, keyword); // 키워드 검색 await page.type(&quot;input[class='gLFyf gsfi']&quot;, String.fromCharCode(13));} puppeteer 모듈을 불러온 뒤 openBrowser 함수를 추가하였으며, 포탈 이동 및 응답값을 받기 위해 async 함수로 감싸주었다. 브라우저 실행 옵션에서 headless 모드를 true로 설정하면 브라우저가 화면에 노출이 되지 않고 백그라운드에서 작동된다. 지금은 브라우저 작동 순서를 보기 위해 임시로 false로 설정해 준다. 위처럼 수정해 준 뒤 클라이언트 화면으로 가서 검색해 보면 아래 순서대로 작동된다. Chromium 브라우저가 실행되고 Google 사이트로 이동한 뒤 Google 검색창에 검색 키워드를 넣고 엔터를 눌러 검색을 시작한다. 검색 내용 크롤링하기이제 검색결과를 크롤링을 해보자. 크롤링할 내용 형태JSON123456{ title: &quot;제목&quot;, link: &quot;링크&quot;, text: &quot;내용&quot;, kategorie: &quot;카테고리&quot;} 크롤링으로 가져올 정보는 위 형태로 가져올 것이며, index.js를 아래처럼 코드를 수정한다. index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// express 모듈 불러오기const express = require(&quot;express&quot;);// express 객체 생성const app = express();// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 미들웨어 함수를 특정 경로에 등록app.use(&quot;/api/data&quot;, async function (req, res) { console.log(&quot;검색 키워드: &quot; + req.query.keyword); const resultList = await openBrowser(req.query.keyword); console.log(resultList); res.json(resultList);});console.log(`server running at http ${port}`);// puppeteer 모듈 불러오기const puppeteer = require(&quot;puppeteer&quot;);/** * 브라우저 오픈 함수 * @param {string} keyword 검색 키워드 * @return {array} 검색 결과 */async function openBrowser(keyword) { // 브라우저 실행 및 옵션, 현재 옵션은 headless 모드 사용 여부 const browser = await puppeteer.launch({ headless: true }); // 브라우저 열기 const page = await browser.newPage(); // 포탈로 이동 await page.goto(&quot;https://www.google.com/&quot;); // 키워드 입력 await page.type(&quot;input[class='gLFyf gsfi']&quot;, keyword); // 키워드 검색 await page.type(&quot;input[class='gLFyf gsfi']&quot;, String.fromCharCode(13)); // 예외 처리 try { // 해당 콘텐츠가 로드될 때까지 대기 await page.waitForSelector(&quot;#rso div.g&quot;, { timeout: 10000 }); } catch (error) { // 해당 태그가 없을 시 검색결과 없음 반환 console.log(&quot;에러 발생: &quot; + error); return [ { title: &quot;검색결과 없음&quot;, link: &quot;&quot;, text: &quot;&quot;, kategorie: &quot;&quot;, }, ]; } // 호출된 브라우저 영역 const searchData = await page.evaluate(() =&gt; { // 검색된 돔 요소를 배열에 담음 const contentsList = Array.from(document.querySelectorAll(&quot;#rso div.g&quot;)); let contentsObjList = []; // 검색결과 크롤링 contentsList.forEach((item) =&gt; { if (item.className === &quot;g&quot;) { const title = item.querySelector(&quot;h3&quot;); const link = item.querySelector(&quot;.yuRUbf&quot;); const text = item.querySelector(&quot;.VwiC3b&quot;); const kategorie = item.querySelector(&quot;.iUh30 &quot;); if (title &amp;&amp; link &amp;&amp; text &amp;&amp; kategorie) { contentsObjList.push({ title: title.textContent, // 타이틀 link: link.children[0].href, // 링크 text: text.textContent, // 내용 kategorie: kategorie.textContent, // 카테고리 }); } } }); // 호출된 브라우저 영역 콘솔창에서 확인할 수 있음 console.log(contentsList); // 검색한 엘리먼트 리스트 console.log(contentsObjList); // 검색한 콘텐츠 오브젝트 리스트 return contentsObjList; }); // 브라우저 닫기 browser.close(); // 검색결과 반환 return searchData;} 요소 대기headless 모드는 이제 true로 설정해준다. 브라우저가 크롤링하는 모습을 직접 확인하고 싶으면 false로 그냥 두면 된다. 이제 순서대로 코드를 살펴보자. page.waitForSelector 메서드를 추가했으며, 인자로 쿼리 셀렉터와 옵션이 들어간다. 이 메서드는 셀렉터 요소가 로드될 때 까지 대기하며, timeout로 대기 시간을 설정할 수 있다. 대기시간이 끝나도 해당 요소를 로드하지 못하면 에러를 뱉어내며, 이 경우 title에 검색결과가 없다는 값을 리턴해 준다. 브라우저 영역page.evaluate 메서드는 Puppeteer로 호출한 브라우저에서 실행되는 함수로써 여기다가 크롤링 코드를 작성하면 된다. 구글 검색결과의 각 엘리먼트 셀렉터는 #rso div.g이며, 해당 요소들을 Array.from 메서드를 통해 배열로 담았다. 필요한 정보만 가져오기 위해 forEach을 돌려 오브젝트에 내용을 담고 리턴해 준 다음 브라우저는 종료가 된다. 검색결과를 응답해주기이제 이 응답값을 미들웨어 함수에서 받아서 클라이언트의 응답값으로 보내줘야한다. 위 코드의 미들웨어 함수를 보면 콜백함수를 async로 감싸고 결과값을 await 키워드로 받아 응답값으로 보내주고 있다. 클라이언트의 콘솔창을 보면 크롤링한 리스트를 출력하는걸 확인할 수 있다. 연속 검색지금까지 구현된건 첫 페이지만 크롤링한 것이며, 다음 페이지를 추가로 크롤링을 하려면 아래 순서가 필요하다. 검색결과 맨아래 다음버튼이 있는지 찾기 다음 버튼 있는 경우 다음 페이지로 이동 다음 페이지 내용이 불러올때까지 대기 다음 페이지 크롤링 아래처럼 코드를 수정한다. index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// express 모듈 불러오기const express = require(&quot;express&quot;);// express 객체 생성const app = express();// 기본 포트를 app 객체에 설정const port = process.env.PORT || 5000;app.listen(port);// 미들웨어 함수를 특정 경로에 등록app.use(&quot;/api/data&quot;, async function (req, res) { console.log(&quot;검색 키워드: &quot; + req.query.keyword); const resultList = await openBrowser(req.query.keyword); console.log(resultList); res.json(resultList);});console.log(`server running at http ${port}`);// puppeteer 모듈 불러오기const puppeteer = require(&quot;puppeteer&quot;);/** * 브라우저 오픈 함수 * @param {string} keyword 검색 키워드 * @return {array} 검색 결과 */async function openBrowser(keyword) { // 모든 검색결과 let searchAllData = []; // 브라우저 실행 및 옵션, 현재 옵션은 headless 모드 사용 여부 const browser = await puppeteer.launch({ headless: true }); // 브라우저 열기 const page = await browser.newPage(); // 포탈로 이동 await page.goto(&quot;https://www.google.com/&quot;); // 키워드 입력 await page.type(&quot;input[class='gLFyf gsfi']&quot;, keyword); // 키워드 검색 await page.type(&quot;input[class='gLFyf gsfi']&quot;, String.fromCharCode(13)); // 검색하고 싶은 페이지 수 만큼 반복 for (let i = 0; i &lt; 10; i++) { // 처음 검색 if (i === 0) { // 예외 처리 try { // 해당 콘텐츠가 로드될 때까지 대기 await page.waitForSelector(&quot;#rso div.g&quot;, { timeout: 10000 }); // 크롤링해서 검색 결과들을 담음 searchAllData.push(...(await crawlingData())); } catch (error) { // 해당 태그가 없을 시 검색결과 없음 반환 console.log(&quot;에러 발생: &quot; + error); return [ { title: &quot;검색결과 없음&quot;, link: &quot;&quot;, text: &quot;&quot;, kategorie: &quot;&quot;, }, ]; } // 처음 이후 검색 } else { // 예외 처리 try { // 다음 버튼이 로드될때까지 대기 await page.waitForSelector(&quot;#pnnext&quot;, { timeout: 10000 }); // 브라우저를 호출해 다음 버튼을 클릭 await page.evaluate(() =&gt; { const nextBtn = document.querySelector(&quot;#pnnext&quot;); if (nextBtn) { nextBtn.click(); } }); // 크롤링해서 검색 결과들을 담음 searchAllData.push(...(await crawlingData())); // 다음 버튼이 더이상 없는 경우 지금까지 크롤링한 모든 검색결과 반환 } catch (error) { return searchAllData; } } } /** * 크롤링 함수 * @return {array} 검색 결과 */ async function crawlingData() { // 해당 콘텐츠가 로드될 때까지 대기 await page.waitForSelector(&quot;#rso div.g&quot;, { timeout: 10000 }); // 호출된 브라우저 영역 const searchData = await page.evaluate(() =&gt; { // 검색된 돔 요소를 배열에 담음 const contentsList = Array.from(document.querySelectorAll(&quot;#rso div.g&quot;)); let contentsObjList = []; // 검색결과 크롤링 contentsList.forEach((item) =&gt; { if (item.className === &quot;g&quot;) { const title = item.querySelector(&quot;h3&quot;); const link = item.querySelector(&quot;.yuRUbf&quot;); const text = item.querySelector(&quot;.VwiC3b&quot;); const kategorie = item.querySelector(&quot;.iUh30 &quot;); if (title &amp;&amp; link &amp;&amp; text &amp;&amp; kategorie) { contentsObjList.push({ title: title.textContent, // 타이틀 link: link.children[0].href, // 링크 text: text.textContent, // 내용 kategorie: kategorie.textContent, // 카테고리 }); } } }); // 호출된 브라우저 영역 콘솔창에서 확인할 수 있음 console.log(contentsList); // 검색한 엘리먼트 리스트 console.log(contentsObjList); // 검색한 콘텐츠 오브젝트 리스트 return contentsObjList; }); // 검색결과 반환 return searchData; } // 브라우저 닫기 browser.close(); // 모든 검색결과 반환 return searchAllData;} 이제 추가된 코드들을 살펴보자. 모든 검색결과를 담을 배열 설정31라인을 보면 searchAllData 배열을 추가하였으며, 이 배열안에 각 페이지마다 크롤링한 데이터가 들어간다. 브라우저 호출하는 영역을 함수로 묶음각 페이지마다 크롤링을 반복해줘야되기 때문에 101번째 라인을 보면 crawlingData 함수로 따로 묶어줬다. 그리고 리턴값은 searchData로 해주며, 기존 코드의 예외 처리(try)안에 있던 page.waitForSelector 메서드만 함수 상단에 추가해 준다. 대략적인 형태는 아래와 같다. 1234567891011121314151617181920/** * 크롤링 함수 * @return {array} 검색 결과 */async function crawlingData() { // 해당 콘텐츠가 로드될 때까지 대기 await page.waitForSelector(&quot;#rso div.g&quot;, { timeout: 10000 }); // 호출된 브라우저 영역 const searchData = await page.evaluate(() =&gt; { // ... 기존 크롤링 코드 return contentsObjList; } // 검색결과 반환 return searchData;} 처음 검색 후 다음 페이지로 이동하여 검색코드 49번 라인을 보면 반복문이 실행되며, 검색하고 싶은 페이지만큼 반복되도록 되어있다. 위 코드는 10번만 반복하게 했으며, 반복 횟수를 늘리면 더 많은 페이지를 크롤링할 수 있다. 각 예외 처리는 2개 분기로 되어있으며, 이유는 계속 페이지마다 검색을 하는 경우 결과가 여러가지 있기 때문이다. 검색 결과의 경우들 처음 검색에 아무 검색결과가 없는 경우 처음 검색과는 있는데 다음 버튼이 없어서 검색결과가 첫 페이지만 있는 경우 다음 페이지가 존재해 계속 검색을 진행하다 마지막 페이지에 도달해서 다음 버튼이 없는 경우 처음 검색은 51라인부터 시작되며 검색결과가 없다면 59라인에서 에러를 캐치하며 클라이언트에 검색결과 없음을 리턴해 준다. 검색 결과가 있으면 두번째 반복이 73라인에서 실행되며, 다음 버튼이 있는 경우 83라인 함수에서 다음버튼을 클릭하고 crawlingData 함수가 실행되어 크롤링을 계속 반복하게 된다. 크롤링 결과값은 searchAllData 배열에 전개연산자를 활용하여 차곡차곡 쌓이도록 해준다. 이렇게 계속 다음 페이지로 이동하고 더이상 다음버튼이 없으면 91라인에서 에러를 캐치하여 지금까지 모은 searchAllData를 리턴하게 된다. headless 모드를 false로 설정하면 브라우저가 각 페이지를 돌면서 크롤링을 하는 모습을 직접 볼 수 있다. 결과 확인서버 터미널이나 클라이언트 콘솔창을 확인하면 각 페이지마다 크롤링한 데이터를 정상적으로 응답해주는것을 확인할 수 있다. 지금까지 클라이언트, 서버 셋팅 및 연속 크롤링하는 것까지 알아봤으며 이제 이 응답값을 클라이언트에 뿌려주는 작업을 해보자. 클라이언트에서 받은 데이터 출력하기출력될 컴포넌트 추가데이터가 들어갈 영역을 만들어주자. 우선 /client/src/components 디렉토리에 SearchItem.tsx 파일을 생성하고 아래 코드를 입력해준다. SearchItem.tsx123456789101112131415161718192021import React from &quot;react&quot;;const SearchItem = (props: { item: any }) =&gt; { const { item } = props; return ( &lt;div className=&quot;card&quot;&gt; &lt;div className=&quot;top&quot;&gt; &lt;div className=&quot;kategorie&quot;&gt;{item.kategorie}&lt;/div&gt; &lt;div className=&quot;title&quot;&gt;{item.title}&lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;bottom&quot;&gt; &lt;div className=&quot;text&quot;&gt;{item.text}&lt;/div&gt; &lt;a href={item.link} className=&quot;link&quot; target=&quot;_blank&quot; rel=&quot;noreferrer&quot;&gt; 더보기 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; );};export default SearchItem; 컴포넌트에 데이터 전달하기SearchList.tsx 파일과 App.tsx 파일도 각각 아래처럼 수정해준다. SearchList.tsx SearchList.tsx12345678910111213141516import React from &quot;react&quot;;import SearchItem from &quot;./SearchItem&quot;;const SearchList = (props: { searchData: [] }) =&gt; { const { searchData } = props; return ( &lt;div className=&quot;card-list&quot;&gt; {searchData.map((item: any, idx: number): JSX.Element =&gt; { return &lt;SearchItem key={idx} item={item} /&gt;; })} &lt;/div&gt; );};export default SearchList; App.tsx App.tsx123456789101112131415161718192021222324252627import React, { useState } from &quot;react&quot;;import SearchForm from &quot;./components/SearchForm&quot;;import SearchList from &quot;./components/SearchList&quot;;import &quot;./App.css&quot;;function App() { const [searchData, setSearchData] = useState&lt;any&gt;([]); const getData = (keyword: string) =&gt; { console.log(&quot;검색 키워드: &quot; + keyword); fetch(`api/data?keyword=${keyword}`) .then((res) =&gt; { return res.json(); }) .then((data) =&gt; { setSearchData(data); console.log(data); }); }; return ( &lt;div className=&quot;App&quot;&gt; &lt;SearchForm getData={getData} /&gt; &lt;SearchList searchData={searchData} /&gt; &lt;/div&gt; );}export default App; 과정을 살펴보자, 서버에서 응답값이 오면 App.tsx의 15번째 라인에서 받고 이것을 SearchList 컴포넌트에 전달해 준다. SearchList.tsx를 보면 이 응답값을 props로 전달받았으며, 이 값은 배열이기 때문에 Array.map 메서드를 사용하여 SearchItem 컴포넌트를 리턴하고 있다. 이렇게 리턴받은 SearchItem 컴포넌트는 SearchItem.tsx 파일의 코드처럼, 카테고리, 제목, 본문내용, 링크를 출력하고 있는걸 확인할 수 있다. 스타일 꾸며주기CSS 적용이 안되었기 때문에 실제 화면은 이상하게 보일것이다. App.css 파일에 간단히 스타일을 추가해 주자. App.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.App { margin: 0 auto; max-width: 500px; padding: 10px;}.App .form { position: relative; margin-bottom: 10px;}.App .form-text { border: 1px solid #e0e0e0; border-radius: 5px; box-sizing: border-box; padding: 0 65px 0 5px; width: 100%; height: 35px; box-shadow: 0 0 5px rgba(0, 0, 0, 0.2); outline: none;}.App .form-btn { position: absolute; top: 0; right: 0; border: none; border-radius: 0 5px 5px 0; width: 60px; height: 35px; background-color: #13424b; color: #fff;}.App .card-list { column-count: 2; column-gap: 10px; margin-top: 10px; padding: 0;}.App .card { display: inline-block; position: relative; margin: 0 0 10px; border: 1px solid #e0e0e0; border-radius: 5px; word-break: break-all; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);}.App .card .top { border-radius: 5px 5px 0 0; padding: 10px; background-color: #13424b; color: #fff;}.App .card .top .kategorie { font-size: 11px;}.App .card .top .title { margin-top: 5px; font-weight: bold;}.App .card .bottom { padding: 10px; font-size: 13px;}.App .card .bottom .link { display: inline-block; margin-top: 10px; padding: 3px 5px; border-radius: 3px; text-decoration: none; background-color: #e5e5e5; color: #000;} 추가 화면 및 비활성 처리마무리 단계이며, 아래 단계가 남았다. 검색하는 동안 출력될 화면 추가 검색하는 동안 폼 비활성(disable) 처리 검색결과 없는 경우 추가 SearchLoading.tsx 파일을 생성하고 아래처럼 입력해 준다. 이 컴포넌트가 검색하는 동안 보여지는 부분이다. SearchLoading.tsx12345678910import React from &quot;react&quot;;const SearchLoading = (props: { isOnLoading: boolean }) =&gt; { const { isOnLoading } = props; return ( &lt;div className={isOnLoading ? &quot;loading on&quot; : &quot;loading&quot;}&gt;loading..&lt;/div&gt; );};export default SearchLoading; 그리고 SearchForm.tsx, SearchList.tsx, App.tsx, App.css 파일들을 아래처럼 코드를 수정한다. SearchForm.tsx SearchForm.tsx123456789101112131415161718192021222324252627282930313233343536373839import React, { useState } from &quot;react&quot;;const SearchForm = (props: { getData: any; isOnLoading: boolean }) =&gt; { const { getData, isOnLoading } = props; const [keyword, setKeyword] = useState(&quot;&quot;); return ( &lt;div className={isOnLoading ? &quot;form disable&quot; : &quot;form&quot;}&gt; &lt;input type=&quot;text&quot; className=&quot;form-text&quot; disabled={isOnLoading ? true : false} onChange={(e: any) =&gt; { setKeyword(e.target.value); }} onKeyPress={(e: any) =&gt; { if (e.charCode === 13) { if (keyword) { getData(keyword); } } }} /&gt; &lt;button type=&quot;button&quot; className=&quot;form-btn&quot; disabled={isOnLoading ? true : false} onClick={() =&gt; { if (keyword) { getData(keyword); } }} &gt; search &lt;/button&gt; &lt;/div&gt; );};export default SearchForm; SearchList.tsx SearchList.tsx123456789101112131415161718192021222324import React from &quot;react&quot;;import SearchItem from &quot;./SearchItem&quot;;const SearchList = (props: { searchData: []; isOnLoading: boolean }) =&gt; { const { searchData, isOnLoading } = props; return ( &lt;div className={isOnLoading ? &quot;card-list disable&quot; : &quot;card-list&quot;}&gt; {searchData.map( (item: any, idx: number): JSX.Element =&gt; { if (item.kategorie &amp;&amp; item.kategorie &amp;&amp; item.text) { return &lt;SearchItem key={idx} item={item} /&gt;; } else { return ( &lt;div key={idx} className=&quot;none&quot;&gt; 검색결과 없음 &lt;/div&gt; ); } } )} &lt;/div&gt; );};export default SearchList; App.tsx App.tsx1234567891011121314151617181920212223242526272829303132import React, { useState } from &quot;react&quot;;import SearchForm from &quot;./components/SearchForm&quot;;import SearchLoading from &quot;./components/SearchLoading&quot;;import SearchList from &quot;./components/SearchList&quot;;import &quot;./App.css&quot;;function App() { const [searchData, setSearchData] = useState&lt;any&gt;([]); const [isOnLoading, setIsOnLoading] = useState(false); const getData = (keyword: string) =&gt; { setIsOnLoading(true); console.log(&quot;검색 키워드: &quot; + keyword); fetch(`api/data?keyword=${keyword}`) .then((res) =&gt; { return res.json(); }) .then((data) =&gt; { setSearchData(data); setIsOnLoading(false); console.log(data); }); }; return ( &lt;div className=&quot;App&quot;&gt; &lt;SearchForm getData={getData} isOnLoading={isOnLoading} /&gt; &lt;SearchLoading isOnLoading={isOnLoading} /&gt; &lt;SearchList searchData={searchData} isOnLoading={isOnLoading} /&gt; &lt;/div&gt; );}export default App; App.css App.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495.App { margin: 0 auto; max-width: 500px; padding: 10px;}.App .form { position: relative; margin-bottom: 10px;}.App .form-text { border: 1px solid #e0e0e0; border-radius: 5px; box-sizing: border-box; padding: 0 65px 0 5px; width: 100%; height: 35px; box-shadow: 0 0 5px rgba(0, 0, 0, 0.2); outline: none;}.App .form-btn { position: absolute; top: 0; right: 0; border: none; border-radius: 0 5px 5px 0; width: 60px; height: 35px; background-color: #13424b; color: #fff;}.App .form.disable .form-btn { background-color: #b3b3b3;}.App .card-list { column-count: 2; column-gap: 10px; margin-top: 10px; padding: 0;}.App .card { display: inline-block; position: relative; margin: 0 0 10px; border: 1px solid #e0e0e0; border-radius: 5px; word-break: break-all; box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);}.App .card .top { border-radius: 5px 5px 0 0; padding: 10px; background-color: #13424b; color: #fff;}.App .card-list.disable .top { background-color: #b3b3b3;}.App .card .top .kategorie { font-size: 11px;}.App .card .top .title { margin-top: 5px; font-weight: bold;}.App .card .bottom { padding: 10px; font-size: 13px;}.App .card .bottom .link { display: inline-block; margin-top: 10px; padding: 3px 5px; border-radius: 3px; text-decoration: none; background-color: #e5e5e5; color: #000;}.App .card-list.disable .link { color: #fff;}.App .card-list .none { font-size: 13px;}.App .loading { overflow: hidden; text-align: center; height: 0; line-height: 18px; font-size: 0; transition: 0.3s;}.App .loading.on { font-size: 13px; height: 20px;} 검색 시작 및 끝을 나타내는 값컴포넌트에 검색중 여부 전달코드를 하나씩 살펴보자. App.tsx 파일의 9번째 라인을 보면 isOnLoading값이 있는데 요청을 보내면 12번째 라인에서 true로 변경, 검색중을 나타내고, 응답을 받으면 20번째 라인에서 false로 변경되며 검색이 끝났다는 것을 의미한다. 이 값을 SearchForm, SearchLoading, SearchList 컴포넌트에 전달해 주었다. 컴포넌트에서 검색중 여부 처리SearchLoading.tsx 파일 6번째 라인을 보면 isOnLoading가 true일 경우 on 클래스를 추가해 준다. 평상시에 이 엘리먼트는 보이지 않다가 on 클래스가 추가되면 보여지도록 App.css에 설정되어있다. 다른 컴포넌트도 마찬가지로 SearchForm.tsx에서 11번째 라인을 보면 isOnLoading이 true면 폼들은 disabled 처리가 되며, 7번째 라인에서 disable 클래스를 주고있다. SearchList.tsx 컴포넌트도 검색중이면 disable 클래스를 주고있으며, 이 클래스로 검색중에 스타일을 변경하도록 App.css에 설정되어있다. 검색결과 없는 경우SearchList.tsx파일의 10번째 라인을 보면 전달받은 데이터 값이 모두 있을경우 데이터를 노출하고 없는 경우는 검색결과가 없다는 내용을 출력하고 있다. 배포하기이제 로컬에서 작업한 결과물을 헤로쿠에 배포를 해보자. 깃 초기화헤로쿠는 깃을 통해 업로드하기 때문에 루트 경로에서 아래 명령어로 깃을 초기화 해준다. TERMINAL1$ git init 빌드 설정정적 파일 생성client 디렉토리에서 아래 명령어를 입력해 배포용 정적 파일을 생성한다. TERMINAL1$ npm run build 정적 파일 경로 설정다음에 index.js 파일 최하단에 아래 코드를 추가해준다. index.js123456789101112// ... 기존 코드// path 모듈 불러오기const path = require('path');// 리액트 정적 파일 제공app.use(express.static(path.join(__dirname, 'client/build')));// 라우트 설정app.get('*', (req, res) =&gt; { res.sendFile(path.join(__dirname+'/client/build/index.html'));}); 헤로쿠 빌드 명령어 설정루트경로의 package.json 파일로 가서 heroku-postbuild를 아래처럼 추가해준다. package.json1234567&quot;scripts&quot;: { &quot;start&quot;: &quot;nodemon index.js&quot;, &quot;dev&quot;: &quot;concurrently \\&quot;npm run dev:server\\&quot; \\&quot;npm run dev:client\\&quot;&quot;, &quot;dev:server&quot;: &quot;npm start&quot;, &quot;dev:client&quot;: &quot;cd client &amp;&amp; npm start&quot;, &quot;heroku-postbuild&quot;: &quot;cd client &amp;&amp; npm install &amp;&amp; npm run build&quot;} 헤로쿠 연동하기헤로쿠에 대한 간략한 설명은 [이 포스팅]https://recordboy.github.io/2020/11/05/express-react-heroku-init/)을 참고하면 된다. 기존에 회원이 아니면 헤로쿠 홈페이지에서 회원가입을 하고 이곳에서 헤로쿠 CLI를 설치하면 된다. 로그인 및 프로젝트 생성아래 명령어를 입력하고 아무키나 입력하면 로그인 하라는 브라우저가 뜨고 로그인을 해주자. TERMINAL1$ heroku login 아래 명령어로 헤로쿠에 프로젝트를 생성하며 프로젝트 이름은 다른 프로젝트와 중복되지 않게 정한다. git remote -v 명령어로 저장소가 제대로 연결되었는지 확인한다. TERMINAL12$ heroku create 프로젝트이름$ git remote -v 헤로쿠 프로젝트 주소와 로컬에서 바라보는 주소가 다를경우 $ git remote set-url heroku 프로젝트주소 명령어를 사용하여 동일하게 맞춰주면 된다. 빌드팩 추가한가지 또 추가해줘야 하는 것이 있는데 Puppeteer를 헤로쿠에서 사용하려면 프로젝트에 빌드팩을 추가해줘야 한다. 아래 명령어를 입력해주자. TERMINAL123$ heroku buildpacks:clear$ heroku buildpacks:add --index 1 https://github.com/jontewks/puppeteer-heroku-buildpack$ heroku buildpacks:add --index 1 heroku/nodejs 그리고 index.js 파일로 가서 34번째 라인의 브라우저 실행 옵션에 args값을 아래처럼 추가해 준다. index.js123456789// 브라우저 실행 및 옵션, 현재 옵션은 headless 모드 사용 여부const browser = await puppeteer.launch({ headless: true, args: [ &quot;--no-sandbox&quot;, &quot;--disable-setuid-sandbox&quot;, &quot;--window-size=1600,2000&quot;, ]}); 업로드이제 배포를 위한 모든 준비가 끝났다. 깃 명령어를 입력하여 푸쉬해주자. TERMINAL123$ git add .$ git commit -m '커밋 메세지'$ git push heroku master 이제 배포된 페이지를 확인해 보자. url은 https://프로젝트이름.herokuapp.com/로 가면 확인할 수 있다. 정상적으로 배포된 페이지를 화인할 수 있다. 지금까지 만들어본건 검색하는 기능만 있는 아주 기본적인 형태이지만 잘만 활용하면 요청, 응답값으로 여러가지 형태로 발전시킬 수 있다. 예를들어 검색 포탈명을 요청해 여러 포탈의 검색결과를 한번에 찾아보거나 각 다음 페이지를 넘기는 index값을 응답을 받아 검색 로딩시간을 알아보는 등 여러가지 활용이 가능하다. 마지막으로 주의할 점이 있는데, 헤로쿠 서버의 무료 용량은 500MB로 제한된다. Puppeteer는 자체적으로 Chromium을 내장하고 있는데 이것이 꽤 용량이 나간다.(대략 300MB 조금 넘게) 그래서 프로젝트를 크게 불려 배포를 하면 가끔 용량이 부족하다고 에러가 나오는 경우가 있다. 또 한가지는 Puppeteer를 많이 사용하다보면 구글에서 봇으로 판단하여 ‘로봇이 아닙니다’ 체크를 해야하는 경우도 있었다. 아무튼 Puppeteer는 크롤링 말고 여러가지 강력한 기능이 있기 때문에 잘 활용하면 좋은 도구가 될 수 있을 것이다. References PuppeteerPuppeteer unable to run on heroku","link":"/2021/04/30/puppeteer-search/"},{"title":"[React] 리액트 소개","text":"리액트는 페이스북이 제작한 프론트엔드 라이브러리이다. 프론트엔드 프레임워크/라이브러리는 대표적으로 React, Angular, Vue 이렇게 세가지가 있다. 종류Angular UI를 구현하게 되면서, 앵귤러만의 문법같은 것들이 다양하게 존재 라우터, HTTP 클라이언트 등 웹 프로젝트에서 필요한 대부분의 도구들이 프레임워크 안에 내장되어 있음 앵귤러1의 경우 만들어진지 꽤 오래 되었고, 기업에서 많이 사용해서, 유지보수하고 있는 프로젝트가 많음 앵귤러2의 경우 매우 성숙하지만, 인지도 측면에서는 아직 성장하는중이며, 주로 타입스크립트랑 함께 사용됨 React 컴포넌트(UI를 조립해서 보여줌)라는 개념에 집중이 되어있는 라이브러리 생테계가 넒고 사용하는 곳도 많음 HTTP 클라이언트, 라우터, 심화적 상태 관리등의 기능들은 내장되어있지 않음, 따로 공식 라이브러리가 있는 것도 아니여서, 개발자가 원하는 스택을 마음대로 골라서 사용할 수 있음(혹은 직접 라이브러리를 만들어서 쓸 수도 있음) 큰 규모의 앱을 만든다면 React Vue 입문자가 사용하기에 적합함 대부분 웹팩같은 모듈 번들러를 사용하여 프로젝트를 구성해야하는 앵귤러와 리액트와는 달리, 다순히 CDN에 있는 파일을 로딩하는 형태로 스크립트를 불러와서 사용하기 편리(물론 CLI로 프로젝트를 구성할 수 있음) HTML을 템플릿처럼 그대로 사용할 수 있어 마크업을 만들어주는 디자이너/퍼블리셔가 있는 경우 작업 환경이 매끄러움(Templates 형식으로 앱 제작) 공식 라우터, 상태관리 라이브러리가 존재 빠르고 경량의 앱을 제작하고 싶다면 Vue 쓰는 이유웹사이트를 만들기 위해선 굳이 프로트엔드 라이브러리의 도움 없이 만들 수 있다. 더군다나 정직인 웹사이트는 HTML, CSS만 사용하여 제작이 가능하다. 거기에 자바스크립트를 더해주면, 유저의 행동에 따라 동적으로 화면을 보여주게 될 것이다. 하지만 프로젝트 규모가 커지고, 다양한 유저 인터페이스를 제공하게 된다면, 그 많은 DOM 요소들을 직접 관리하고 코드 정리하는건 갈수록 정말 힘든 일이 될 것이다. 귀찮은 DOM 관리와 상태값 업데이트를 최소화하고, 오직 개발, 그리고 사용자 인터페이스를 구현하는 것에 집중할 수 있다록 하기 위하여 여러개의 라이브러리/프레임워크들이 만들어 졌다. 무엇을 써야 하나답은 정해져 있지 않다. 어떠한 프로젝트를 하냐에 따라 알맞은 프레임워크/라이브러리를 선택하면 된다. 이 포스팅에서는 리액트에 대해 알아 볼 것이다. References 누구든지 하는 리액트 1편: 리액트는 무엇인가React 인가 Vue 인가?","link":"/2020/03/05/react-introduce/"},{"title":"[React] 리액트 JSX","text":"JSX란 자바스크립트를 확장한 문법이다. 얼핏 보면 HTML과 비슷하여 템플릿 언어가 떠오를 수도 있지만, 자바스크립트의 모든 기능이 포함되어 있다. JSX를 제대로 사용하기 위해서 몇가지 규칙을 준수해줘야 한다. 이전 포스팅 [React] React 시작하기에 나온 App.js파일에 예제를 작성하여 진행하겠다. 기존의 코드는 지우고 클래스 방식으로 컴포넌트를 만들어준 뒤 아래 예제들을 살펴보겠다. 12345678910111213import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; &lt;/div&gt; ); }}export default App; JSX 엘리먼트 규칙태그는 꼭 닫혀줘야 된다.&lt;div&gt;를 열었으면 꼭&lt;/div&gt;로 태그를 닫아주도록 한다. 또한 input이나 br태그 같은 단일 태그들은 HTML5에서 안닫아도 상관 없었지만, 리액트에서는 오류를 출력하므로 꼭 태그를 닫아주도록 한다. 12345678910111213import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; &lt;input type=&quot;text&quot;&gt; // error &lt;/div&gt; ); }}export default App; 하나의 엘리먼트로 감싸줘야 한다.리턴값이 두개의 엘리먼트로 되어있으면 오류를 출력한다. 12345678910111213141516import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; // error my &lt;/div&gt; &lt;div&gt; app &lt;/div&gt; ); }}export default App; 위 문제를 해결하기 위해서 두개의 엘리먼트를 하나의 엘리먼트로 감싸야 한다. 하나의 엘리먼트로 감싸기 까다로운 경우하지만 위처럼 하나의 엘리먼트로 감싸기엔 까다로운 경우가 있다. CSS로 인한 스타일 관련 문제나 table관련 태그를 작성할 때 번거로운 경우이다. 이럴때는 아래처럼 Fragment을 사용하면 된다.(이 기능은 v.16.2에 도입되었다.) 123456789101112131415161718import React, { Component, Fragment } from 'react';class App extends Component { render() { return ( &lt;Fragment&gt; &lt;div&gt; my &lt;/div&gt; &lt;div&gt; app &lt;/div&gt; &lt;/Fragment&gt; ); }}export default App; 나눠진 엘리먼트를 Fragment로 감싼뒤 import의 { Component }에 Fragment을 추가하면 된다. JSX 자바스크립트 사용하기변수 사용하기JSX 내부에서 변수를 사용 할 땐 아래처럼 할 수 있다. 123456789101112131415import React, { Component } from 'react';class App extends Component { render() { const name = 'my-app'; console.log(1) return ( &lt;div&gt; hello {name} // hello my-app &lt;/div&gt; ); }}export default App; JSX 내부에 {}(중괄호)안에 자바스크립트 구문을 넣어 주면 된다. 조건부 렌더링JSX 내부에서 조건부 렌더링을 할 때는 보통 삼항 연산자를 사용하거나, AND연산자(&amp;&amp;)를 사용한다. 반면에 if문은 사용할 수 없으며, 사용하려면 즉시함수를 실행해야 한다. 삼항연산자1234567891011121314151617import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; { 1 + 1 === 2 // 참 ? &lt;div&gt;참&lt;/div&gt; : &lt;div&gt;거짓&lt;/div&gt; } &lt;/div&gt; ); }}export default App; AND연산자12345678910111213141516import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; { 1 + 1 === 2 // 참 &amp;&amp; &lt;div&gt;참&lt;/div&gt; } &lt;/div&gt; ); }}export default App; 참고로 AND연산자의 경우 true일때만 값을 보여주고, false일때는 아무것도 보여주지 않는다. if문123456789101112131415161718192021import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; { (function(){ if (1 + 1 === 2) { // 참 return &lt;div&gt;참&lt;/div&gt; } else { return &lt;div&gt;거짓&lt;/div&gt; } })() } &lt;/div&gt; ); }}export default App; 위처럼 JSX 내부에서 로직을 작성할 수 있지만 복잡한 로직을 작성해야 할 때는 JSX 밖에서 로직을 작성하는 것이 좋다. 하지만 꼭 JSX 내부에서 작성해야 한다면 위처럼 즉시실행함수를 사용하면 된다. style과 classNameJSX에서 CSS와 class명은 HTML에서 작성하는 방법과 약간 다르다. 12345678910111213141516171819import React, { Component } from 'react';class App extends Component { render() { const style = { padding: '10px', fontSize: '15px', fontWeight: 'bold', backgroundColor: 'yellow' }; return ( &lt;div style={style}&gt; my-app &lt;/div&gt; ); }}export default App; HTML에서는 그냥 텍스트 형태로 =&quot;padding: 10px; font-size: 15px;&quot; 이런 형태로 작성하였다면 리액트에서는 객체 형태로 작성해줘야 한다. 그리고 class는 class대신에 className을 사용한다. 12345678910111213import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div className=&quot;App&quot;&gt; my-app &lt;/div&gt; ); }}export default App; 주석주석은 아래처럼 {/* 내용 */} 사이에 넣거나, 태그 사이에 넣을 수 있다. 1234567891011121314151617import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; {/* 주석 내용 */} &lt;div // 태그 사이에 주석 내용 &gt;my-app &lt;/div&gt; &lt;/div&gt; ); }}export default App; References 누구든지 하는 리액트 3편: JSXJSX 소개","link":"/2020/03/07/react-jsx/"},{"title":"[React] 리액트 데이터 관리(Props, State)","text":"리액트에서 다루는 데이터는 두개로 나뉜다. 바로 props와 state인데, 요약하자면 props는 부모 컴포넌트가 자식 컴포넌트에게 주는 값이다. 자식 컴포넌트에서는 props를 받아오기만 하고, 받아온 props를 직접 수정할 수는 없다. 자식 입장에서 읽기 전용인 데이터이다. 반면에 state는 컴포넌트 내부에서 선언하며, 내부에서 값을 변경할 수 있다. 자신이 들고있는 값이며 props와 비교한다면, 쓰기 전용이라고 볼 수 있다. props예제를 통해 props과 state를 알아보겠다. src디렉토리에 components디렉토리를 생성한 뒤 컴포넌트를 MyNmae.js파일을 만든 후 MyName컴포넌트를 추가하도록 하겠다. 1234567891011import React, { Component } from 'react';class MyName extends Component { render() { return( &lt;span&gt;{this.props.name}&lt;/span&gt; ) }}export default MyName; 자신이 받아온 props의 값은 this 키워드를 통해 조회할 수 있다. App.js파일을 아래와 같이 수정하겠다. 1234567891011121314import React, { Component } from 'react';import MyName from './components/MyName';class App extends Component { render() { return ( &lt;div&gt; this is &lt;MyName name=&quot;my-app&quot; /&gt; {/* this is my-app */} &lt;/div&gt; ); }}export default App; 화면에 this is my-app라고 출력되는 것을 확인할 수 있다. MyName컴포넌트는 부모 컴포넌트인 App컴포넌트안의 MyName에서 선언한 name값을 this.props.name구문을 이용하여 값을 가져오고 있다. defaultProps특정한 상황에 props를 일부러 비워야 할 때가 있다. 그러한 경우에 props의 기본 값을 설정해 줄 수 있는데, 그것이 defaultProps이다. 1234567891011121314import React, { Component } from 'react';class MyName extends Component { static defaultProps = { name: 'basic-app' } render() { return( &lt;span&gt;{this.props.name}&lt;/span&gt; ) }}export default MyName; MyName컴포넌트의 render함수 위에 defaultProps를 이용해 기본값을 선언해 준 뒤 App컴포넌트의 MyName의 name값을 지워주면 결과가 name의 기본 값인 this is basic-app로 보여진다. 1234567891011121314import React, { Component } from 'react';import MyName from './components/MyName';class App extends Component { render() { return ( &lt;div&gt; this is &lt;MyName /&gt; {/* this is basic-app */} &lt;/div&gt; ) }}export default App; statestate는 위에서 쓰기 전용이라고 말한 것처럼 동적인 데이터를 다룰 때 사용된다. Counter라는 새로운 컴포넌트를 만들어 대략적으로 데이터를 어떻게 다루는지 알아보겠다. 12345678910111213141516171819202122232425262728293031import React, { Component } from 'react';class Counter extends Component { state = { number: 0 } handleIncrease = () =&gt; { this.setState({ number: this.state.number + 1 }) } handleDecrease = () =&gt; { this.setState({ number: this.state.number - 1 }) } render() { return ( &lt;div&gt; &lt;div&gt;값: {this.state.number}&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={this.handleIncrease}&gt;+&lt;/button&gt; &lt;button type=&quot;button&quot; onClick={this.handleDecrease}&gt;-&lt;/button&gt; &lt;/div&gt; ) }}export default Counter; 위 코드를 보면 state 정의는 class fields문법으로 정의되었으며, class fields문법을 사용하지 않는다면 아래와 같이 사용하면 된다. class fields를 사용하는 이유는 편의를 위함이다. 123456789101112131415161718import React, { Component } from 'react';class Counter extends Component { constructor(props) { super(props) this.state = { number: 0 } } // state = { // number: 0 // } ...} 컴포넌트에서 메서드 작성컴포넌트에서 메서드를 작성할 때 아래와 같이 화살표 함수로 작성된 것을 확인할 수 있다. 123456handleIncrease = () =&gt; { this.setState({ number: this.state.number + 1 }) console.log(this); // Counter} 위 화살표 함수로 작성된 메서드는 컴포넌트 안에서 아래와 같은 형식으로도 작성할 수 있는데, 이렇게 하면, 이벤트가 발생했을 때, this가 undefined로 나타나서 제대로 처리가 되지 않는다. 123456handleIncrease() { this.setState({ number: this.state.number + 1 // TypeError }) console.log(this); // undefined} 이는 함수가 버튼의 클릭이벤트로 전달이 되는 과정에서 this와의 연결이 끊켜버리기 때문인데, 이를 고쳐주려면 constructor에서 아래처럼 추가해주거나 화살표 함수 형태로 하면 this가 풀리는 것을 해결할 수 있다. 12345constructor(props) { super(props); this.handleIncrease = this.handleIncrease.bind(this); this.handleDecrease = this.handleDecrease.bind(this);} 값 업데이트(setState)각 메서드에 들어있는 this.setState는 state값을 바꾸기 위해서 받드시 사용해야 하는데, 리액트에서는 이 함수가 호출되면 컴포넌트가 리렌더링 되도록 설계되어 있기 때문이다. setState의 몇가지 특징을 알아보겠다. setState는, 객체로 전달되는 값만 업데이트를 해준다.지금은 state에 number값만 있지만 만약 다음과 같은 값이 있다고 가정을 해본다. 1234state = { number: 0, foo: 'bar'} 이벤트에 this.setState({ number: 1 });을 전달해주면, foo는 그대로 남고, number값만 업데이트가 된다. setState는 객체의 깊숙한곳 까지 확인하지 못한다.예를 들어, state가 다음과 같이 설정되어 있다고 보자 1234567state = { number: 0, foo: { bar: 0, foobar: 1 }} 아래와 같이 전달한다고 해서 foobar값이 2로 바뀌지 않는다. 12345this.setState({ foo: { foobar: 2 }}) 위처럼 하면 foobar값이 2로 바뀌지 않고 기존의 foo객체 자체가 바뀌어버린다. 1234567{ number: 0, foo: { // bar 값이 없다. foo 객체 자체가 바뀌었기 때문이다. foobar: 2 }} 위와 같은 상황에서는 아래처럼 작성해 줘야 한다. 1234567this.setState({ number: 0, foo: { ...this.state.foo, foobar: 2 }}) 위 구문중 ...는 전개연산자이다. 기존의 객체안에 있는 내용을 해당 위치에 풀어준다는 의미다. 그 다음에 설정하고 싶은 값을 넣어주면 해당 값을 덮어 쓰게 된다. setState에 객체 대신 함수 전달하기setState로 값을 업데이트 할 때, 기존은 객체를 전달하여 값을 업데이트한다면 함수를 전달하는 방법도 있다. 기존 코드는 아래와 같다. 123this.setState({ number: this.state.number + 1}) 큰 문제는 아니지만, 굳이 또 this.state를 조회해야 하는데, 아래 처럼 함수를 전달하여 값을 바꿀수도 있다. 12345this.setState( (state) =&gt; ({ number: state.number + 1 })) 이 방법 말고 더 나아가 아래처럼 작성할 수도 있다. 12345this.setState( ({ number }) =&gt; ({ number: number + 1 })) 보면 (state)가 ({ number })가 되었는데, 이는 비구조화 할당이라는 문법이다. 이 문법은 아래와 같은 방식으로도 사용할 수 있다. 1const = { number } = this.state 결국 코드를 조금 사용하고 싶다면 아래처럼 작성하면 된다. 1234const { number } = this.state;this.setState({ number: number + 1}) 이벤트 설정render함수에서 이벤트 설정한 부분을 확인해 보겠다. 123456789render() { return ( &lt;div&gt; &lt;div&gt;값: {this.state.number}&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={this.handleIncrease}&gt;+&lt;/button&gt; &lt;button type=&quot;button&quot; onClick={this.handleDecrease}&gt;-&lt;/button&gt; &lt;/div&gt; );} 버튼이 클릭되면 등록된 함수가 각각 호출되도록 설정되었다. 기존에 자바스크립트로 버튼에 이벤트를 걸어줄 때는 아래처럼 설정을 했을 것이다. 1&lt;button type=&quot;button&quot; onclick=&quot;alert('hello world')&quot;&gt;click&lt;/button&gt; 기존 html로 작성된 코드는 onclick 속성에 자바스크립트를 문자열 형태로 넣어줬지만, jsx로 작성된 코드는 약간 다르다. 1&lt;button type=&quot;button&quot; onClick={this.handleIncrease}&gt;+&lt;/button&gt; 몇가지 다른 사항은 아래와 같다. 이벤트 이름을 설정할 때는 camelCase로 설정해주어야 한다. 예를들어 onclick은 onClick으로 설정 한다. 이벤트에 전달되는 값은 함수여야 한다. 주의사항이 있는데 함수를 onClick={this.handleIncrease()}라고 함수 호출식으로 작성하게 된다면 렌더링 할 때 마다 해당 함수가 호출되어 무한반복이 되버린다. 렌더링 함수에서 이벤트를 설정할 때는 꼭 메서드를 호출하지 말도록 한다. 결과 화면App.js파일도 아래처럼 수정해 준다. 123456789101112import React, { Component } from 'react';import Counter from './components/Counter';class App extends Component { render() { return( &lt;Counter /&gt; ) }}export default App; 이제 +, -버튼을 클릭해보면 값이 정상적으로 증가, 감소하는 것을 확인할 수 있다. References 누구든지 하는 리액트 4편: props 와 stateReact 기억법(4) - React 필수요소 props, state","link":"/2020/03/08/react-props-state/"},{"title":"[React] 리액트로 전화번호부 만들기","text":"리액트로 간단한 전화번호부를 만들어 보자, 우선 새로운 리액트 프로젝트를 만들고, 로컬 서버를 시작한다. 프로젝트 이름은 phone-book으로 하겠다. 프로젝트 초기화123$ create-react-app phone-book --use-npm$ cd phone-book$ npm server App.js 파일을 열어 필요없는 코드를 전부 지워준 뒤 App 컴포넌트만 추가해 본다. 1234567import React, { Component } from 'react';class App extends Component { render() { return &lt;div&gt;hello&lt;/div&gt;; }}export default App; http://localhost:3000에 들어가보면 hello 라고 정상적으로 출력 될 것이다. 이제 본격적으로 하위 컴포넌트를 만들어 App.js에 연결해 보겠다. 입력 폼 컴포넌트 추가src 디렉토리 내부에 components 디렉토리를 만든 뒤 그 안에 PhoneForm.jsx 파일을 만든 뒤 아래 코드를 입력한다. 이름 인풋 값 state에 할당1234567891011121314151617181920import React, { Component } from 'react';class PhoneForm extends Component { state = { name: '', }; handleChange = (e) =&gt; { this.setState({ name: e.target.value, }); }; render() { return ( &lt;form&gt; &lt;input type=&quot;text&quot; onChange={this.handleChange} /&gt; &lt;div&gt;name: {this.state.name}&lt;/div&gt; &lt;/form&gt; ); }}export default PhoneForm; 코드를 살펴보면, 우선 인풋태그의 onChange 이벤트가 발생하면 handleChange 함수를 실행하게 된다. 이벤트 객체를 파라미터로 받은 handleChange 함수는 e.target.value값을 통해 인풋 요소의 값을 가져와서 state의 name값을 설정하게 된다. 인풋태그 아래 텍스트가 state의 값이 잘 바뀌고 있는지 확인할 수 있게 해준다. App컴포넌트에 연결App.js 파일에 PhoneForm 컴포넌트를 아래와 같이 연결해 준다. 123456789101112import React, { Component } from 'react';import PhoneForm from './components/PhoneForm';class App extends Component { render() { return ( &lt;div&gt; &lt;PhoneForm /&gt; &lt;/div&gt; ); }}export default App; 인풋 태그에 값을 입력할 때 마다 아래에 입력값이 출력되는 것을 확인할 수 있다. 전화번호 인풋 태그 추가전화번호가 들어갈 phone 인풋태그를 더 추가한다. 아래 코드를 살펴보자 1234567891011121314151617181920212223import React, { Component } from 'react';class PhoneForm extends Component { state = { name: '', phone: '', }; handleChange = (e) =&gt; { this.setState({ [e.target.name]: e.target.value, }); }; render() { return ( &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; onChange={this.handleChange} /&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; onChange={this.handleChange} /&gt; &lt;div&gt;name: {this.state.name}&lt;/div&gt; &lt;div&gt;phone: {this.state.phone}&lt;/div&gt; &lt;/form&gt; ); }}export default PhoneForm; phone 인풋태그가 추가되었으니 해당 값을 가져오는 이벤트 핸들러 함수를 하나 더 만들어야 될 것 같지만 Computed property names문법을 사용하면 따로 메서드를 추가 안하고 위처럼 작성이 가능하다. 우선 인풋 태그에 name 값을 추가 하여 각 인풋을 구분할 수 있게 되었다. setState 함수를 보면 [e.target.name]로 이벤트 객체의 name 값을 state의 키값으로 활용하고 있다. 즉 name 인풋을 입력하면 [e.target.name]값은 name이기 때문에 state의 name 프로퍼티에 e.target.value 값을 할당, phone 인풋을 입력하면 [e.target.name]값은 phone이기 때문에 state의 phone 프로퍼티에 e.target.value 값을 할당 한다고 보면 된다. 두 인풋 값이 하단에 잘 출력되는 것을 확인할 수 있다. 부모 컴포넌트에게 정보 전달하기PhoneForm 컴포넌트에 있는 값을 부모(App)컴포넌트에 값을 전달해줄 차례다. 이런 상황에는, 부모 컴포넌트에서 메서드를 만들고, 이 메서드를 자식에게 전달한 다음에 자식 내부에서 호출하는 방식을 사용한다. 순서를 보면 우선 App에서 handleCreate라는 메서드를 만들고 이를 props를 이용하여 PhoneForm 컴포넌트에 전달을 한다. 그리고 PhoneForm 컴포넌트에 submit 버튼을 추가하여 이벤트가 발생하면 props로 받은 함수를 호출하여 App에서 파라미터로 받은 값을 사용할 수 있도록 하겠다. 우선 App 컴포넌트는 아래와 같이 수정해 준다. 12345678910111213141516import React, { Component } from 'react';import PhoneForm from './components/PhoneForm';class App extends Component { handleCreate = (data) =&gt; { console.log(data); }; render() { return ( &lt;div&gt; &lt;PhoneForm onCreate={this.handleCreate} /&gt; &lt;/div&gt; ); }}export default App; handleCreate 함수를 추가했다. 이 함수는 자식 컴포넌트에서 전달받아오는 결과값을 콘솔창에 출력할 함수다. PhoneForm 컴포넌트에는 onCreate 라는 속성에 handleCreate 함수를 할당해 주었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, { Component } from 'react';class PhoneForm extends Component { state = { name: '', phone: '', }; handleChange = (e) =&gt; { this.setState({ [e.target.name]: e.target.value, }); }; handleSubmit = (e) =&gt; { // 이벤트 리로딩 방지 e.preventDefault(); // 상태값을 onCreate를 통하여 부모에게 전달 this.props.onCreate(this.state); // 상태 초기화 this.setState({ name: '', phone: '', }); }; render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value={this.state.name} onChange={this.handleChange} /&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; value={this.state.phone} onChange={this.handleChange} /&gt; &lt;button type=&quot;submit&quot;&gt;send&lt;/button&gt; &lt;/form&gt; ); }}export default PhoneForm; render 함수 안을 먼저 보면, submit 버튼을 추가하고, form태그에는 onSubmit 이벤트를 등록하였다. 인풋의 value 값은 현재 state 값을 참조하도록 하여 실시간으로 변경되는 값으로 할당되도록 하였다. state 값이 실시간으로 바뀌는지 확인하기 위한 인풋 아래 텍스트들은 삭제해준다. 메서드는 handleSubmit 함수를 추가하였는데, 우선 submit 이벤트가 발생하면 페이지가 리로드되기 때문에 함수가 실행될 때 e.preventDefault 함수를 이용하여 리로드를 막는다. 다음에 props으로 받은 onCreate 함수를 실행하여 현재 state 값을 전달해주고, 현재 값은 초기화 해준다. submit 버튼을 클릭하면 콘솔창에 전달받은 인풋값이 정상적으로 출력될 것이다. 데이터 추가PhoneForm 컴포넌트의 데이터를 부모 컴포넌트로 전달했으니 이제 부모 컴포넌트에 데이터를 계속 추가 하도록 하겠다. 리액트에서의 배열 다루기데이터 객체를 배열에 계속 추가하기 위해선 리액트에서 배열을 어떻게 다루는지 알아야 한다. 기존의 자바스크립트에서는 배열에 값을 추가할 때 push 메서드를 사용했었다. 예를 들어 arr 배열이 있다고 치자 123var arr = [1, 2, 3];arr.push(4);console.log(arr); // [1, 2, 3, 4] 기존 자바스크립트에서 배열에 값을 추가할때는 위처럼 하던것처럼 리액트에서도 this.state.arr.push('value'); 처럼 해도 된다고 생각할 수 있다. 하지만 리액트에서는 state 내부의 값을 직접적으로 수정하면 절대 안된다. 이를 불변성 유지라고 하는데, push, splice, unshift, pop 같은 내장함수는 배열 자체를 수정하므로 적합하지 않다. 대신 기존 배열에 기반하여 새 배열을 만들어내는 concat, slice, map, filter 같은 함수를 사용해야한다. 리액트에서 불변성 유지가 중요한 이유는 불변성을 유지해야, 리액트에서 모든것들이 필요한 상황에 리렌더링 되도록 설계할 수 있고, 그렇게 해야 나중에도 성능도 최적화 할 수 있기 때문이다. 배열 추가App 컴포넌트의 state에 information 이라는 배열을 만들고, 그 안에 배열의 기본값인 샘플 데이터 두개를 추가 할 것이다. 객체 형식은 아래와 같은 형식으로 작성한다. 12345{ id: 0, name: '한나', phone: '000-0000-0000'} 위에서 id 값은 각 데이터를 식별하기 위함이다. 이 값은 데이터를 추가할 때 마다 숫자를 1씩 더해주겠다. App 컴포넌트는 아래와 같이 작성한다. 12345678910111213141516171819202122232425262728293031323334353637import React, { Component } from 'react';import PhoneForm from './components/PhoneForm';class App extends Component { id = 2; state = { information: [ { id: 0, name: '한나', phone: '000-0000-0000', }, { id: 1, name: '민수', phone: '000-0000-0000', }, ], }; handleCreate = (data) =&gt; { const { information } = this.state; this.setState({ information: information.concat({ id: this.id++, ...data }), }); }; render() { const { information } = this.state; return ( &lt;div&gt; &lt;PhoneForm onCreate={this.handleCreate} /&gt; {JSON.stringify(information)} &lt;/div&gt; ); }}export default App; id 값의 경우, 컴포넌트의 일반 클래스 내부 변수로 선언하였다. 컴포넌트 내부에서 필요한 값 중에서 렌더링 되는 것과 상관이 없는 것들은 굳이 state에 넣어줄 필요가 없다. 그리고 handleCreate 함수에서 this.state의 information 배열은 비구조화 할당으로 값을 선언하였다. 그러므로 setState 함수의 구문은 아래와 같다고 볼 수 있다. 123this.setState({ information: this.state.information.concat({ id: this.id++, ...data })}); render 함수에서도 위와 같이 비구조와 할당으로 information 값을 선언하였으며, JSON.stringify()를 이용해 문자열로 변환하여 출력하였다. send 버튼을 클릭하면 배열에 전달된 데이터 객체가 제대로 출력되는 것을 확인할 수 있다. 1[{&quot;id&quot;:0,&quot;name&quot;:&quot;한나&quot;,&quot;phone&quot;:&quot;000-0000-0000&quot;},{&quot;id&quot;:1,&quot;name&quot;:&quot;민수&quot;,&quot;phone&quot;:&quot;000-0000-0000&quot;},{&quot;id&quot;:2,&quot;name&quot;:&quot;인성&quot;,&quot;phone&quot;:&quot;000-0000-0000&quot;}] 데이터 렌더링배열의 내장 함수인 map을 이용하여 information을 컴포넌트로 변환하여 출력하도록 하겠다. 컴포넌트 만들기두개의 컴포넌트를 만들 것이다. PhoneInfo: 각 전화번호 정보를 보여주는 컴포넌트 PhoneInfoList: 여러개의 PhoneInfo 컴포넌트를 보여줌 PhoneInfo 생성PhoneInfo.jsx 파일을 만들고 아래처럼 작성한다. 123456789101112131415161718192021222324252627import React, { Component } from 'react';class PhoneInfo extends Component { static defaultProps = { name: '이름', phone: '000-0000-0000', id: 0, }; render() { const style = { margin: '2px', border: '1px solid #ccc', padding: '2px', }; const { name, phone } = this.props.info; return ( &lt;div style={style}&gt; &lt;div&gt; &lt;b&gt;{name}&lt;/b&gt; &lt;/div&gt; &lt;div&gt;{phone}&lt;/div&gt; &lt;/div&gt; ); }}export default PhoneInfo; info 객체를 props으로 받아와서 렌더링을 할 것이다. 여기서 만약 info 객체에 값이 전달 안 될 경우 에러가 뜰 것이다. 위 코드에서 info 객체의 값을 비구조화 할당하고 있는데, info가 undefined 경우 내부의 값을 가져오지 못하기 때문이다. 때문에 위 코드에서 defaultProps를 이용하여 info의 기본값을 설정해준다. PhoneInfoList 생성다음에 PhoneInfoList 컴포넌트를 생성하고, 아래처럼 코드를 입력한다. 123456789101112131415import React, { Component } from 'react';import PhoneInfo from './PhoneInfo';class PhoneInfoList extends Component { static defaultProps = { data: [], }; render() { const { data } = this.props; const list = data.map((info) =&gt; &lt;PhoneInfo key={info.id} info={info} /&gt;); return &lt;div&gt;{list}&lt;/div&gt;; }}export default PhoneInfoList; 이 컴포넌트에서는 data라는 배열을 가져와서 map 함수를 이용하여 JSX로 변환을 해준다. 여기서 컴포넌트에 key라는 값도 설정되었는데, key 값은 리액트에서 배열을 렌더링 할 때 꼭 필요한 값이다. 리액트는 배열을 렌더링 할 때 값을 통하여 업데이트 성능을 최적화 한다. 아래 예시를 통해 살펴보겠다. 1234&lt;div&gt;A&lt;/div&gt;&lt;div&gt;B&lt;/div&gt;&lt;div&gt;C&lt;/div&gt;&lt;div&gt;D&lt;/div&gt; key 값을 설정하지 않으면 배열의 index 값이 자동으로 key 값으로 설정 된다. 때문에 각 요소마다 따로 키값을 설정하지 않으면 아래처럼 각 index 값이 키값으로 들어갈 것이다. 1234&lt;div key={0}&gt;A&lt;/div&gt;&lt;div key={1}&gt;B&lt;/div&gt;&lt;div key={2}&gt;C&lt;/div&gt;&lt;div key={3}&gt;D&lt;/div&gt; 위 요소들 중 B와 C사이에 X를 집어넣는다고 가정을 해보자. 12345&lt;div key={0}&gt;A&lt;/div&gt;&lt;div key={1}&gt;B&lt;/div&gt;&lt;div key={2}&gt;X&lt;/div&gt; C 가 X 로 바뀜&lt;div key={3}&gt;C&lt;/div&gt; D 가 C 로 바뀜&lt;div key={4}&gt;D&lt;/div&gt; D 는 새로 생성됨 보면 2 index 값으로 X 요소가 들어가면서 index 값이 밀리고, X 요소 이후 부터 값이 전부 바뀔 것이다. 각 요소를 index 값이 아닌 데이터를 추가 할 때마다 고유 값을 부여하면, 리액트가 변화를 감지하고 업데이트 할때 좀 더 효율적이게 처리를 할 수 있게 된다. 12345&lt;div key={0}&gt;A&lt;/div&gt;&lt;div key={1}&gt;B&lt;/div&gt;&lt;div key={4}&gt;X&lt;/div&gt; 새로 생성됨&lt;div key={2}&gt;C&lt;/div&gt; 유지됨&lt;div key={3}&gt;D&lt;/div&gt; 유지됨 새로운 요소 하나만 생성되고 나머지는 그대로 유지된다. key 값은 언제나 고유해야 한다. 실제 데이터베이스에도 데이터를 추가하면 해당 데이터를 가리키는 고유 id가 있다. 여기서는 각 요소의 고유 id를 key 값으로 사용하고 있다. PhoneInfoList 렌더링이제 PhoneInfoList 컴포넌트를 App 컴포넌트에 렌더링을 하고 data 값을 props으로 전달하면 된다. 12345678910111213141516171819202122232425262728293031323334353637import React, { Component } from 'react';import PhoneForm from './components/PhoneForm';import PhoneInfoList from './components/PhoneInfoList';class App extends Component { id = 2; state = { information: [ { id: 0, name: '한나', phone: '000-0000-0000', }, { id: 1, name: '민수', phone: '000-0000-0000', }, ], }; handleCreate = (data) =&gt; { const { information } = this.state; this.setState({ information: information.concat({ id: this.id++, ...data }), }); }; render() { return ( &lt;div&gt; &lt;PhoneForm onCreate={this.handleCreate} /&gt; &lt;PhoneInfoList data={this.state.information} /&gt; &lt;/div&gt; ); }}export default App; 확인해 보면 기존 데이터 렌더링 및 신규 데이터 추가도 확인해 볼 수 있다. 가끔 데이터에 고유 값이 없을 수도 있다. 그럴 경우에는 렌더링은 되지만 콘솔창에 경고창이 뜰 것이다. 꼭 배열을 렌더링 할 때는 고유의 key 값을 사용하도록 한다. 데이터 삭제이제 전화번호부에 등록된 데이터를 삭제할 코드를 작성하겠다. 배열에서 삭제 방법은 filter 메서드를 사용할 것이다. App 컴포넌트에 handleRemove 함수를 만들어 준뒤 아래처럼 코드를 수정한다. 삭제할 id 값을 받아와 filter 메서드를 사용하여 id 값이 일치하지 않는 값들을 state에 다시 세팅 할 것이다. 함수를 만들었으면 이것을 하위 컴포넌트인 PhoneInfoList에 전달한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, { Component } from 'react';import PhoneForm from './components/PhoneForm';import PhoneInfoList from './components/PhoneInfoList';class App extends Component { id = 2; state = { information: [ { id: 0, name: '한나', phone: '000-0000-0000', }, { id: 1, name: '민수', phone: '000-0000-0000', }, ], }; handleCreate = (data) =&gt; { const { information } = this.state; this.setState({ information: information.concat({ id: this.id++, ...data }), }); }; handleRemove = (id) =&gt; { const { information } = this.state; this.setState({ information: information.filter((info) =&gt; info.id !== id), }); }; render() { return ( &lt;div&gt; &lt;PhoneForm onCreate={this.handleCreate} /&gt; &lt;PhoneInfoList data={this.state.information} onRemove={this.handleRemove} /&gt; &lt;/div&gt; ); }}export default App; PhoneInfoList 컴포넌트는 props으로 전달받은 onRemove을 그대로 하위 컴포넌트인 PhoneInfo에 전달한다. 이 함수가 전달되지 않을 경우를 대비하여 defaultProps도 설정해 준다. 123456789101112131415161718import React, { Component } from 'react';import PhoneInfo from './PhoneInfo';class PhoneInfoList extends Component { static defaultProps = { data: [], onRemove: () =&gt; console.warn('onRemove not defined'), }; render() { const { data, onRemove } = this.props; const list = data.map((info) =&gt; ( &lt;PhoneInfo key={info.id} info={info} onRemove={onRemove} /&gt; )); return &lt;div&gt;{list}&lt;/div&gt;; }}export default PhoneInfoList; 삭제 버튼 및 로직은 PhoneInfo 컴포넌트에서 구현하겠다. 우선 버튼을 추가하고 삭제 이벤트를 추가 해 준다. 삭제 버튼을 클릭하면 해당 컴포넌트의 id 값을 onRemove 함수에 인자값으로 넣고 호출한다. 삭제가 정상 작동할 것이다. 1234567891011121314151617181920212223242526272829303132333435import React, { Component } from 'react';class PhoneInfo extends Component { static defaultProps = { name: '이름', phone: '000-0000-0000', id: 0, }; handleRemove = () =&gt; { // delete 버튼을 킬릭하면 onRemove에 id값을 넣어서 호출 const { info, onRemove } = this.props; onRemove(info.id); }; render() { const style = { margin: '2px', border: '1px solid #ccc', padding: '2px', }; const { name, phone } = this.props.info; return ( &lt;div style={style}&gt; &lt;div&gt; &lt;b&gt;{name}&lt;/b&gt; &lt;/div&gt; &lt;div&gt;{phone}&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={this.handleRemove}&gt; delete &lt;/button&gt; &lt;/div&gt; ); }}export default PhoneInfo; 데이터 수정수정할 때도 마찬가지로 불변성을 지켜워야 하며, 기존의 배열과 그 내부에 있는 객체를 직접 수정하지 않도록 한다. 예를 들어 아래와 같은 객체로 이루어진 배열이 있다고 가정해 본다. 123456789101112const array = [ { id: 0, name: '한나', phone: '000-0000-0000', }, { id: 1, name: '민수', phone: '000-0000-0000', },]; 기존의 값은 건들이지 않고, 객체의 id가 1인 객체의 name 값만 수정을 해보겠다. 123456const modifiedArray = array.map((item) =&gt; { return item.id === 1 ? { ...item, name: '인성' } : item;});console.log(modifiedArray);// 0: {id: 0, name: &quot;한나&quot;, phone: &quot;000-0000-0000&quot;}// 1: {id: 1, name: &quot;인성&quot;, phone: &quot;000-0000-0000&quot;} 현재 객체의 id 값이 1인 경우 새로운 객체를 생성하여 기존 값들을 넣은 뒤 name 값만 변경하여 할당 하였다. id 값이 1 아닌 수정이 필요 없는 객체는 기존 값 그대로 할당하였다. 이 원리를 이용하여 전화번호부 정보를 수정하도록 하겠다. App 컴포넌트에 handleUpdate라는 새로운 함수를 만든다. 이 함수는 id와 data라는 파라미터를 받아와서 필요한 정보를 업데이트 해준다. 이 함수는 PhoneInfoList의 onUpdata로 전달해 준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, { Component } from 'react';import PhoneForm from './components/PhoneForm';import PhoneInfoList from './components/PhoneInfoList';class App extends Component { id = 2; state = { information: [ { id: 0, name: '한나', phone: '000-0000-0000', }, { id: 1, name: '민수', phone: '000-0000-0000', }, ], }; handleCreate = (data) =&gt; { const { information } = this.state; this.setState({ information: information.concat({ id: this.id++, ...data }), }); }; handleRemove = (id) =&gt; { const { information } = this.state; this.setState({ information: information.filter((item) =&gt; item.id !== id), }); }; handleUpdate = (id, data) =&gt; { const { information } = this.state; this.setState({ information: information.map((info) =&gt; info.id === id ? { ...info, ...data } : info ), }); }; render() { return ( &lt;div&gt; &lt;PhoneForm onCreate={this.handleCreate} /&gt; &lt;PhoneInfoList data={this.state.information} onRemove={this.handleRemove} onUpdate={this.handleUpdate} /&gt; &lt;/div&gt; ); }}export default App; 이제 하위 컴포넌트 PhoneInfoList를 아래와 같이 수정해 준다. 123456789101112131415161718192021222324import React, { Component } from 'react';import PhoneInfo from './PhoneInfo';class PhoneInfoList extends Component { static defaultProps = { data: [], onRemove: () =&gt; console.warn('onRemove not defined'), onUpdate: () =&gt; console.warn('onUpdate not defined'), }; render() { const { data, onRemove, onUpdate } = this.props; const list = data.map((info) =&gt; ( &lt;PhoneInfo key={info.id} info={info} onRemove={onRemove} onUpdate={onUpdate} /&gt; )); return &lt;div&gt;{list}&lt;/div&gt;; }}export default PhoneInfoList; PhoneInfo 컴포넌트가 렌더링 하는 과정에 onUpdate를 그대로 전달하여 주고, onRemove과 마찬가지로 defaultProps도 설정해 준다. 이제 PhoneInfo 컴포넌트를 수정해 준다. 이번에 수정될 코드의 양은 꽤 많다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import React, { Component } from 'react';class PhoneInfo extends Component { static defaultProps = { name: '이름', phone: '000-0000-0000', id: 0, }; state = { // modify 버튼을 클릭했을 때 editing 값은 true로 변경 된다. 이 값이 true 일 때에는, 기존의 텍스트 형태의 값이 input 형태로 변환 되어 수정 할 수 있게 된다. editing: false, // input 값은 동적이기 때문에 input 값을 담아야 할 값도 설정 한다. name: '', phone: '', }; handleRemove = () =&gt; { // delete 버튼을 킬릭하면 onRemove에 id값을 넣어서 호출 const { info, onRemove } = this.props; onRemove(info.id); }; // 수정 버튼이 클릭 될 때 마다 editing 값이 반전된다. handleToggleEdit = () =&gt; { const { editing } = this.state; this.setState({ editing: !editing, }); }; // input 값이 변경될 때 마다 state 값을 현재 값으로 변경해 준다. handleChange = (e) =&gt; { this.setState({ [e.target.name]: e.target.value, }); }; // editing 값이 바뀔 때 처리 할 로직이 있는 함수, 수정을 눌렀을 때는 기존 값이 input에 나타나고, apply 버튼을 누르면 input 값들이 부모한테 전달 된다. componentDidUpdate(prevProps, prevState) { const { info, onUpdate } = this.props; if (!prevState.editing &amp;&amp; this.state.editing) { // editing 값이 true로 전활 될 때 info의 값을 state에 넣어준다. this.setState({ name: info.name, phone: info.phone, }); } if (prevState.editing &amp;&amp; !this.state.editing) { // editing 값이 false로 전환 될 때 현재 수정하고 있는 객체의 변경된 값을 onUpdate 함수에 태워 보낸다. onUpdate(info.id, { name: this.state.name, phone: this.state.phone, }); } } render() { const style = { margin: '2px', border: '1px solid #ccc', padding: '2px', }; const { editing } = this.state; // 수정모드 if (editing) { return ( &lt;div style={style}&gt; &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value={this.state.name} onChange={this.handleChange} /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; value={this.state.phone} onChange={this.handleChange} /&gt; &lt;/div&gt; &lt;button onClick={this.handleRemove}&gt;delete&lt;/button&gt; &lt;button onClick={this.handleToggleEdit}&gt;apply&lt;/button&gt; &lt;/div&gt; ); } // 일반모드 const { name, phone } = this.props.info; return ( &lt;div style={style}&gt; &lt;div&gt; &lt;b&gt;{name}&lt;/b&gt; &lt;/div&gt; &lt;div&gt;{phone}&lt;/div&gt; &lt;button type=&quot;button&quot; onClick={this.handleRemove}&gt; delete &lt;/button&gt; &lt;button type=&quot;button&quot; onClick={this.handleToggleEdit}&gt; modify &lt;/button&gt; &lt;/div&gt; ); }}export default PhoneInfo; 결과물을 확인해 보면 수정이 잘 되는 것을 확인해 볼 수 있다. References 누구든지 하는 리액트 6편: input 상태 관리하기누구든지 하는 리액트 7편: 배열 다루기 (1) 생성과 렌더링누구든지 하는 리액트 8편: 배열 다루기 (2) 제거와 수정","link":"/2020/03/27/react-phone-book/"},{"title":"[SASS] SASS 설치 및 기본 사용","text":"CSS전처리기(CSS pre-processor)라 불리는 SASS(Syntactically Awesome StyleSheet)는 CSS의 단점을 보완한 CSS의 확장형이다. 전처리기란 자신만의 특별한 구문을 가지고 CSS를 생성하도록 하는 프로그램이다. CSS 전처리기 종류 SASS LESS Stylus PostCSS SASS와 SCSS의 차이SCSS는 SASS의 3버전으로 업그레이드 하면서 갖춰진 새로운 문법 체계이다. SASS{}(중괄호)와 ;(세미콜론) 사용 안하기 때문에 코드가 깔끔하고 간결함 12345678.list float: left width: 100px li color: red background: url(&quot;./image.jpg&quot;) &amp;:last-child margin-right: -10px SCSS인라인 코드(한 줄 작성)를 작성할 수 있고, CSS와 유사한 문법을 가지기 때문에 코드 통합이 훨씬 쉬움 1234567891011.list { float: left; width: 100px; li { color: red; background: url(&quot;./image.jpg&quot;); &amp;:last-child { margin-right: -10px; } }} SCSS를 추천 공식 문법: 공식 레퍼런스는 SCSS 문법을 기준으로 모든 문법을 설명하고 예시를 보여줌 더 넓은 사용자: 다수의 라이브러리, 프레임워크가 SCSS 문법을 활용하는 등 새로운 문법이 더욱 널리 쓰임 CSS 호환성: 친근한 CSS 문법은 SASS와 CSS 사이의 심리적 틈을 줄여주고, 기능적으로도 확장성을 높임 여러 줄 쓰기 지원: SASS 문법은 들여쓰기와 줄 바꿈이 문법의 중요한 요소이기 때문에, 반대로 여러 줄 쓰기를 지원하지 않음 SASS를 더 편리하게 수정한 버전이 SCSS이기 때문에 파일 확장자명은 .scss를 사용한다. 컴파일 방법SASS는 웹에서 직접 동작할 수 없다. 최종에는 표준 CSS로 동작해야 하며, 전처리기로 작성 후 CSS로 컴파일해야 한다. 다양한 방법으로 컴파일이 가능하여 여기서는 node-sass를 사용할 것이다. node-sass는 Node.js를 컴파일러인 LibSass에 바인딩한 라이브러리다. NPM을 사용하여 전역에 설치해준다. 1$ npm install -g node-sass 컴파일이 제대로 되는지 테스트를 해보겠다. 작업할 디렉토리로 가서 아래처럼 구문을 적은뒤 test.scss로 저장한다. 1234$red: #ff0000;div{ color: $red;} 터미널로 들어가 해당 디렉토리로 이동한 뒤 아래를 참고하여 명령어를 입력한다. 1sass 작성한scss파일명.scss 변환될css파일명.css 위 예제 파일을 컴파일 할려면 아래처럼 입력하면 된다. 1sass test.scss test.css 명령어를 실행하면 해당 디렉토리에 test.css 및 test.css.map 파일이 정상적으로 생성된 것을 확인할 수 있다. .scss 파일은 컴파일이 진행된 파일이고, .map 파일은 scss와 css가 어떻게 연결되어 있는지에 대한 정보 파일이다. 123456div { color: #ff0000;}/*# sourceMappingURL=test.css.map */ 하지만 매번 이렇게 컴파일을 할수 없기에 내가 작성하고 있던 파일을 변경(저장)되면 자동으로 컴파일 하도록 설정할 수 있다. 작성된 scss파일만 변환 1$ sass --watch 작성된.scss 디렉토리의 모든 scss 파일을 변환 1$ sass --watch .:. 위와 같이 해당 명령어를 입력하면 test.scss 변경 시 자동으로 test.css도 변경된다. 해당 명령어를 취소하고자 할 때는 ctrl + c 를 입력하면 취소가 된다. References Sass(SCSS) 완전 정복!Sass 기초와 활용[사스(Sass)] 2. Sass 사용법CSS 전처리기Sass는 SCSS로 쓰세요[사스(Sass)] Sass 기본 사용법 (컴파일 및 명령어)","link":"/2020/02/07/sass-init/"},{"title":"[SASS] SASS 중첩(Nesting), 변수(Variables), 가져오기(Import)","text":"중첩(Nesting)SASS는 중첩기능을 사용할 수 있다. 상위 선택자의 반복을 피할수 있어 좀 더 편리하게 복잡한 구조를 작성할 수 있다. SCSS 123456789.wrap { width: 100%; .list { padding: 20px; li { color: red; } }} Compiled to 123456789.wrap { width: 100%;}.wrap .list { padding: 20px;}.wrap .list li { color: red;} 상위 선책자 참조중첩 안에서 &amp;키워드는 상위(부모) 선택자를 참조한다. SCSS 123456.wrap { width: 100%; &amp;.active { color: red; }} Compiled to 123456.wrap { width: 100%;}.wrap.active { color: red;} &amp; 키워드는 상위 선택자를 참조했기 때문에 아래와 같이 응용이 가능하다. SCSS 123456.wrap { width: 100%; &amp;-small { font-size: 12px; } &amp;-medium { font-size: 14px; } &amp;-large { font-size: 16px; }} Compiled to 123456789101112.wrap { width: 100%;}.wrap-small { font-size: 12px;}.wrap-medium { font-size: 14px;}.wrap-large { font-size: 16px;} 중첩 벗어나기중첩에서 벗어나고 싶을 때 @at-root키워드를 사용한다. 중첩 안에서 생성하되 중첩 밖에서 사용해야 하는 경우에 유용하다. SCSS 123456789.list { width: 100px; li { width: 50px; @at-root .box { width: 10px; } }} Compiled to 123456789.list { width: 100px;}.list li { width: 50px;}.box { width: 10px;} 중첩된 속성font-, margin- 등과 같이 동일한 네임 스페이스를 가지는 속성들은 아래와 같이 사용할 수 있다. SCSS 123456789101112131415.wrap { font: { weight: bold; size: 12px; family: sans-serif; }; margin: { top: 10px; left: 20px; }; padding: { bottom: 20px; right: 10px; }} Compiled to 123456789.wrap { font-weight: bold; font-size: 12px; font-family: sans-serif; margin-top: 10px; margin-left: 20px; padding-bottom: 20px; padding-right: 10px;} 변수(Variables)반복적으로 사용되는 값을 변수로 지정할 수 있다. 변수 이름 앞에는 항상 $를 붙인다. 1$변수이름: 속성값; SCSS 123456789$color-code: #000;$url: &quot;/common/images/&quot;;$w: 200px;.wrap { color: $color-code; background-image: $url; width: $w;} Compiled to 12345.wrap { color: #000; background-image: &quot;/common/images/&quot;; width: 200px;} 변수의 유효범위변수는 사용 가능한 유효범위가 있다. 선언된 블록({}) 내에서만 유효범위를 가진다. SCSS 1234567891011.wrap { $w: 100px; .box { width: $w; }}// Error.box2 { width: $w;} 변수 $w는 .wrap의 블록 안에서 설정되었기 때문에, 블록 밖의 .box2에서 사용할 수 없다. 변수 재 할당아래처럼 변수에 변수를 할당할 수 있다. SCSS 123456$red: #FF0000;$color-code: $red;.box { color: $color-code;} Compiled to 123.box { color: #FF0000;} 전역 설정!global 플래그를 사용하면 변수의 유효범위를 전역(Global)로 설정할 수 있다. 대신 기존에 사용하던 같은 이름의 변수가 있을 경우 값이 덮어져 사용된다. SCSS 1234567891011.box { $w: 100px !global; width: $w;}.box2 { width: $w; $w: 200px !global;}.box3 { width: $w;} Compiled to 1234567891011.box { width: 100px;}.box2 { width: 100px;}.box3 { width: 200px;} 초기값 설정!default 플래그는 할당되지 않은 변수의 초깃값을 설정한다. 즉, 할당되어있는 변수가 있다면 변수가 기존 할당 값을 사용한다. SCSS 123456$w: 100px;.box { $w: 200px !default; width: $w;} Compiled to 123.box { width: 100px;} 변수와 값을 설정하겠지만, 혹시 기존 변수가 있을 경우 현재 설정하는 값은 사용하지 않겠다는 의미로 쓸 수 있다. 문자 보간#{}를 이용하여 코드의 어디든지 변수 값을 넣을 수 있다. SCSS 12$family: unquote(&quot;Droid+Sans&quot;);@import url(&quot;http://fonts.googleapis.com/css?family=#{$family}&quot;); Compiled to 1@import url(&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;); 가져오기(Import)CSS에는 현재 파일에 다른 CSS를 불러오는 @import라는 속성이 있다. 이 속성을 사용하면 의도에 따라 코드를 잘게 쪼개어 효율적으로 유지 보수할 수 있지만, @import로 선언되어 있는 CSS마다 http 요청을 발생하므로 웹페이지 성능 저하의 원인이 된다 하여 사용을 지양하고 있다. SASS에서도 다른 파일을 불러올 수 있는 @import가 있다. CSS의 @import와 다른 점은 여러개의 SASS파일은 @import해도 최종적으로 하나의 CSS로 컴파일해주기 때문에 성능에 영향을 주지 않고 코드를 여러 파일로 나누어 관리할 수 있다. 물론 @import된 파일에서 정의된 내용은 부모 SASS 파일에서도 사용할 수 있다. 123// 작성 방법 : @import &quot;파일명.scss&quot; 또는 @import &quot;파일명&quot;;@import &quot;reset&quot;;@import &quot;reset.scss&quot;; 참고로 .scss파일을 @import할 경우, .scss 확장자를 써주지 않아도 된다. Partials만약 .scss파일 앞에 언더바(_)로 시작하면 CSS파일로 따로 컴파일 되지 않는다. html에서 해당 CSS파일을 불러올일이 없고, @import만 필요한 경우에는 이 기능을 사용하면 된다. References Sass(SCSS) 완전 정복!Sass 기초와 활용[사스(Sass)] 2. Sass 사용법CSS 전처리기Sass는 SCSS로 쓰세요[사스(Sass)] Sass 기본 사용법 (컴파일 및 명령어)","link":"/2020/02/09/sass-nesting-variables-import/"},{"title":"[SASS] SASS 연산(Operations)","text":"SASS는 기본적인 연산 기능을 지원한다. 레이아웃 작업시 상황에 맞게 크기를 계산하거나 정해진 값을 나눠서 작성할 경우 유용하다. 아래는 SASS에서 사용 가능한 연산자 종류이다. 산술 연산자 종류 설명 주의사항 + 더하기 - 빼기 * 곱하기 하나 이상의 값이 반드시 숫자(Number) / 나누기 오른쪽 값이 반드시 숫자(Number) % 나머지 비교 연산자 종류 설명 == 동등 != 부등 &lt; 대소 / 보다 작은 &gt; 대소 / 보다 큰 &lt;= 대소 및 동등 / 보다 작거나 같은 &gt;= 대소 및 동등 / 보다 크거나 같은 논리 연산자 종류 설명 and 그리고 or 또는 not 부정(반대) 숫자일반적으로 절대값을 나타내는 px단위로 연산을 하지만, 상대적 단위(%, em, vw 등)의 연산의 경우 calc()로 연산 해야 한다. 12width: 50% - 20px; // 단위 모순 에러(Incompatible units error)width: calc(50% - 20px); // 연산 가능 나누기 연산의 주의사항CSS는 속성 값의 숫자를 분리하는 방법으로 /를 허용하기 때문에 /가 나누기 연산으로 사용되지 않을 수 있다. 아래 예제를 보면 나누기 연산자만 연산 되지 않고 그대로 컴파일된다. SCSS 123456div { width: 20px + 20px; // 더하기 height: 40px - 10px; // 빼기 font-size: 10px * 2; // 곱하기 margin: 30px / 2; // 나누기} Compiled to 123456div { width: 40px; height: 30px; font-size: 20px; margin: 30px/2; // Error} 따라서 /를 나누기 연산 기능으로 사용하려면 다음과 같은 조건을 충족해야 한다. 값 또는 그 일부가 변수에 저장되거나 함수에 의해 반환되는 경우 값이 ()로 묶여있는 경우 값이 다른 산술 표현식의 일부로 사용되는 경우 SCSS 123456div { $x: 100px; width: $x / 2; // 변수에 저장된 값을 나누기 height: (100px / 2); // 괄호로 묶여있는 경우 font-size: 10px + 12px / 3; // 더하기 연산자와 같이 사용} Compiled to 12345div { width: 50px; height: 50px; font-size: 14px;} 문자문자 연산에는 +가 사용된다. 문자 연산의 결과는 첫번째 피연산자를 기준으로 한다. 첫번째 피연산자에 따옴표가 붙어있다면 연산 결과를 따옴표로 묶는다. 반대로 첫번째 피연산자에 따옴표가 붙어있지 않으면 연산 결과도 따옴표를 처리하지 않는다. SCSS 123456div::after { content: &quot;hello&quot; + world;}div::after { content: hello + &quot;world&quot;;} Compiled to 1234567div::after { content: &quot;helloworld&quot;;}div::after { content: helloworld;} 색상색상도 연산이 가능하다. 논리SASS의 @if조건문에서 사용되는 논리 연삭에는 그리고, 또는, 부정이 있다. 자바스크립트의 &amp;&amp;, ||, !와 같은 기능이라 보면 된다. SCSS 123456$width: 90px;div { @if not ($width &gt; 100px) { height: 300px; }} Compiled to 123div { height: 300px;} References Sass(SCSS) 완전 정복!Sass 기초와 활용[사스(Sass)] 2. Sass 사용법CSS 전처리기Sass는 SCSS로 쓰세요[사스(Sass)] Sass 기본 사용법 (컴파일 및 명령어)","link":"/2020/02/10/sass-operations/"},{"title":"[TypeScript] 타입스크립트 시작하기","text":"정의타입스크립트(TypeScript)는 마이크로소프트에서 개발, 유지하고 있으며 엄격한 문법을 지원한다. 자바스크립트 엔진을 사용하며, 자바스크립트의 상위 집합으로 ECMA의 최신 표준을 지원한다. 장점정적 타입 언어(static type language)C#과 Java같은 정적 타입 언어들에서 사용하는 타입 시스템은 높은 가독성과 코드 품질 등을 제공할 수 있고, 런타임이 아닌 컴파일 환경에서 에러가 발생해 치명적인 오류들을 더욱 쉽게 잡아낼 수 있다. 기존의 자바스크립트는 타입 시스템이 없는 동적 프로그래밍 언어로, 변수에 문자열, 숫자, 불리언 등 여러 타입의 값을 가질 수 있다. 이는 약한 타입의 언어라고 하며, 비교적 유연하게 개발할 수 있는 환경을 제공하지만, 타입 안정성이 보장되지 않아 런타임 환경에서 쉽게 에러가 발생할 수 있는 단점을 가진다. 타입스크립트는 자바스크립트에 타입 시스템을 적용하여 대부분의 에러를 컴파일 환경에서 체크할 수 있다. 설치하기타입스크립트를 설치하는 방법에는 크게 두가지가 있다. npm을 이용한 설치 TypeScript의 Visual Studio 플러그인 설치 여기서는 npm을 이용하여 설치하겠다. 우선 전역에 타입스크립트를 설치해 준다. 1$ npm install -g typescript 기존의 자바스크립트의 확장자가 .js이였다면 타입스크립트는 .ts라는 확장자를 가진다. 타입스크립트 작성 후 컴파일러를 통해 자바스크립트 파일로 변환되어 사용하게 된다. 파일 생성하기원하는 디렉토리로 이동하여 타입스크립트 파일을 하나 만들어준다. 여기서는 app.ts로 만들겠다. 만든 뒤 아래 처럼 코드를 입력한다. 1234function func(msg) { return 'hello' + msg;}let txt = 'world'; 컴파일 하기이제 터미널로 가서 아래 명령어를 실행 한다. 1$ tsc app.ts app.ts 파일을 컴파일 하여 아래처럼 app.js 파일이 생성되었을 것이다. 1234function func(msg) { return 'hello' + msg;}var txt = 'world'; 로컬에서 작업 하기로컬 환경에서 Parcel 번들러를 이용하면 작업을 빠르게 테스트를 할 수 있다. ParcelParcel 전역 설치 1$ npm install -g parcel-bundler 프로젝트 파일 생성 및 패키지 파일 생성 후 패키지 및 Parcel를 설치해 준다. 프로젝트 폴더명은 app으로 하겠다. 1234$ mkdir app$ cd app$ npm init -y$ npm install -D typescript parcel-bundler tsconfig.json 파일을 생성하고 아래 옵션을 추가한다. 12345678{ &quot;compilerOptions&quot;: { &quot;strict&quot;: true }, &quot;exclude&quot;: [ &quot;node_modules&quot; ]} main.ts 파일을 생성하고 아래 코드를 입력한다. 12345function add(a: number, b: number) { return a + b;}const sum: number = add(1, 2);console.log(sum); index.html 파일을 생성하고 main.ts 파일을 연결한다. Parcel 번들러가 빌드시에 자동으로 타입스크립트를 컴파일 할 것이다. 12345678910&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;typescript&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;main.ts&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Parcel 번들러로 빌드해 준다. 1$ npx parcel index.html http://localhost:1234에서 결과물을 확인할 수 있으며, 이제 코드를 수정할 때마다 타입스크립트가 자동으로 컴파일될 것이다. References 한눈에 보는 타입스크립트(updated)TypeScript-Handbook 한글 문서타입스크립트, 써야할까?","link":"/2020/05/09/typescript-init/"},{"title":"[Svelte] 스벨트 요약","text":"REACT/VUE에서 이젠 SVELTEW3C HTML5 Conference 2019에서 변규현 강사님의 내용을 간략하게 필기한 것 Let’s start SVELTE, goodbye React &amp; Vue 공식 문서 듀토리얼 예제 스벨트란? 코드가 간결하다. 리액트와 뷰와 스벨트를 비교했을 때 코드의 양이 차이가 많이난다. React : 442 Characters Vue : 263 Characters Svelte : 145 Charaters 가상돔을 사용하지 않는다. 반응성이다. 이는 변경된 값이 DOM에 자동으로 반영된다는 것 리액트나 뷰는 하나의 컴포넌트 및 템플릿으로 HTML을 감싸야 하지만 스벨트는 각 태그별로 사용이 가능하다. 스벨트는 에러를 빌드 타임에서 잡는다. 컴포넌트명을 예약어로도 사용 가능 컴포넌트간의 통신 가능 문법이 뷰보다 쉬움, 문법이라고 할게 없음, 상당히 쉽다. 가볍게 코드를 짤 경우 스벨트를 강력 추천 리액트의 경우 렌더링된 DOM 트리가 전의 것과 비교해서 다른 타입의 요소일때, 전 요소는 없어지고, 새로운 것을 완전히 새롭게 렌더링하는데 이를 diff 라고 한다. 리액트는 이로 인해 버벅거리는 현상이 있다. 이로 인해 스벨트와 어느 한 예제를 비교하였을때 성능차이가 거의 5배 차이가 남 References SvelteJS(스벨트) - 새로운 개념의 프론트엔드 프레임워크(updated)웹 프레임워크 Svelte를 소개합니다.","link":"/2019/10/20/svelte-seminar/"},{"title":"[UI] 전체동의 체크박스(agree checkbox)","text":"vanilla JS로 만들어진 전체동의 체크박스, 보통 이용 약관에 많이 사용되된다. 조건 전체동의 클릭 시 모든 체크박스 체크 전체동의 클릭 해제 시 모든 체크박스 체크 해제 전체동의 체크박스 외 체크박스가 모두 체크 될 시 전체동의 체크박스 체크 전체동의 체크박스 외 체크박스가 모두 체크 해제 될 시 전체동의 체크박스 체크 해제 구현 window.onload = function(){ var checkWrap = document.getElementById('checkWrap'), check = checkWrap.getElementsByTagName('input'); checkWrap.addEventListener('click', function(e){ var target = e.target, checkNum = 0; if(target === check[0]){ if(target.checked){ for(var i = 1;i < check.length;i++){ check[i].checked = true; }; }else{ for(var i = 1;i < check.length;i++){ check[i].checked = false; }; }; }else{ for(var i = 1;i < check.length;i++){ if(check[i].checked){ checkNum++; }; }; if(checkNum >= check.length - 1){ check[0].checked = true; }else{ check[0].checked = false; }; }; }); }; .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li:before, .uiWrap ol li:before { display:none; } #checkWrap { width: 120px; } #checkWrap label { display: block; margin: 5px; font-size: 14px; } #checkWrap label input[type=\"checkbox\"] { margin-right: 5px; width: 20px; height: 20px; vertical-align: middle; } #checkWrap label:first-child input[type=\"checkbox\"] { width: 30px; height: 30px; } 전체 동의 동의 동의 동의 html123456&lt;div id=&quot;checkWrap&quot;&gt; &lt;label for=&quot;cheeck01&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;cheeck01&quot; /&gt;전체 동의&lt;/label&gt; &lt;label for=&quot;cheeck02&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;cheeck02&quot; /&gt;동의&lt;/label&gt; &lt;label for=&quot;cheeck03&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;cheeck03&quot; /&gt;동의&lt;/label&gt; &lt;label for=&quot;cheeck04&quot;&gt;&lt;input type=&quot;checkbox&quot; id=&quot;cheeck04&quot; /&gt;동의&lt;/label&gt;&lt;/div&gt; css123456789101112131415161718192021#checkWrap { width: 120px;}#checkWrap label { display: block; margin: 5px; font-size: 14px;}#checkWrap label input[type=&quot;checkbox&quot;] { margin-right: 5px; width: 20px; height: 20px; vertical-align: middle;}#checkWrap label:first-child input[type=&quot;checkbox&quot;] { width: 30px; height: 30px;} javascript123456789101112131415161718192021222324252627282930window.onload = function(){ var checkWrap = document.getElementById('checkWrap'), check = checkWrap.getElementsByTagName('input'); checkWrap.addEventListener('click', function(e){ var target = e.target, checkNum = 0; if(target === check[0]){ if(target.checked){ for(var i = 1;i &lt; check.length;i++){ check[i].checked = true; }; }else{ for(var i = 1;i &lt; check.length;i++){ check[i].checked = false; }; }; }else{ for(var i = 1;i &lt; check.length;i++){ if(check[i].checked){ checkNum++; }; }; if(checkNum &gt;= check.length - 1){ check[0].checked = true; }else{ check[0].checked = false; }; }; });};","link":"/2019/05/28/ui-agree-checkbox/"},{"title":"[TypeScript] 타입스크립트 타입 선언","text":"타입 기본타입 지정타입스크립트는 일반 변수, 매개 변수, 객체 속성 등에: TYPE과 같은 형태로 타입을 지정할 수 있다. 12345let a: string = 'text'; // 문자열let b: number = 0; // 숫자형let c: boolean = true; // 논리형let d: any = true; // 어떤 타입이 올지 모를 때let e: string | number = '0'; // 문자열이나 숫자가 올 때 타입 에러만약 아래와 같이 타입을 선언하고 다른 타입의 값을 대입하거나 값이 선언된 후에 다른 타입의 값이 대입되면 에러를 발생한다. 123456// 문자열로 선언하고 숫자를 대입하면 에러 발생let a: string = 0; // error// 문자열 값이 들어가고 이후에 숫자가 대입하면 에러 발생let b: string = 'text';b = 1; // error Type '1' is not assignable to type 'string'. TS2322 출력창에서 TS2322라는 에러 코드를 볼 수 있으며, 이를 검색하면 쉽게 에러 코드에 대한 정보를 얻을 수 있다. 타입 선언타입스크립트는 ES5, ES6의 상위 확장인 언어이므로 자바스크립트의 타입을 그대로 사용하며, 이외에도 타입스크립트의 고유의 타입이 추가로 제공된다. Type JS TS Description boolean ◯ ◯ true와 false null ◯ ◯ 값이 없다는 것을 명시 undefined ◯ ◯ 값을 할당하지 않은 변수의 초기값 number ◯ ◯ 숫자(정수와 실수, Infinity, NaN) string ◯ ◯ 문자열 symbol ◯ ◯ 고유하고 수정 불가능한 데이터 타입이며 주로 객체 프로퍼티들의 식별자로 사용(ES6에서 추가) object ◯ ◯ 객체형(참조형) array ◯ 배열 tuple ◯ 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현 enum ◯ 열거형. 숫자값 집합에 이름을 지정한 것 any ◯ 타입 추론(type inference)할 수 없거나 타입 체크가 필요없는 변수에 사용, var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능 void ◯ 일반적으로 함수에서 반환값이 없을 경우 사용 never ◯ 결코 발생하지 않는 값 논리형(Boolean)12let bool01: boolean = true;let bool02: boolean = false; 숫자형(Number)123let num01: number = 5;let num02: number = 3.14;let num03: number = NaN; 문자열(String)ES6의 템플릿 문자열도 지원한다. 12let str01: string = 'text';let str02: string = `my name is ${val}`; 배열(Array)배열은 아래와 같이 두가지 방법으로 타입을 선언할 수 있다. 123456789101112131415// 문자열만 가지는 배열let arr01: string[] = ['a', 'b', 'c'];let arr02: Array&lt;string&gt; = ['a', 'b', 'c'];// 숫자형만 가지는 배열let arr03: number[] = [1, 2, 3];let arr04: Array&lt;number&gt; = [1, 2, 3];// Union 타입(다중 타입)의 문자열과 숫자를 동시에 가지는 배열let arr05: (string | number)[] = [1, 'a', 2, 'b', 'c', 3];let arr06: Array&lt;string | number&gt; = [1, 'a', 2, 'b', 'c', 3];// 배열이 가지는 값의 타입을 추측할 수 없을 때 any를 사용할 수 있다.let arr07: (any)[] = [1, 'a', 2, 'b', 'c', 3];let arr08: Array&lt;any&gt; = [1, 'a', 2, 'b', 'c', 3]; 함수(Function)함수는 파라미터에 각각 타입을 선언해 주며, 파라미터 우측에는 해당 함수의 리턴값 타입도 선언해 주면 된다. 1234function sum(a: number, b: number): number { return a + b;}console.log(sum(2, 3)); // 5 리턴값을 숫자형으로 선언하였는데 다른 값이 리턴된다면 역시 에러가 난다. 123function sum(a: number, b: number): number { return null; // error} 객체(Object)기본적으로 typeof 연산자가 object로 반환하는 모든 타입을 나타낸다. 여러 타입의 상위 타입이기 때문에 그다지 유용하지 않다. 1234let obj: object = {};let arr: object = [];let func: object = function() {};let date: object = new Date(); 보다 정확하게 타입 지정을 하기 위해 아래와 같이 객체 속성들에 대한 타입을 개별적으로 지정할 수 있다. 12345let user: { name: string, age: number } = { name: 'a', age: 20};console.log(user); // {name: &quot;a&quot;, age: 20} 튜플(Tuple)배열과 유사하다. 차이점은 정해진 타입의 요소 개수 만큼의 타입을 미리 선언후 배열을 표현한다. 123let tuple: [string, number];tuple = ['a', 0];console.log(tuple); // [&quot;a&quot;, 0] 정해진 요소의 순서 및 개수가 다르면 오류를 출력한다. 123let tuple: [string, number];tuple = [0, 'a']; // errortuple = ['a', 0, 1]; // error 아래와 같이 데이터를 개별 변수로 지정하지 않고, 단일 튜플 타입으로 지정해 사용할 수 있다. 1234567// 기존 변수let name: string = 'a';let age: number = 20;// 튜플let user: [string, number] = ['a', 20];console.log(user); // [&quot;a&quot;, 20] 값으로 타입을 대신할 수도 있다. 처음 선언할 때의 값과 다른 값이 할당 되면 에러가 출력된다. 1234let user: ['a', number];user = ['a', 20]; // [&quot;a&quot;, 20]user = ['a', 30]; // [&quot;a&quot;, 30]user = ['b', 30]; // error 튜플은 정해진 타입과 고정된 길이의 배열이지만, 값을 할당할 때만 해당된다. push나 splice같은 메서드를 통해 값을 넣는건 막을 수 없다. 12345let user: [string, number];user = ['a', 20]console.log(user); // [&quot;a&quot;, 20]user.push(30);console.log(user); // [&quot;a&quot;, 20, 30] 열거형(Enum)숫자 혹은 문자열 값 집합에 이름을 부여할 수 있는 타입으로, 값의 종류가 일정한 범위로 정해져 있는 경우 유용하다. 기본적으로 0부터 시작하며, 값은 1씩 증가한다. 123456789101112131415161718enum obj { a, b, c, d, e}console.log(obj);// 0: &quot;a&quot;// 1: &quot;b&quot;// 2: &quot;c&quot;// 3: &quot;d&quot;// 4: &quot;e&quot;// a: 0// b: 1// c: 2// d: 3// e: 4 수동으로 값을 변경할 수 있으며, 변경한 부분부터 다시 1씩 증가한다. 123456789enum obj { a, b = 10, c, d, e}console.log(obj.b); // 10console.log(obj.c); // 11 모든 타입(Any)Any는 모든 타입을 의미하며, 기존의 자바스크립트 변수와 마찬가지로 어떠한 타입의 값도 할당할 수 있다. 불가피하게 타입을 선언할 수 없는 경우, 유용할 수 있다. 12345let any:any = 'String';any = 0;console.log(any); // 0any = true;console.log(any); // true 빈 타입(Void)빈 타입인 Void는 리턴값이 없는 함수에서 사용된다. 리턴값의 타입을 명시하는 곳에 작성하며, 리턴값이 없는 함수는 undefined를 반환한다. 1234function hello(): void { console.log(&quot;hello&quot;);}console.log(hello()); // undefined neverNever 타입은 절대 발생할 수 없는 타입을 나타낸다. 1234function errorMsg() { throw new Error(&quot;오류 발생!&quot;);}console.log(errorMsg()); // Uncaught Error: 오류 발생! errorMsgd 함수는 오류를 발생시키기 때문에 null, undefined를 포함한 어떠한 값도 반환하지 않는다. 이럴 경우 never 타입을 사용하면 된다. References 한눈에 보는 타입스크립트(updated)정적 타이핑타입스크립트 기초 연습TypeScript-Handbook 한글 문서3.1 기본 타입타입스크립트 기초 연습","link":"/2020/05/12/typescript-type-declaration/"},{"title":"[UI] 커스텀 셀렉트박스(custom selectbox)","text":"기존의 select 태그는 CSS 적용이 안되는 부분이 많아 디자인에 제약이 많다.디자인을 더욱 다양하게 적용할 수 있는 커스텀 셀렉트 박스는 아래와 같이 만들 수 있다. 설명 셀렉트가 된 항목은 ‘selected’ 라는 클래스명이 붙음 항목이 많아질 경우 스크롤바가 생김 생성자 함수방식 및 프로토타입에 메서드를 추가하여 재사용 및 메모리 관리에 용이함 구현 function CustomSelectBox(selector){ this.$selectBox = null, this.$select = null, this.$list = null, this.$listLi = null; CustomSelectBox.prototype.init = function(selector){ this.$selectBox = $(selector); this.$select = this.$selectBox.find('.box .select'); this.$list = this.$selectBox.find('.box .list'); this.$listLi = this.$list.children('li'); } CustomSelectBox.prototype.initEvent = function(e){ var that = this; this.$select.on('click', function(e){ that.listOn(); }); this.$listLi.on('click', function(e){ that.listSelect($(this)); }); $(document).on('click', function(e){ that.listOff($(e.target)); }); } CustomSelectBox.prototype.listOn = function(){ this.$selectBox.toggleClass('on'); if(this.$selectBox.hasClass('on')){ this.$list.css('display', 'block'); }else{ this.$list.css('display', 'none'); }; } CustomSelectBox.prototype.listSelect = function($target){ $target.addClass('selected').siblings('li').removeClass('selected'); this.$selectBox.removeClass('on'); this.$select.text($target.text()); this.$list.css('display', 'none'); } CustomSelectBox.prototype.listOff = function($target){ if(!$target.is(this.$select) && this.$selectBox.hasClass('on')){ this.$selectBox.removeClass('on'); this.$list.css('display', 'none'); }; } this.init(selector); this.initEvent(); } $(function(){ var select = new CustomSelectBox('.select_box'); }); .wrap * { margin: 0; padding: 0; } .wrap ul li, .wrap ol li { list-style: none; } .select_box { margin: 20px; } .select_box .box { display: inline-block; position: relative; width: 150px; } .select_box .box .select { position: relative; border: 2px solid #ccc; box-sizing: border-box; padding: 0 10px; width: 100%; height: 40px; line-height: 35px; font-size: 16px; background-color: #fff; cursor: pointer; } .select_box .box .select:after { content: '▼'; position: absolute; top: 7px; right: 10px; transform: none; border: 0; } .select_box.on .box .select:after { content: '▲'; } .select_box .box .list { display: none; overflow-y: auto; position: absolute; top: 45px; left: 0; z-index: 10; margin: 0; border: 2px solid #ccc; box-sizing: border-box; padding: 10px 0; width: 100%; max-height: 200px; background-color: #fff; } .select_box .box .list::-webkit-scrollbar { width: 10px; height: 0; } .select_box .box .list::-webkit-scrollbar-button:start:decrement, .select_box .box .list::-webkit-scrollbar-button:end:increment { display: block; height: 0; } .select_box .box .list::-webkit-scrollbar-track { background: rgba(0, 0, 0, .05); -webkit-border-radius: 10px; border-radius: 10px; } .select_box .box .list::-webkit-scrollbar-thumb { height: 50px; width: 50px; background: rgba(0, 0, 0, .2); -webkit-border-radius: 5px; border-radius: 5px; } .select_box .box .list>li { box-sizing: border-box; padding: 0 10px; width: 100%; height: 35px; line-height: 35px; cursor: pointer; } .select_box .box .list>li:hover { background-color: #ccc; } 선택 선택 항목01 항목02 항목03 항목04 항목05 항목06 항목07 항목08 항목09 항목10 html1234567891011121314151617181920&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;select_box&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;select&quot;&gt;선택&lt;/div&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;selected&quot;&gt;선택&lt;/li&gt; &lt;li&gt;항목01&lt;/li&gt; &lt;li&gt;항목02&lt;/li&gt; &lt;li&gt;항목03&lt;/li&gt; &lt;li&gt;항목04&lt;/li&gt; &lt;li&gt;항목05&lt;/li&gt; &lt;li&gt;항목06&lt;/li&gt; &lt;li&gt;항목07&lt;/li&gt; &lt;li&gt;항목08&lt;/li&gt; &lt;li&gt;항목09&lt;/li&gt; &lt;li&gt;항목10&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182.wrap * { margin: 0; padding: 0;}.wrap ul li,.wrap ol li { list-style: none;}.select_box { margin: 20px;}.select_box .box { display: inline-block; position: relative; width: 150px;}.select_box .box .select { position: relative; border: 2px solid #ccc; box-sizing: border-box; padding: 0 10px; height: 40px; line-height: 35px; font-size: 16px; background-color: #fff; cursor: pointer;}.select_box .box .select:after { content: '▼'; position: absolute; top: 0; right: 10px;}.select_box.on .box .select:after { content: '▲';}.select_box .box .list { display: none; overflow-y: auto; position: absolute; top: 45px; left: 0; z-index: 10; border: 2px solid #ccc; box-sizing: border-box; padding: 10px 0; width: 100%; max-height: 200px; background-color: #fff;}.select_box .box .list::-webkit-scrollbar { width: 10px; height: 0;}.select_box .box .list::-webkit-scrollbar-button:start:decrement,.select_box .box .list::-webkit-scrollbar-button:end:increment { display: block; height: 0;}.select_box .box .list::-webkit-scrollbar-track { background: rgba(0, 0, 0, .05); -webkit-border-radius: 10px; border-radius: 10px;}.select_box .box .list::-webkit-scrollbar-thumb { height: 50px; width: 50px; background: rgba(0, 0, 0, .2); -webkit-border-radius: 5px; border-radius: 5px;}.select_box .box .list&gt;li { box-sizing: border-box; padding: 0 10px; width: 100%; height: 35px; line-height: 35px; cursor: pointer;}.select_box .box .list&gt;li:hover { background-color: #ccc;} javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546function CustomSelectBox(selector){ this.$selectBox = null, this.$select = null, this.$list = null, this.$listLi = null; CustomSelectBox.prototype.init = function(selector){ this.$selectBox = $(selector); this.$select = this.$selectBox.find('.box .select'); this.$list = this.$selectBox.find('.box .list'); this.$listLi = this.$list.children('li'); } CustomSelectBox.prototype.initEvent = function(e){ var that = this; this.$select.on('click', function(e){ that.listOn(); }); this.$listLi.on('click', function(e){ that.listSelect($(this)); }); $(document).on('click', function(e){ that.listOff($(e.target)); }); } CustomSelectBox.prototype.listOn = function(){ this.$selectBox.toggleClass('on'); if(this.$selectBox.hasClass('on')){ this.$list.css('display', 'block'); }else{ this.$list.css('display', 'none'); }; } CustomSelectBox.prototype.listSelect = function($target){ $target.addClass('selected').siblings('li').removeClass('selected'); this.$selectBox.removeClass('on'); this.$select.text($target.text()); this.$list.css('display', 'none'); } CustomSelectBox.prototype.listOff = function($target){ if(!$target.is(this.$select) &amp;&amp; this.$selectBox.hasClass('on')){ this.$selectBox.removeClass('on'); this.$list.css('display', 'none'); }; } this.init(selector); this.initEvent();} 인스턴스 생성123$(function(){ var select = new CustomSelectBox('.select_box');}); 셀렉트 박스가 여러개일 경우셀렉트박스가 여러 개일 경우 태그를 각각 추가해 준 뒤 인스턴스도 각각 생성해 주면 된다. 여러개의 셀렉트 박스 예시는 여기를 참고하면 되며, 소스는 여기에 있다.","link":"/2019/10/02/ui-custom-selectbox/"},{"title":"[UI] 인터렉션 테스트","text":"리스트 페이지마소니(랜덤 상자) 레이아웃Masonry 무작위(정사각형, 가로, 세로 직사각형)의 상자가 무작위로 배치 임시 구현Test 무작위 및 랜덤한 모양의 박스 배열 각 게시물 상자의 넓이는 같게 뿌려지며, 추천수가 많을수록 크기가 커지는 레이아웃 셀렉트로 원하는 게시물 및 순위 조회 가능 팝업 뷰파노라마 사진 활용Airpano 파노라마 사진을 활용하여 인테리어 게시물을 3D 형태로 출력 입체적인 컨텐츠로 사용자가 직접 둘러볼 수 있음 임시 구현Test 해당 3D 형태에 원하는 핀 및 태그를 활용하여 해당 소품들의 정보를 전달 임시 구현Test","link":"/2019/12/16/ui-interaction-test/"},{"title":"[UI] Vanilla JS로 패럴랙스 적용하기","text":"particles.js 적용 백그라운드에 패럴랙스 적용 구현 화면 코드","link":"/2020/05/23/ui-parallax-scroll/"},{"title":"[UI] 핀터레스트 레이아웃 구현하기","text":"핀터레스트 레이아웃 사용시 자바스크립트만으로 구현이 가능하다. Masonry 플러그인을 활용하면 좀더 다양한 인터렉션을 활용할 수 있지만 성능 및 블록 틀어짐 이슈 때문에 자바스크립트만 활용하였다. 예제 확인장점 현재 화면에 나열된 요소들의 부모를 기준으로 posirion: absolute; top: y; left: x; 속성을 활용, 각 위치에 맞게 배치하여 제이쿼리 플러그인 필요 없이 자바스크립트만으로 구현하여 가볍다. IE9까지 대응 가능 가능 하며, IE10까지만 대응한다면 top: y; left: x; 대신 transform: translate(x, y) 속성을 활용하면 성능이 좀 더 좋아진다. 단점 오직 레이아웃만 구현하여 Masonry 플러그인같은 인터렉션 효과는 없다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;div class=&quot;cntBox&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img01.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img02.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img03.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img04.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img03.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img04.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img01.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img02.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img01.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img02.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img03.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img04.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img03.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img04.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img01.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img02.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img01.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img02.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img03.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img04.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img03.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img04.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img01.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;img src=&quot;img/img02.jpg&quot; /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132* { margin: 0; padding: 0; box-sizing: border-box;}.cntBox { position: relative; margin: 0 auto; width: 100%; max-width: 1200px;}.item { display: inline-block; position: absolute; width: 20%; padding: 5px;}.item img { width: 100%;}.item .inner { border: 3px solid #ccc; border-radius: 5px;}.item .inner p { padding: 10px;} 123456789101112131415161718192021222324252627282930313233343536// 리사이즈 이벤트 한번만 실행// var timer = null;window.addEventListener('resize', function () { // 리사이즈 이벤트 한번만 실행 // clearTimeout(timer); // timer = setTimeout(boxLayout, 150); boxLayout();}, false);window.addEventListener(&quot;load&quot;, function () { boxLayout();});function boxLayout() { var images = document.querySelectorAll(&quot;.item&quot;); var imgStack = [0, 0, 0, 0, 0]; var boxW = document.querySelectorAll(&quot;.cntBox&quot;)[0].offsetWidth; var colWidth = boxW / imgStack.length; for (var i = 0; i &lt; images.length; i++) { var minIndex = imgStack.indexOf(Math.min.apply(0, imgStack)); var x = colWidth * minIndex; var y = imgStack[minIndex]; imgStack[minIndex] += (images[i].offsetHeight); // images[i].style.transform = 'translateX(' + x + 'px) translateY(' + y + 'px)'; images[i].style.left = x + 'px'; images[i].style.top = y + 'px'; if (i === images.length - 1) { document.querySelector(&quot;.cntBox&quot;).style.height = Math.max.apply(0, imgStack) + 'px'; } }} References 핀터레스트(Masonry) 스타일 레이아웃을 만드는 세 가지 방법","link":"/2019/12/08/ui-pinterest-layout/"},{"title":"[UI] Vanilla JS로 짱깸뽀(가위 바위 보) 게임 만들기","text":"바닐라 자바스크립트로 만든 추억의 짱깸뽀 게임이다. 게임 설명 시작 버튼을 눌러 게임 시작 게임을 한판 할 때 마다 하단의 코인이 하나씩 소모됨 룰렛 주변으로 게임 결과가 표시 됨 승리할 경우 랜덤으로 코인이 지급 짱깸뽀 사운드를 추가해야 하는데 구하기가 쉽지 않음 게임 하기여기를 클릭하면 게임 화면이 나온다. 코드여기를 클릭하면 코드를 확인할 수 있다.","link":"/2020/02/05/ui-rock-paper-scissors/"},{"title":"[UI] 슬라이드 배너(slide banner)","text":"vanilla JS로 만들어본 기본 슬라이드 배너 조건 라이브러리 없이 자바스크립트만 활용 다음, 이전 버튼으로 슬라이드 조작 가능 인디게이터는 슬라이드 갯수에 맞게 자동으로 생성 자동재생, 일시정지 버튼으로 웹 접근성 준수 구현 window.addEventListener('load', function(){ var MOVEING_PX = 4, AUTO_TIME = 2000, slide = document.getElementById('slide'), indi = document.createElement('ul'), slideCnt = slide.getElementsByClassName('cnt'), slideCntItem = slideCnt[0].getElementsByTagName('li'), prevBtn = slide.getElementsByClassName('prev'), nextBtn = slide.getElementsByClassName('next'), playBtn = slide.getElementsByClassName('play'), stopBtn = slide.getElementsByClassName('stop'), playSet = null, before = 0, after = 0, moveIng = false; // init slideCntItem[0].style.left = 0; playBtn[0].style.display = 'block'; var indi = document.createElement('ul'); for(var i = 0;i < slideCntItem.length;i++){ indi.innerHTML += ''; }; indi.classList.add('indi'); indi.children[0].classList.add('on'); slide.append(indi); for(var j = 0;j < indi.children.length;j++){ indiClick(j); }; // initEvnet nextBtn[0].addEventListener('click', function(e){ if(!moveIng){ after++; if(after >= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }); prevBtn[0].addEventListener('click', function(e){ if(!moveIng){ after--; if(after < 0){ after = slideCntItem.length - 1; }; move(after, before); before = after; }; }); playBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'none'; stopBtn[0].style.display = 'block'; playSet = setInterval(function(){ if(!moveIng){ after++; if(after >= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }, AUTO_TIME); }); stopBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'block'; stopBtn[0].style.display = 'none'; clearInterval(playSet); }); function indiClick(target){ indi.children[target].addEventListener('click', function(){ if(!moveIng){ after = target; if(after > before){ move(after, before, 'next'); }else if(after < before){ move(after, before); }; before = after; }; }); } function move(after, before, type){ var nextX = type === 'next' ? slide.offsetWidth : slide.offsetWidth * -1, prevX = 0, set = null; set = setInterval(function(){ moveIng = true; if(type === 'next'){ nextX -= MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX = 0){ clearInterval(set); nextX = slide.offsetWidth * -1; moveIng = false; }; prevX += MOVEING_PX; }; slideCntItem[before].style.left = prevX + 'px'; }); indi.children[before].classList.remove('on'); indi.children[after].classList.add('on'); } }); .uiWrap * { margin: 0 0 10px; padding: 0; } .uiWrap ul li, .uiWrap ol li { list-style: none; } .uiWrap ul li:before, .uiWrap ol li:before { display: none; } #slide { position: relative; overflow: hidden; width: 300px; height: 300px; } #slide .cnt>li { position: absolute; top: 0; left: 300px; margin: 0; width: 300px; height: 300px; text-align: center; font-size: 30px; line-height: 300px; color: #fff; } #slide .cnt>li:nth-child(1) { background-color: #333; } #slide .cnt>li:nth-child(2) { background-color: #666; } #slide .cnt>li:nth-child(3) { background-color: #999; } #slide .cnt>li:nth-child(4) { background-color: #ccc; } #slide .btn>button { position: absolute; top: 50%; transform: translateY(-50%); border: 0; padding: 5px; background-color: #fff; } #slide .btn .prev { left: 5px; } #slide .btn .next { right: 5px; } #slide .auto>button { display: none; position: absolute; bottom: 5px; right: 5px; border: 0; padding: 5px; background-color: #fff; } #slide .indi { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); margin: 0; } #slide .indi:after { content: ''; display: block; clear: both; } #slide .indi>li { float: left; margin: 0 0 0 5px; border-radius: 50%; width: 12px; height: 12px; cursor: pointer; opacity: .5; background-color: #fff; } #slide .indi>li.on { opacity: 1 } #slide .indi>li:first-child { margin-left: 0 } 1 2 3 4 prev next stop play html12345678910111213141516&lt;div id=&quot;slide&quot;&gt; &lt;ul class=&quot;cnt&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;btn&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;prev&quot;&gt;prev&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;next&quot;&gt;next&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;auto&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;stop&quot;&gt;stop&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;play&quot;&gt;play&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#slide { position: relative; overflow: hidden; width: 300px; height: 300px;}#slide .cnt &gt; li { position: absolute; top: 0; left: 300px; width: 300px; height: 300px; text-align: center; font-size: 30px; line-height: 300px; color: #fff;}#slide .cnt &gt; li:nth-child(1) { background-color: red;}#slide .cnt &gt; li:nth-child(2) { background-color: orange;}#slide .cnt &gt; li:nth-child(3) { background-color: green;}#slide .cnt &gt; li:nth-child(4) { background-color: blue;}#slide .btn &gt; button { position: absolute; top: 50%; transform: translateY(-50%); border: 0; padding: 5px; background-color: #fff;}#slide .btn .prev { left: 5px;}#slide .btn .next { right: 5px;}#slide .auto &gt; button { display: none; position: absolute; bottom: 5px; right: 5px; border: 0; padding: 5px; background-color: #fff;}#slide .indi { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);}#slide .indi:after { content: &quot;&quot;; display: block; clear: both;}#slide .indi &gt; li { float: left; margin-left: 5px; border-radius: 50%; width: 12px; height: 12px; cursor: pointer; opacity: 0.5; background-color: #fff;}#slide .indi &gt; li.on { opacity: 1;}#slide .indi &gt; li:first-child { margin-left: 0;} javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120window.addEventListener(&quot;load&quot;, function () { var MOVEING_PX = 4, AUTO_TIME = 2000, slide = document.getElementById(&quot;slide&quot;), indi = document.createElement(&quot;ul&quot;), slideCnt = slide.getElementsByClassName(&quot;cnt&quot;), slideCntItem = slideCnt[0].getElementsByTagName(&quot;li&quot;), prevBtn = slide.getElementsByClassName(&quot;prev&quot;), nextBtn = slide.getElementsByClassName(&quot;next&quot;), playBtn = slide.getElementsByClassName(&quot;play&quot;), stopBtn = slide.getElementsByClassName(&quot;stop&quot;), playSet = null, before = 0, after = 0, moveIng = false; // init slideCntItem[0].style.left = 0; playBtn[0].style.display = &quot;block&quot;; var indi = document.createElement(&quot;ul&quot;); for (var i = 0; i &lt; slideCntItem.length; i++) { indi.innerHTML += &quot;&lt;li&gt;&lt;/li&gt;&quot;; } indi.classList.add(&quot;indi&quot;); indi.children[0].classList.add(&quot;on&quot;); slide.append(indi); for (var j = 0; j &lt; indi.children.length; j++) { indiClick(j); } // initEvnet nextBtn[0].addEventListener(&quot;click&quot;, function (e) { if (!moveIng) { after++; if (after &gt;= slideCntItem.length) { after = 0; } move(after, before, &quot;next&quot;); before = after; } }); prevBtn[0].addEventListener(&quot;click&quot;, function (e) { if (!moveIng) { after--; if (after &lt; 0) { after = slideCntItem.length - 1; } move(after, before); before = after; } }); playBtn[0].addEventListener(&quot;click&quot;, function () { playBtn[0].style.display = &quot;none&quot;; stopBtn[0].style.display = &quot;block&quot;; playSet = setInterval(function () { if (!moveIng) { after++; if (after &gt;= slideCntItem.length) { after = 0; } move(after, before, &quot;next&quot;); before = after; } }, AUTO_TIME); }); stopBtn[0].addEventListener(&quot;click&quot;, function () { playBtn[0].style.display = &quot;block&quot;; stopBtn[0].style.display = &quot;none&quot;; clearInterval(playSet); }); function indiClick(target) { indi.children[target].addEventListener(&quot;click&quot;, function () { if (!moveIng) { after = target; if (after &gt; before) { move(after, before, &quot;next&quot;); } else if (after &lt; before) { move(after, before); } before = after; } }); } function move(after, before, type) { var nextX = type === &quot;next&quot; ? slide.offsetWidth : slide.offsetWidth * -1, prevX = 0, set = null; set = setInterval(function () { moveIng = true; if (type === &quot;next&quot;) { nextX -= MOVEING_PX; slideCntItem[after].style.left = nextX + &quot;px&quot;; if (nextX &lt;= 0) { clearInterval(set); nextX = slide.offsetWidth; moveIng = false; } prevX -= MOVEING_PX; } else { nextX += MOVEING_PX; slideCntItem[after].style.left = nextX + &quot;px&quot;; if (nextX &gt;= 0) { clearInterval(set); nextX = slide.offsetWidth * -1; moveIng = false; } prevX += MOVEING_PX; } slideCntItem[before].style.left = prevX + &quot;px&quot;; }); indi.children[before].classList.remove(&quot;on&quot;); indi.children[after].classList.add(&quot;on&quot;); }});","link":"/2019/04/10/ui-slide-banner/"},{"title":"[UI] 탭메뉴(tab menu)","text":"vanilla JS로 제작된 기본 탭 메뉴 구현 window.addEventListener('load', function(){ var tab = document.getElementById('tab'), btn = tab.getElementsByClassName('btn')[0], cnt = tab.getElementsByClassName('cnt')[0], index = 0; btn.children[0].classList.add('on'); cnt.children[0].classList.add('on'); for(var i = 0;i < btn.children.length;i++){ (function(target){ btn.children[target].addEventListener('click', function(){ tabOn(target); }); })(i); }; function tabOn(target){ for(var i = 0;i < btn.children.length;i++){ btn.children[i].classList.remove('on'); cnt.children[i].classList.remove('on'); }; btn.children[target].classList.add('on'); cnt.children[target].classList.add('on'); } }); .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li:before, .uiWrap ol li:before { display:none; } #tab { border: 1px solid #ccc; width: 300px; } #tab .btn:after { content: ''; display: block; clear: both; } #tab .btn button { float: left; border: 0; width: 25%; height: 30px; cursor: pointer; outline: none; background-color: #ccc; } #tab .btn button:hover { background-color: #fff; } #tab .btn button.on { background-color: #fff; } #tab .cnt div { display: none; } #tab .cnt div.on { display: block; } 01 02 03 04 content01 content01 content01 content01 content01 content01 content01 content01 content01 content01 content02 content02 content02 content02 content02 content02 content02 content02 content02 content02 content03 content03 content03 content03 content03 content03 content03 content03 content03 content03 content04 content04 content04 content04 content04 content04 content04 content04 content04 content04 html1234567891011121314&lt;div id=&quot;tab&quot;&gt; &lt;div class=&quot;btn&quot;&gt; &lt;button type=&quot;button&quot;&gt;01&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;02&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;03&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;04&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;cnt&quot;&gt; &lt;div&gt;content01 content01 content01 content01 content01 content01 content01 content01 content01 content01&lt;/div&gt; &lt;div&gt;content02 content02 content02 content02 content02 content02 content02 content02 content02 content02&lt;/div&gt; &lt;div&gt;content03 content03 content03 content03 content03 content03 content03 content03 content03 content03&lt;/div&gt; &lt;div&gt;content04 content04 content04 content04 content04 content04 content04 content04 content04 content04&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536#tab { border: 1px solid #ccc; width: 300px;}#tab .btn:after { content: ''; display: block; clear: both;}#tab .btn button { float: left; border: 0; width: 25%; height: 30px; cursor: pointer; outline: none; background-color: #ccc;}#tab .btn button:hover { background-color: #fff;}#tab .btn button.on { background-color: #fff;}#tab .cnt div { display: none;}#tab .cnt div.on { display: block;} javascript12345678910111213141516171819202122232425262728window.addEventListener('load', function(){ var tab = document.getElementById('tab'), btn = tab.getElementsByClassName('btn')[0], cnt = tab.getElementsByClassName('cnt')[0], index = 0; btn.children[0].classList.add('on'); cnt.children[0].classList.add('on'); for(var i = 0;i &lt; btn.children.length;i++){ (function(target){ btn.children[target].addEventListener('click', function(){ tabOn(target); }); })(i); }; function tabOn(target){ for(var i = 0;i &lt; btn.children.length;i++){ btn.children[i].classList.remove('on'); cnt.children[i].classList.remove('on'); }; btn.children[target].classList.add('on'); cnt.children[target].classList.add('on'); }});","link":"/2019/04/08/ui-tab-menu/"},{"title":"[VIM] VIM 명령어","text":"VIM 명령어 정리 vi 실행 명령어 동작 # vi file file을 연다. # vi file1 file2 file1 과 file2 를 차례로 연다. # view file file을 읽기 모드로 연다. # vi -R file file을 읽기 모드로 연다. # vi + file file을 열때 커서가 file 본문의 마지막 행에 위치한다. # vi +n file file을 열어 n행에 위치한다. # vi -r file 손상된 파일 회복 입력모드 전환 명령어 동작 # i 커서 있는데서 입력모드 전환 # I 커서 왼쪽, 행의 처음에 몬자 삽입 # a 커서 있는 줄 끝에서 입력모드 전환 # A 커서 오른쪽, 행의 끝에 문자 삽입 # o 커서 있는 줄 아래에 빈 줄 삽입 # O 커서 있는 줄 위에 빈 줄을 삽입 # R 덮어쓰기 모드로 전환 커서 이동 명령어 동작 # ^, 0 줄의 처음으로 이동 # $ 줄의 끝으로 이동 # H 화면 맨 위로 이동 # M 화면의 중간으로 이동 # L 화면 맨 아래로 이동 # w 다음 단어 끝으로 커서 이동 # e 다음 단어 앞으로 커서 이동 # b 이전 단어로 이동 # shift + ↑ 한 페이지 앞으로 이동 # shift + ↓ 한 페이지 뒤로 이동 # 3l, 3G 현재 커서 위치한 행에서 3번째 행으로 이동 # ctrl + i 한 화면 위로 이동 # ctrl + b 한 화면 아래로 이동 # ctrl + d 반 화면 위로 이동 # ctrl + u 반 화면 아래로 이동 # ctrl + e 한 줄씩 위로 이동 # ctrl + y 한 줄씩 아래로 이동 삭제 명령어 동작 # x 한 문자 삭제 # 5x 커서가 있는 위치부터 5개의 문자를 삭제 # d + ↑ 커서있는 줄, 윗줄 2줄 삭제 # d + ↓ 커서잇는 줄, 아래줄 2줄 삭제 # dw 한 단어 삭제 # dd 한 줄 삭제 # 5dd 커서가 있는 라인부터 5개의 라인 삭제 # db 커서의 위치에서 거꾸로 한 단어 삭제 # D 한줄 내에서 커서있는 뒤 모두 삭제 # u 바로 전에 수행한 명령을 취소 # :5,10 d 5~10번째 행 삭제 복사와 붙여넣기 명령어 동작 # yy 현재 줄을 버퍼로 복사 # p 버퍼에 있는 내용을 커서 뒤에 삽입 # P 버퍼에 있는 내용을 커서 앞에 삽입 # 3y 현재 줄에서부터 아래로 3줄 복사 # :5, 10y 5~10줄을 버퍼로 복사 # :30pu 30행에 버퍼 내용을 삽입 # d 현재 커서가 위치해 있는 단어 복사 # 3yy 현재 행을 기준으로 3번째 행까지 n행 복사 문자열 찾기 명령어 동작 # /name name 문자열 찾기 # n 다음 name으로 이동 # N n과 같으며 역방향으로 이동 문자열 대체 명령어 동작 # :s/str/rep 현재 행의 str을 rep로 대체 # :l,.s/str/rep/ 1부터 현재 행의 str을 rep로 대체 # :%s/str/rep/g 파일 전체 str을 rep로 전부 대체 # :.$/aaa/bbb 커서의 위치로부터 파일의 끝까지 있는 모든 aaa를 bbb로 대체 파일 저장 및 불러오기 명령어 동작 # :w 지정된 파일에 저장 # :wq, :x, ZZ 지정된 파일에 저장하고 vi를 종료 # :w php.ini php.ini 파일에 저장 # :q 저장하지 않고 종료 # :q! 저장하지 않고 강제 종료 # :wq php.ini php.ini에 저장하고 vi를 종료 # :r php.ini php.ini의 내용을 현재 커서가 있는데로 불러온다. # :e php.ini 현재의 화면을 지우고 새로운 파일 php.ini를 불러온다. # :5,10 w php.ini 5~10 줄까지의 내용을 php.ini에 저장 기타 명령어 동작 # :set nu 행 번호 보여주기 # :set nonu 행 번호 보여주기 취소 # . 바로 전에 실행한 명령어 재 실행 # ctrl + l 불필요한 화면 정리후 다시 표시 References Linux 문서편집기 vi, vim 명령어 정리","link":"/2019/12/06/vim-command/"},{"title":"[Vue] Vue CLI 명령어(2.x)","text":"최소 뷰 기능만 들어간 HTML 파일 1개 생성 1$ vue init simple 고급 웹팩 기능을 활용한 프로젝트 구성 방식. 테스팅, 문법 검사 등을 지원 1$ vue init webpack 웹팩 최소 기능을 활용한 프로젝트 구성 방식. 빠른 화면 프로토타이밍용 1$ vue init webpack-simple 고급 브라우저파이 기능을 활용한 프로젝트 구성 방식. 테스팅, 문법 검사 등을 지원 1$ vue init browserify 브라우저파이 최소 기능을 활용한 프로젝트 구성 방식. 빠른 화면 프로토타이밍용 1$ vue init browserify-simple CLI 관련 라이브러리 설치 1$ npm install 웹팩 데브 서버 실행 1$ npm run dev","link":"/2019/07/01/vue-cli-command/"},{"title":"[Vue] Vue Cli 초기 세팅","text":"Vue CLIVue CLI는 Vue 프로젝트를 개발할 수 있게 해주는 아주 유용한 도구이며, 여기서 CLI란 Command Line Interface의 약자로서 타이핑으로 명령어를 입력하여 원하는 바를 실행시키는 도구를 말한다. 윈도우에서는 명령 프롬프트(CMD), 맥에서는 터미널을 이용한다고 볼 수 있다. Vue CLI은 내부적으로 Webpack을 활용한다. Vue CLI로 명령을 실행 시키면 CLI가 자동으로 최적화된 Webpack 형태의 결과물을 생성 시켜 준다. Vue CLI 2.x 와 Vue CLI 3.x 버전 비교프로젝트를 생성 CLI2 : eslint, unit test, night watch 등 낯선것들 선택 필요 CLI3 : default (babel, eslint) 를 선택하면 가장 기본적인 설정으로 프로젝트가 생성, 나중에 옵션을 추가 가능작성 필요 프로젝트 구성 CLI2 : simple, webpack, webpack-simple, pwa 등 템플릿 리스트 중 하나를 선택해서 프로젝트 구성 CLI3 : 프로젝트에 플러그인 기반으로 원하는 설정 추가 웹팩 설정 파일 CLI2 : webpack.config.js 파일이 최상단 디렉토리에 있다. CLI3 : 없음, root 경로에 vue.config.js 파일을 설정하고 내용 추가 ES6 이해도 CLI2 : 필요 X CLI3 : 필요 O node modules CLI2 : 자동설치 안됨. $ npm install 필요 CLI3 : 자동설치 설치 환경 node.js npm CLI 설치12$ npm i -g @vue/cli // vue-cli 3.x$ npm i -g vue-cli // vue-cli 2.x 버전 확인12$ vue --version@vue/cli 4.0.5 프로젝트 생성babel과 eslint 기반인 default 옵션을 선택한다. 12$ vue create 'ProjectName' // vue-cli 3.X$ vue init webpack 'ProjectName' // vue-cli 2.X 로컬 서버 실행12$ npm run serve // vue-cli 3.x$ npm run dev // vue-cli 2.x http://localhost:8080/ 로 들어가면 뷰 로고가 있는 로컬 페이지를 볼 수 있다.$ npm install 명령어를 통해 NPM패키지를 설치하지 않아도 서버가 작동되는 것을 확인할 수 있는데 vue cli가 이미 node_modules디렉터토리 안에 라이브러리들을 다운받았기 때문이다. vue cli의 기본 템플릿은 babel, eslint, unit-mocha 를 포함한다. Babel: 자바스크립트 컴파일러다. 최신버전의 자바스크립트 문법은 브라우저가 이해하지 못하기 때문에 Babel은이 브라우저가 이해할 수 있는 문법으로 변환시켜준다. ES6, ES7 등의 최신 문법을 사용해서 코딩을 할 수 있기 때문에 생산성이 향상된다. ESLint: 코딩 스타일 가이드를 따르지 않거나 문제가 있는 코드나 안티 패턴을 찾아 표시를 달아 놓는 도구이다. unit-mocha: javascript 진영에서 테스트 러너를 지원하는 테스트 프레임워크이다. References Vue CLI 3.0 사용하기Vue CLI 3.X 사용하기Vue CLI 3 사용법[Vue.js] Vue Version 비교 (cli2 vs cli3)Vue-CLI 도구 활용방법","link":"/2019/11/01/vue-cli-init/"},{"title":"[Vue] Vue Cli 2.x를 이용한 Github페이지 만들기","text":"Vue Cli 2.x 버전을 이용하여 프로젝트를 생성하고 깃허브 페이지에 적용하는 방법을 알아보도록 한다. 설치 시작프로젝트 설치할 디렉토리로 가서 웹팩 설치뒤에 해당 디렉토리로 이동, npm까지 설치해준다. 123$ vue webpack init 'projact name'$ cd 'projact name'$ npm install 사용자 정보 수정설치가 완료되면 config 디렉토리의 index.js파일을 열어준 뒤 build 값을 아래처럼 수정해준다. 1234567891011build: { index: path.resolve(__dirname, '../docs/index.html'), assetsRoot: path.resolve(__dirname, '../docs'), assetsSubDirectory: 'static', assetsPublicPath: '', productionSourceMap: true, devtool: '#source-map', productionGzip: false, productionGzipExtensions: ['js', 'css'], bundleAnalyzerReport: process.env.npm_config_report} 수정되는 항목 index 에서 dist &gt; docs assetsRoot 에서 dist &gt; docs assetsPublicPath 에서 '/' &gt; '' 빌드수정이 완료되면 빌드해준다. 1$ npm run build 원격 저장소 설정빌드후에 깃허브 원격저장소에 push를 해준뒤 원격저장소 세팅페이지로 들어간다.GitHub Pages 항목에서 Source 옵션을 master branch /docs folder로 선택해주면 끝이다.페이지 url은 https://[유저이름].github.io/[저장소이름]/ 로 들어가면 된다. 위에까지의 과정은 이곳에 쉽게 잘 정리되어 있다. References vue github page 만들기Problems deploying to github pages with vue project","link":"/2019/11/02/vue-cli2-github-page/"},{"title":"[Vue] Vue Cli 3.x를 이용한 Github페이지 만들기","text":"Vue Cli 2.x 버전을 이용하여 프로젝트를 생성하면 웹펙 설정파일이 자동으로 생성되지만 3.x 버전부터는 직접 만들어줘야 한다. 때문에 2.x 버전하고 방법이 약간 다르다. 설치할 디렉토리로 가서 프로젝트를 생성해 준다. 1$ vue create 'ProjectName' 프로젝트 폴더로 이동하여 원격 저장소에 연결시켜 준 뒤 푸쉬해준다. 123cd 'ProjectName'git remote add origin 'url'git push origin master 코드를 빌드하면 dist 디렉토리에 출력되어도록 되어있기 때문에 vue.config.js 파일을 만들어서 설정을 변경해둔다. 우선 최상단 디렉토리에 vue.config.js파일을 생성해 준 뒤 아래 코드를 입력해준다. 원격 저장소의 프로젝트명과 동일하게 publicPath를 수정해준다. 12345// vue.config.js module.exports = { publicPath: '/ProjectName/', outputDir: 'docs'} 빌드를 하면 /docs 디렉토리가 생성된다. 후에 최상단 디렉토리의 .gitignore 파일에 /dist 를 주석처리 해준다. 이제 깃에 푸쉬해준다. 123git add ./git commit -m &quot;commit message&quot;git push origin 이제 깃허브로 들어가서 저장소 설정으로 간 뒤 GitHub Pages 항목에서 master branch /docs folder 를 셀렉해준다. 이제 https://[유저이름].github.io/[저장소이름] 으로 들어가면 뷰 페이지를 확인할 수 있다. (반영에 시간이 조금 걸린다. 당분간은 404가 표시되어있다.) References vue-cli で作ったサイトを GitHub Pages にデプロイするDeploy vue-cli 3 project to github pages","link":"/2019/11/05/vue-cli3-github-page/"},{"title":"[Crawling] 웹 크롤링(Web Crawling)","text":"특정 데이터가 필요한 경우 Node.js를 이용하여 웹 크롤링을 하면 쉽게 데이터를 추출할 수 있다. 설치 환경 node.js npm 설치 모듈 request웹 페이지의 HTML문서를 그대로 가져오기 위한 모듈 cheerioHTML 문서를 파싱(parsing)하여 필요한 정보만을 가져올 수 있도록 도와주는 모듈, 제이쿼리 셀렉터를 사용할 수 있다. 작업 순서 원하는 디렉토리에 폴더 생성 후 js 파일 생성(crawling.js로 만들었음) 터미널에서 프로젝트 폴더로 진입 package 생성(이름만 설정한뒤 모두 예스) 1&amp; npm init 필요 모듈 설치 12$ npm install cheerio $ npm install request package.json 파일에 아래처럼 해당 모듈의 버전이 나타난다면 제대로 설치가 된 것이다. 1234&quot;dependencies&quot;: { &quot;cheerio&quot;: &quot;^1.0.0-rc.2&quot;, &quot;request&quot;: &quot;^2.83.0&quot;} 생성한 crawling.js 파일에 설치한 모듈을 불러준다. 12var cheerio = require('cheerio');var request = require('request'); url 변수에 파싱할 주소를 입력하고, request 모듈을 이용하여 웹페이지를 로드한다. 12345var url = 'http://www.naver.com';request(url, function (error, response, html){ var $ = cheerio.load(html); // 여기서 제이쿼리 셀렉터를 이용하여 원하는 정보를 가져올 수 있다.}); 아래는 전체 코드이다. 12345678910111213var cheerio = require('cheerio');var request = require('request');var url = 'http://www.naver.com';request(url, function (error, response, html){ var $ = cheerio.load(html); // 여기서 제이쿼리 셀렉터를 이용하여 원하는 정보를 가져올 수 있다. console.log($('.naver_logo').text())}); References Node.js로 멜론 순위 차트 데이터 파싱[Node.js] node.js환경에서 웹 크롤링 하기(cheerio-httpcli)[Node.js] 크롤링 DOM parsing ( request, cheerio, iconv 모듈 )","link":"/2019/08/20/web-crawling/"},{"title":"[Web] Web Technology Terminology","text":"틈틈히 웹 관련 용어를 정리하는 곳 용어 설명 dump 프로그램 디버그 또는 시스템 테스트의 목적을 위해 기록되는 파일 temp 임시 폴더","link":"/2019/03/25/web-technology-terminology/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"youngcart5","slug":"youngcart5","link":"/tags/youngcart5/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"economy","slug":"economy","link":"/tags/economy/"},{"name":"insurance","slug":"insurance","link":"/tags/insurance/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"heroku","slug":"heroku","link":"/tags/heroku/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"jekyll","slug":"jekyll","link":"/tags/jekyll/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"web accessibility","slug":"web-accessibility","link":"/tags/web-accessibility/"},{"name":"jquey","slug":"jquey","link":"/tags/jquey/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"es5","slug":"es5","link":"/tags/es5/"},{"name":"es8","slug":"es8","link":"/tags/es8/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"vanillajs","slug":"vanillajs","link":"/tags/vanillajs/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"pure function","slug":"pure-function","link":"/tags/pure-function/"},{"name":"functional programming","slug":"functional-programming","link":"/tags/functional-programming/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"yum","slug":"yum","link":"/tags/yum/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"rest","slug":"rest","link":"/tags/rest/"},{"name":"restfull","slug":"restfull","link":"/tags/restfull/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"web crawling","slug":"web-crawling","link":"/tags/web-crawling/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"jsx","slug":"jsx","link":"/tags/jsx/"},{"name":"sass","slug":"sass","link":"/tags/sass/"},{"name":"svelte.js","slug":"svelte-js","link":"/tags/svelte-js/"},{"name":"ui","slug":"ui","link":"/tags/ui/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"}],"categories":[{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"javascript","slug":"front-end/javascript","link":"/categories/front-end/javascript/"},{"name":"css","slug":"front-end/css","link":"/categories/front-end/css/"},{"name":"server","slug":"server","link":"/categories/server/"},{"name":"economy","slug":"economy","link":"/categories/economy/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"centos","slug":"server/centos","link":"/categories/server/centos/"},{"name":"html","slug":"front-end/html","link":"/categories/front-end/html/"},{"name":"jquery","slug":"front-end/jquery","link":"/categories/front-end/jquery/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"insurance","slug":"economy/insurance","link":"/categories/economy/insurance/"},{"name":"express","slug":"server/express","link":"/categories/server/express/"},{"name":"git","slug":"git/git","link":"/categories/git/git/"},{"name":"github","slug":"git/github","link":"/categories/git/github/"},{"name":"linux","slug":"server/linux","link":"/categories/server/linux/"},{"name":"mysql","slug":"server/mysql","link":"/categories/server/mysql/"},{"name":"mac","slug":"mac","link":"/categories/mac/"},{"name":"network","slug":"network","link":"/categories/network/"},{"name":"nginx","slug":"server/nginx","link":"/categories/server/nginx/"},{"name":"node.js","slug":"node-js","link":"/categories/node-js/"},{"name":"react","slug":"front-end/react","link":"/categories/front-end/react/"},{"name":"sass","slug":"front-end/sass","link":"/categories/front-end/sass/"},{"name":"typescript","slug":"front-end/typescript","link":"/categories/front-end/typescript/"},{"name":"svelte.js","slug":"front-end/svelte-js","link":"/categories/front-end/svelte-js/"},{"name":"ui","slug":"front-end/ui","link":"/categories/front-end/ui/"},{"name":"vue.js","slug":"front-end/vue-js","link":"/categories/front-end/vue-js/"}]}